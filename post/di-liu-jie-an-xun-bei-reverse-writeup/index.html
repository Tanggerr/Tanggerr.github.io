<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="Reverse &amp; Crypto">
<meta name="theme-color" content="#000">
<title>第六届安洵杯 Reverse WriteUp | Tanggerr&#39;s blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1740639212390">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="第六届安洵杯 Reverse WriteUp" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Tanggerr&#39;s blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">Reverse &amp; Crypto</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Tanggerr</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">18</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">0</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper  auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E4%BD%A0%E8%A7%81%E8%BF%87%E8%93%9D%E8%89%B2%E7%9A%84%E5%B0%8F%E9%B2%B8%E9%B1%BC">一. 你见过蓝色的小鲸鱼</a></li>
<li><a href="#%E4%BA%8C-%E6%84%9F%E8%A7%89%E6%9C%89%E7%82%B9%E7%82%B9%E7%AE%80%E5%8D%95">二. 感觉有点点简单</a></li>
<li><a href="#%E4%B8%89-%E7%89%A2%E5%A4%A7%E6%83%B3%E4%BD%A0%E4%BA%86">三. 牢大想你了</a></li>
<li><a href="#%E5%9B%9B-mobilego">四. mobilego</a></li>
<li><a href="#%E4%BA%94-%E4%BD%A0%E5%A5%BDpe">五. 你好PE</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://Tanggerr.github.io/post/di-liu-jie-an-xun-bei-reverse-writeup/"> 第六届安洵杯 Reverse WriteUp </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2023-12-27 00:34:56">2023-12-27</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >17<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >2728<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
      
    <span
      id="/post/di-liu-jie-an-xun-bei-reverse-writeup/"
      data-flag-title="第六届安洵杯 Reverse WriteUp"
      class="meta-item pc-show leancloud_visitors"
    >
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span
        ><span class="language" data-lan="view">浏览量:</span>:<span
          class="leancloud-visitors-count"
        ></span
      ></span>
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <h2 id="一-你见过蓝色的小鲸鱼">一. 你见过蓝色的小鲸鱼</h2>
<ul>
<li>
<p>找到关键加密函数：</p>
</li>
<li>
<pre><code class="language-c">CHAR *__cdecl sub_4577E0(HWND hDlg)
{
  CHAR *result; // eax
  CHAR *v2; // [esp+10h] [ebp-154h]
  void *v3; // [esp+24h] [ebp-140h]
  CHAR *v4; // [esp+114h] [ebp-50h]
  CHAR *lpString; // [esp+120h] [ebp-44h]
  HWND DlgItem; // [esp+12Ch] [ebp-38h]
  HWND hWnd; // [esp+138h] [ebp-2Ch]
  int v8; // [esp+144h] [ebp-20h]
  int WindowTextLengthA; // [esp+150h] [ebp-14h]

  __CheckForDebuggerJustMyCode(&amp;unk_52105E);
  hWnd = GetDlgItem(hDlg, 1003);
  DlgItem = GetDlgItem(hDlg, 1004);
  WindowTextLengthA = GetWindowTextLengthA(hWnd);
  v8 = GetWindowTextLengthA(DlgItem);
  lpString = (CHAR *)j__malloc(__CFADD__(WindowTextLengthA, 16) ? -1 : WindowTextLengthA + 16);
  result = (CHAR *)j__malloc(__CFADD__(v8, 16) ? -1 : v8 + 16);
  v4 = result;
  if ( lpString &amp;&amp; result )
  {
    GetWindowTextA(hWnd, lpString, WindowTextLengthA + 16);
    GetWindowTextA(DlgItem, v4, v8 + 16);
    v3 = operator new(0x10u);
    if ( v3 )
    {
      sub_451B43(0x10u);
      v2 = (CHAR *)sub_450CE3(v3);
    }
    else
    {
      v2 = 0;
    }
    sub_44FC2B(&amp;unk_51D38C, 0x10u);
    sub_45126F(lpString, WindowTextLengthA, (int)v4, v8);
    sub_450199(v2);
    j__free(lpString);
    j__free(v4);
    result = v2;
    if ( v2 )
      return (CHAR *)sub_44F77B(1);
  }
  return result;
}


int __thiscall sub_4571A0(int this, void *Src, size_t a3, void *a4, size_t a5)
{
  const void *v5; // eax
  int result; // eax
  size_t v7; // [esp-4h] [ebp-12Ch]
  int v8; // [esp+10h] [ebp-118h]

  __CheckForDebuggerJustMyCode(&amp;unk_52102F);
  if ( operator new(0x2Cu) )
  {
    sub_451A4E(0x2Cu);
    v8 = sub_450CBB(Src, a3);
  }
  else
  {
    v8 = 0;
  }
  sub_4521B5(&amp;unk_51C048, &amp;unk_51C000);
  sub_451F08(a4, a5);
  *(_DWORD *)(this + 12) = sub_44FEF6(v8);
  *(_DWORD *)(this + 4) = j_unknown_libname_47(*(_DWORD *)(this + 12));
  v7 = *(_DWORD *)(this + 12);
  v5 = (const void *)sub_4505A4(v8);
  j__memmove(*(void **)(this + 4), v5, v7);
  result = v8;
  if ( v8 )
    return sub_44FF0A(1);
  return result;
}


sub_4521B5(&amp;unk_51C048, &amp;unk_51C000);//两个都是blowfish的表
</code></pre>
</li>
<li>
<p>发现为blowfish加密，密钥就是题目用户名（blowfish密钥不定长）</p>
</li>
<li>
<p>在线网站解密</p>
</li>
<li>
<p>QHRoZWJsdWVmMXNo</p>
</li>
<li>
<p>也可以脚本解密</p>
</li>
<li>
<pre><code class="language-python">from Crypto.Cipher import Blowfish
key=b'UzBtZTBuZV9EMGcz'
bf=Blowfish.new(key,Blowfish.MODE_ECB)
enc=b&quot;\x11\xA5\x1F\x04\x95\x50\xE2\x50\x8F\x17\xE1\x6C\xF1\x63\x2B\x47&quot;
print(bf.decrypt(enc))
</code></pre>
</li>
<li>
<p>则有：<em><strong>D0g3{UzBtZTBuZV9EMGczQHRoZWJsdWVmMXNo}</strong></em></p>
</li>
</ul>
<h2 id="二-感觉有点点简单">二. 感觉有点点简单</h2>
<ul>
<li>
<p>简单题，RC4魔改加base64魔改</p>
</li>
<li>
<pre><code class="language-C">__int64 sub_1400016F0()
{
  __int64 v1; // [rsp+20h] [rbp-78h] BYREF
  PVOID NumberOfBytes_4; // [rsp+28h] [rbp-70h]
  PVOID P; // [rsp+30h] [rbp-68h]
  __int64 v4; // [rsp+38h] [rbp-60h]
  __int64 v5; // [rsp+40h] [rbp-58h]
  __int64 v6; // [rsp+48h] [rbp-50h] BYREF
  const char *v7; // [rsp+50h] [rbp-48h]
  const char *v8; // [rsp+58h] [rbp-40h]
  struct _UNICODE_STRING DestinationString; // [rsp+60h] [rbp-38h] BYREF
  char v10[40]; // [rsp+70h] [rbp-28h] BYREF

  HIDWORD(v1) = 4096;
  memset(&amp;v6, 0, sizeof(v6));
  RtlInitUnicodeString(&amp;DestinationString, L&quot;\\??\\C:\\Users\\Public\\flag.txt&quot;);
  NumberOfBytes_4 = ExAllocatePool(NonPagedPool, 0x1000ui64);
  P = ExAllocatePool(NonPagedPool, 0x1000ui64);
  if ( NumberOfBytes_4 &amp;&amp; P )
  {
    v4 = HIDWORD(v1);
    memset(P, 0, HIDWORD(v1));
    v5 = HIDWORD(v1);
    memset(NumberOfBytes_4, 0, HIDWORD(v1));
    qmemcpy(v10, &amp;DestinationString, 0x10ui64);
    LOBYTE(v1) = sub_140001040(v10, v6, NumberOfBytes_4, (char *)&amp;v1 + 4);
    if ( (_BYTE)v1 )
    {
      if ( HIDWORD(v1) &lt;= 0xC00 )
      {
        sub_1400011F0(NumberOfBytes_4, HIDWORD(v1), &quot;the_key_&quot;, 8i64, v1);
        sub_140001360((__int64)P, (__int64)NumberOfBytes_4, SHIDWORD(v1));
        LOBYTE(v1) = sub_140001560((__int64)P, 56);
        v8 = &quot;tips: YES, RIGHT FLAG.   you got it!&quot;;
        v7 = &quot;tips: NO , WRONG ANSWER. try again !&quot;;
        if ( (_BYTE)v1 )
          DbgPrint(&quot;tips: %s\n&quot;, v8);
        else
          DbgPrint(&quot;tips: %s\n&quot;, v7);
      }
      else
      {
        DbgPrint(&quot;tips: file to long \n&quot;);
      }
    }
    else
    {
      DbgPrint(&quot;tips: can not read|open file\n&quot;);
    }
  }
  else
  {
    DbgPrint(&quot;tips: can not malloc\n&quot;);
  }
  if ( NumberOfBytes_4 )
  {
    ExFreePoolWithTag(NumberOfBytes_4, 0);
    NumberOfBytes_4 = 0i64;
  }
  if ( P )
  {
    ExFreePoolWithTag(P, 0);
    P = 0i64;
  }
  return 0i64;
}
</code></pre>
</li>
<li>
<p>RC4魔改：</p>
</li>
<li>
<pre><code class="language-c">__int64 __fastcall sub_1400011F0(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4)
{
  __int64 result; // rax
  unsigned __int8 v5; // [rsp+20h] [rbp-18h]
  unsigned __int8 v6; // [rsp+21h] [rbp-17h]
  unsigned int i; // [rsp+24h] [rbp-14h]

  v5 = 0;
  v6 = 0;
  sub_1400015B0(a3, a4);
  for ( i = 0; ; ++i )
  {
    result = a2;
    if ( i &gt;= a2 )
      break;
    v5 = (v5 + 1) % 64;
    v6 = (byte_140003010[v5] + v6) % 64;
    sub_1400018E0(&amp;byte_140003010[v5], &amp;byte_140003010[v6]);
    *(_BYTE *)(a1 + i) ^= (v6 ^ v5) &amp; byte_140003010[(unsigned __int8)(((v6 ^ v5)
                                                                      + byte_140003010[v6]
                                                                      + byte_140003010[v5])
                                                                     % 64)];
  }
  return result;
}
</code></pre>
</li>
<li>
<p>base64魔改：</p>
</li>
<li>
<pre><code class="language-c">__int64 __fastcall sub_140001360(__int64 a1, __int64 a2, int a3)
{
  int v4; // [rsp+0h] [rbp-88h]
  int v5; // [rsp+4h] [rbp-84h]
  char v6[80]; // [rsp+10h] [rbp-78h] BYREF

  strcpy(v6, &quot;4KBbSzwWClkZ2gsr1qA+Qu0FtxOm6/iVcJHPY9GNp7EaRoDf8UvIjnL5MydTX3eh&quot;);
  v4 = 0;
  v5 = 0;
  while ( v4 &lt; a3 )
  {
    *(_BYTE *)(a1 + v5) = v6[*(_BYTE *)(a2 + v4) &amp; 0x3F];
    *(_BYTE *)(a1 + v5 + 1) = v6[(4 * (*(_BYTE *)(a2 + v4 + 1) &amp; 0xF)) | ((*(_BYTE *)(a2 + v4) &amp; 0xC0) &gt;&gt; 6)];
    *(_BYTE *)(a1 + v5 + 2) = v6[(16 * (*(_BYTE *)(a2 + v4 + 2) &amp; 3)) | ((*(_BYTE *)(a2 + v4 + 1) &amp; 0xF0) &gt;&gt; 4)];
    *(_BYTE *)(a1 + v5 + 3) = v6[(*(_BYTE *)(a2 + v4 + 2) &amp; 0xFC) &gt;&gt; 2];
    v4 += 3;
    v5 += 4;
  }
  if ( a3 % 3 == 1 )
  {
    *(_BYTE *)(a1 + v5 - 2) = 61;
    *(_BYTE *)(a1 + v5 - 1) = 61;
  }
  else if ( a3 % 3 == 2 )
  {
    *(_BYTE *)(a1 + v5 - 1) = 61;
  }
  return 0i64;
}
</code></pre>
</li>
<li>
<p>检验：</p>
</li>
<li>
<pre><code class="language-c">bool __fastcall sub_140001560(__int64 a1, int a2)
{
  return a2 == 56 &amp;&amp; !(unsigned int)sub_1400019F0(a1, &quot;6zviISn2McHsa4b108v29tbKMtQQXQHA+2+sTYLlg9v2Q2Pq8SP24Uw=&quot;, 56i64);
}
</code></pre>
</li>
<li>
<p>编写脚本：</p>
</li>
<li>
<pre><code class="language-python">def KSA(key):
    key_length = len(key)
    S = list(range(64))
    j = 0
    for i in range(64):
        j = (j + S[i] + key[i % key_length]) % 64
        S[i], S[j] = S[j], S[i]
    return S


def PRGA(S):
    i = 0
    j = 0
    while True:
        i = (i + 1) % 64
        j = (j + S[i]) % 64
        S[i], S[j] = S[j], S[i]
        K = (i^j) &amp; S[(((i^j)+S[i] + S[j]) % 64)]
        yield K


def RC4(key):
    S = KSA(key)
    keystream = PRGA(S)
    return keystream


if __name__ == '__main__':
    key = 'the_key_'
    c = '6zviISn2McHsa4b108v29tbKMtQQXQHA+2+sTYLlg9v2Q2Pq8SP24Uw4'
    table = '4KBbSzwWClkZ2gsr1qA+Qu0FtxOm6/iVcJHPY9GNp7EaRoplaintextf8UvIjnL5MyplaintextTX3eh'

    # c = c.replace('=', table[0])
    plaintext = []
    for i in range(0, len(c), 4):
        x = [table.inplaintextex(j) for j in c[i: i + 4]]
        plaintext.append(x[0] | ((x[1] &amp; 3) &lt;&lt; 6))
        plaintext.append((x[1] &gt;&gt; 2) | ((x[2] &amp; 0xf) &lt;&lt; 4))
        plaintext.append((x[2] &gt;&gt; 4) | (x[3] &lt;&lt; 2))
    print(plaintext)
    key = key.encode()
    keystream = RC4(key)
    ciphertext = []
    for b in plaintext:
        ciphertext.append(chr(b ^ next(keystream)))
    print(&quot;&quot;.join(ciphertext))
</code></pre>
</li>
<li>
<p><em><strong>D0g3{608292C4-15400BA4-B3299A5C-704C292D}</strong></em></p>
</li>
<li>
<p>注意：可以把原密文最后的等号直接替换成table[0]</p>
</li>
</ul>
<h2 id="三-牢大想你了">三. 牢大想你了</h2>
<ul>
<li>
<p>直接反编译**&quot;\GalgamePro_BackUpThisFolder_ButDontShipItWithYourGame\Managed\Assembly-CSharp.dll&quot;**</p>
</li>
<li>
<pre><code class="language-c#">	public void OnValueChanged(string ABBAAAABBBBAAABABBBABAAABAABAABBABBBBABAABAABAB)
	{
		uint[] str = new uint[]
		{
			286331153U,
			286331153U,
			286331153U,
			286331153U
		};
		byte[] strBytes = Encoding.UTF8.GetBytes(ABBAAAABBBBAAABABBBABAAABAABAABBABBBBABAABAABAB);
		int paddingCount = 8 - strBytes.Length % 8;
		byte[] paddedArray = new byte[strBytes.Length + paddingCount];
		Array.Copy(strBytes, paddedArray, strBytes.Length);
		uint[] uintArray = new uint[paddedArray.Length / 4];
		Buffer.BlockCopy(paddedArray, 0, uintArray, 0, paddedArray.Length);
		uint[] encryptedData = new uint[0];
		AAABAAABABABAAABBABBABAAAABBAABBAABABBBBBABAAAB str2 = new AAABAAABABABAAABBABBABAAAABBAABBAABABBBBBABAAAB(str);
		for (int i = 0; i &lt; uintArray.Length; i += 2)
		{
			encryptedData = encryptedData.Concat(str2.BABBBBBBAAAAAABABBBAAAABBABBBAABABAAABABBAAABBA(uintArray[i], uintArray[i + 1])).ToArray&lt;uint&gt;();
		}
		uint[] array = new uint[]
		{
			3363017039U,
			1247970816U,
			549943836U,
			445086378U,
			3606751618U,
			1624361316U,
			3112717362U,
			705210466U,
			3343515702U,
			2402214294U,
			4010321577U,
			2743404694U
		};
		MonoBehaviour.print(array);
		if (array.SequenceEqual(encryptedData))
		{
			this.BBBAAAAABABABABBABAAAAABBABBAABBABABABABBBABAAB = 5;
			this.ABAABAAABABABABABBBBBAAABBAABBBBBAABAAAABBABABB(&quot;port&quot;);
			this.BAABAABBABABABABBBABBBBABBBBBBBABABBAABBABABABB(&quot;牢大&quot;);
			this.AAAABBABAAAABBAABAABAABAABBBAAABBBABBBBBAABABBA(&quot;哈哈，我没有变成耐摔王&quot;);
			return;
		}
		this.BBBAAAAABABABABBABAAAAABBABBAABBABABABABBBABAAB = 5;
		this.ABAABAAABABABABABBBBBAAABBAABBBBBAABAAAABBABABB(&quot;耐摔王&quot;);
		this.BAABAABBABABABABBBABBBBABBBBBBBABABBAABBABABABB(&quot;狂暴牢大&quot;);
		this.AAAABBABAAAABBAABAABAABAABBBAAABBBABBBBBAABABBA(&quot;获得成就“耐摔王”&quot;);
	}
</code></pre>
</li>
<li>
<p>找到关键加密函数：</p>
</li>
<li>
<pre><code class="language-c#">	// Token: 0x060000AA RID: 170 RVA: 0x000058FC File Offset: 0x00003AFC
	public uint[] BABBBBBBAAAAAABABBBAAAABBABBBAABABAAABABBAAABBA(uint ABBAABAAAAAABAAAABBBBBBABAABAAAABBBABBBAABBABBA, uint BAABBAAAAABABBAABBABBAABABABABABABAAABABBBABABA)
	{
		uint v0 = ABBAABAAAAAABAAAABBBBBBABAABAAAABBBABBBAABBABBA;
		uint v = BAABBAAAAABABBAABBABBAABABABABABABAAABABBBABABA;
		uint sum = 0U;
		uint delta = 2654435769U;
		uint[] str2 = this.BBABABBBABBABABAAABBBAABBAAAAAAABBBBBAABBAAAAAA;
		for (int i = 0; i &lt; 32; i++)
		{
			sum += delta;
			v0 += ((v &lt;&lt; 4) + str2[0] ^ v + sum ^ (v &gt;&gt; 5) + str2[1]);
			v += ((v0 &lt;&lt; 4) + str2[2] ^ v0 + sum ^ (v0 &gt;&gt; 5) + str2[3]);
		}
		return new uint[]
		{
			v0,
			v
		};
	}
</code></pre>
</li>
<li>
<p>这些混淆不去也罢，也能看懂</p>
</li>
<li>
<p>tea，直接套脚本解密：</p>
</li>
<li>
<pre><code class="language-python">from ctypes import *

def decrypt(v, k):
    v0 = c_uint32(v[0])
    v1 = c_uint32(v[1])
    delta = 2654435769
    sum1 = c_uint32(delta*32)
    for i in range(32):
        v1.value -= ((v0.value &lt;&lt; 4) + k[2]) ^ (v0.value + sum1.value) ^ ((v0.value &gt;&gt; 5) + k[3])
        v0.value -= ((v1.value &lt;&lt; 4) + k[0]) ^ (v1.value + sum1.value) ^ ((v1.value &gt;&gt; 5) + k[1])
        sum1.value -= delta
    return v0.value.to_bytes(4,'little')+v1.value.to_bytes(4,'little')


if __name__ == '__main__':
    a=[3363017039,1247970816]
    a1=[549943836,445086378]
    a2=[3606751618,1624361316]
    a3=[3112717362,705210466]
    a4=[3343515702,2402214294]
    a5=[4010321577,2743404694]
    k=[286331153, 286331153, 286331153, 286331153]
    res= decrypt(a, k)+decrypt(a1,k)+decrypt(a2,k)+decrypt(a3,k)+decrypt(a4,k)+decrypt(a5,k)
    print(&quot;解密后数据:&quot;, res)
</code></pre>
<ul>
<li><em><strong>D0g3{it_is_been_a_long_day_without_you_my_friend}</strong></em></li>
</ul>
</li>
</ul>
<h2 id="四-mobilego">四. mobilego</h2>
<ul>
<li>
<p>MainActivity如下：</p>
</li>
<li>
<pre><code class="language-java">package com.example.mobilego;

import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;
import androidx.appcompat.app.AppCompatActivity;
import game.Game;

/* loaded from: classes3.dex */
public class MainActivity extends AppCompatActivity {
    private Button button;
    private EditText editText;

    /* JADX INFO: Access modifiers changed from: protected */
    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        this.editText = (EditText) findViewById(R.id.editText);
        Button button = (Button) findViewById(R.id.button);
        this.button = button;
        button.setOnClickListener(new View.OnClickListener() { // from class: com.example.mobilego.MainActivity$$ExternalSyntheticLambda0
            @Override // android.view.View.OnClickListener
            public final void onClick(View view) {
                MainActivity.this.m44lambda$onCreate$0$comexamplemobilegoMainActivity(view);
            }
        });
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* renamed from: lambda$onCreate$0$com-example-mobilego-MainActivity  reason: not valid java name */
    public /* synthetic */ void m44lambda$onCreate$0$comexamplemobilegoMainActivity(View v) {
        if (Game.checkflag(this.editText.getText().toString()).equals(getResources().getString(R.string.cmp))) {
            Toast.makeText(this, &quot;yes your flag is right&quot;, 0).show();
        } else {
            Toast.makeText(this, &quot;No No No&quot;, 0).show();
        }
    }
}
</code></pre>
</li>
<li>
<p>注意checkflag函数为native函数</p>
</li>
<li>
<p>frida简单调试一下，发现是一个替换</p>
</li>
<li>
<pre><code class="language-python">cmp='49021}5f919038b440139g74b7Dc88330e5d{6'
tmp='vIlDoLjtEpkCmyzfqbshucxwiAagKFBdGHJner'
table='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKL'
flag=''
for i in table:
    for j in tmp:
        if ord(i)==ord(j):
            flag+=cmp[tmp.index(j)]
        else:
            continue
print(flag)
</code></pre>
</li>
<li>
<p><em><strong>D0g3{4c3b5903d11461f94478b7302980e958}</strong></em></p>
</li>
</ul>
<h2 id="五-你好pe">五. 你好PE</h2>
<ul>
<li>
<pre><code class="language-c">int __cdecl main_0(int argc, const char **argv, const char **envp)
{
  int v4; // [esp+4Ch] [ebp-10h] BYREF
  int v5; // [esp+50h] [ebp-Ch]
  LPVOID lpAddress; // [esp+54h] [ebp-8h]

  __CheckForDebuggerJustMyCode(&amp;unk_51E018);
  v5 = 0;
  v4 = 0;
  lpAddress = (LPVOID)sub_450DF0();             // 获取资源文件
  if ( lpAddress )
  {
    v5 = sub_44E753(0, lpAddress, 1, &amp;v4);      // 资源文件进行加密
    VirtualFree(lpAddress, 0, 0x8000u);
    return v4;
  }
  else
  {
    sub_44EA73(&quot;find res failed\n&quot;);
    return 0;
  }
}
</code></pre>
</li>
<li>
<p>实现对资源文件的加密操作</p>
</li>
<li>
<p>跟进找资源文件</p>
</li>
<li>
<pre><code class="language-c">int __cdecl sub_455DB0(int a1, int a2, int a3, int a4)
{
  __CheckForDebuggerJustMyCode(&amp;unk_51E02A);
  switch ( a1 )
  {
    case 0:
      return sub_4513F9(a2, a3 != 0, a4);
    case 1:
      sub_44F89C(a2);
      break;
    case 2:
      return sub_44F2A7(a2, a3);
  }
  return 0;
}
</code></pre>
</li>
<li>
<pre><code class="language-c">_DWORD *__cdecl sub_455750(int a1, int a2, _DWORD *a3)
{
  void (__stdcall *v4)(_DWORD *); // [esp+4Ch] [ebp-10h]
  _DWORD *v5; // [esp+50h] [ebp-Ch]
  int v6; // [esp+58h] [ebp-4h]

  __CheckForDebuggerJustMyCode(&amp;unk_51E02A);
  v6 = sub_450FAD();
  if ( v6 )
  {
    v5 = (_DWORD *)(*(int (__stdcall **)(int, int))(v6 + 24))(64, 28);
    if ( v5 )
    {
      v5[3] = v6;
      v5[4] = a2;
      v5[5] = 0;
      v5[6] = 0;
      if ( sub_44FCC5(v5, a1, a2) )
      {
        if ( a3 )
          *a3 = 0;
        return v5;
      }
      else
      {
        if ( a3 )
          *a3 = v5[6];
        v4 = *(void (__stdcall **)(_DWORD *))(v6 + 28);
        v4(v5);
        v4((_DWORD *)v6);
        return 0;
      }
    }
    else
    {
      if ( a3 )
        *a3 = 255;
      return 0;
    }
  }
  else
  {
    if ( a3 )
      *a3 = 255;
    return 0;
  }
}
</code></pre>
</li>
<li>
<p>注意到此处的a1就是资源文件起始地址</p>
</li>
<li>
<p>跟进</p>
</li>
<li>
<pre><code class="language-c">int __cdecl sub_455870(_DWORD *a1, int a2, int a3)
{
  __CheckForDebuggerJustMyCode(&amp;unk_51E02A);
  if ( !a1 || !a1[3] || !a2 )
    return 0;
  a1[6] = 0;
  if ( !sub_44FED7(a1, a2) )
    return 0;
  if ( !sub_44EB77(a1, a2) )
    return 0;
  if ( !sub_44F478(a1) )
    goto LABEL_17;
  if ( !sub_451057(a1) )
    goto LABEL_17;
  a1[2] = sub_450D69(0, *a1, a1[1]);
  if ( !sub_45016B(a1) )
    goto LABEL_17;
  if ( !sub_4509DB(a1) )
    return 0;
  if ( !a3 || sub_44ED5C(a1, 1) )
    return 1;
LABEL_17:
  sub_44EFD2(a1);
  return 0;
}
</code></pre>
</li>
<li>
<p>调试发现直到sub_44ED5C函数才出现输入flag</p>
</li>
<li>
<p>跟进</p>
</li>
<li>
<pre><code class="language-c">int __cdecl sub_3A4B40(_DWORD *a1, int a2)
{
  void (__cdecl *v3)(_DWORD, int, _DWORD); // [esp+4Ch] [ebp-8h]
  int v4; // [esp+50h] [ebp-4h]

  if ( !a1 || !*a1 )
    return 0;
  v4 = *(_DWORD *)(*a1 + 60) + *a1;
  if ( !*(_DWORD *)(v4 + 40) )
    return 0;
  v3 = (void (__cdecl *)(_DWORD, int, _DWORD))(*(_DWORD *)(v4 + 40) + *a1);
  if ( v3 )
  {
    v3(*a1, a2, 0);
    return 1;
  }
  else
  {
    a1[6] = 6;
    return 0;
  }
}
</code></pre>
</li>
<li>
<p>实际上是v3对资源文件进行了改动</p>
</li>
<li>
<p>跟进找到加密函数：</p>
</li>
<li>
<pre><code class="language-c">int sub_1005F820()
{
  _DWORD *v1; // [esp+D0h] [ebp-8h]

  sub_1005B16F(&amp;unk_1014000F);
  kernel32_VirtualAlloc(0, 65548, 12288, 4);
  v1 = (_DWORD *)sub_1005A260();
  if ( !v1 )
    return -1;
  v1[1] = 0x10000;
  *v1 = 0;
  v1[2] = v1 + 3;
  sub_10059572(v1[2], 0, v1[1]);
  ((void (__cdecl *)(const char *))unk_10058BC7)(&quot;[out]: PLZ Input FLag \n&quot;);
  ((void (__cdecl *)(const char *))unk_10058BC7)(&quot;[in ]: &quot;);
  ((void (__cdecl *)(void *, _DWORD))unk_100581A4)(&amp;unk_10114B68, v1[2]);
  *v1 = sub_1005B5BB(v1[2]);
  if ( *v1 == 41 )
  {
    *v1 = 48;
    ((void (__cdecl *)(_DWORD *))unk_1005A242)(v1);
    if ( ((int (__cdecl *)(_DWORD, void *, int))unk_10058AA0)(v1[2], &amp;unk_1013C008, 48) )
      ((void (__cdecl *)(const char *))unk_10058BC7)(&quot;[out]: WRONG FLAG\n&quot;);
    else
      ((void (__cdecl *)(const char *))unk_10058BC7)(&quot;[out]: RIGHT FLAG\n&quot;);
    kernel32_VirtualFree(v1, 0, 49152);
    sub_1005A260();
    return 0;
  }
  else
  {
    ((void (__cdecl *)(const char *))unk_10058BC7)(&quot;[out]: len error\n&quot;);
    kernel32_VirtualFree(v1, 0, 49152);
    sub_1005A260();
    return -1;
  }
}
</code></pre>
</li>
<li>
<p>把数据p完找到加密函数：</p>
</li>
<li>
<pre><code class="language-c">_DWORD *__cdecl sub_1005F6F0(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ecx
  int j; // [esp+D0h] [ebp-30h]
  unsigned int i; // [esp+DCh] [ebp-24h]
  __int64 v5; // [esp+E8h] [ebp-18h]
  int *v6; // [esp+F8h] [ebp-8h]

  sub_1005B16F(&amp;unk_1014000F);
  for ( i = 0; ; ++i )
  {
    result = a1;
    if ( i &gt;= *a1 &gt;&gt; 3 )
      break;
    v6 = (int *)(a1[2] + 8 * i);
    v2 = *v6;
    v5 = *(_QWORD *)v6;
    for ( j = 0; j &lt; 64; ++j )
    {
      LOBYTE(v2) = 1;
      if ( v5 &lt; 0 )
        v5 = qword_1013C000 ^ sub_10059F9F(v2, HIDWORD(v5));
      else
        v5 = sub_10059F9F(v2, HIDWORD(v5));
    }
    *(_QWORD *)v6 = v5;
  }
  return result;
}
</code></pre>
</li>
<li>
<p>注意如下汇编代码:</p>
</li>
<li>
<pre><code class="language-assembly">debug034:1005F738 mov     eax, [ebp+arg_0]
debug034:1005F73B mov     ecx, [eax+8]
debug034:1005F73E mov     edx, [ebp+var_24]
debug034:1005F741 lea     eax, [ecx+edx*8]
debug034:1005F744 mov     [ebp+var_8], eax
debug034:1005F747 mov     eax, [ebp+var_8]
debug034:1005F74A mov     ecx, [eax]
debug034:1005F74C mov     edx, [eax+4]
debug034:1005F74F mov     dword ptr [ebp+var_18], ecx
debug034:1005F752 mov     dword ptr [ebp+var_18+4], edx
</code></pre>
</li>
<li>
<p>与伪代码有点区别</p>
</li>
<li></li>
</ul>
<pre><code class="language-c"> LODWORD(v5) = *(_DWORD *)v6;    
 HIDWORD(v5) = v2;
</code></pre>
<ul>
<li>
<p>根据这个再去编写脚本（真的是坑www</p>
</li>
<li>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;Windows.h&gt;
#include &lt;windef.h&gt;

int main()
{
    __int64 key = 0x54aa4a9;
    BYTE c[] = {
            0x4D,0xB8,0x76,0x29,0xF5,0xA9,0x9E,0x59,
            0x55,0x56,0xB1,0xC4,0x2F,0x21,0x2C,0x30,
            0xB3,0x79,0x78,0x17,0xA8,0xED,0xF7,0xDB,
            0xE1,0x53,0xF0,0xDB,0xE9,0x03,0x51,0x5E,
            0x09,0xC1,0x00,0xDF,0xF0,0x96,0xFC,0xC1,
            0xB5,0xE6,0x62,0x95,0x01,0x00,0x00,0x00,
    };
    __int64 v5;
    int j, i;
    for (i = 0; i &lt; 6; i++)
    {
        v5 = *((__int64*)&amp;c[i * 8]);
        for (j = 0; j &lt; 64; j++)
        {
            if (v5 &amp; 1)
            {
                v5 = ((unsigned __int64)v5 ^ key) &gt;&gt; 1;
                v5 |= 0x8000000000000000;

            }
            else
            {
                v5 = (unsigned __int64)v5 &gt;&gt; 1;
            }
        }
        *((__int64*)&amp;c[i * 8]) = v5;
    }
    for (i = 0; i &lt; 48; i++)
        printf(&quot;%c&quot;, c[i]);
    return 0;
}
</code></pre>
</li>
<li>
<p>还要补全符号位</p>
</li>
<li>
<p><em><strong>D0g3{60E1E72A-576A8BF0-7701CBB9-B02415EC}</strong></em></p>
</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li><strong>注意程序实现及脚本编写的细节！！！</strong></li>
</ul>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      Tanggerr
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://Tanggerr.github.io/post/di-liu-jie-an-xun-bei-reverse-writeup/" title="第六届安洵杯 Reverse WriteUp">https://Tanggerr.github.io/post/di-liu-jie-an-xun-bei-reverse-writeup/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="汇编指令对应机器码列表" href="https://Tanggerr.github.io/post/hui-bian-zhi-ling-dui-ying-ji-qi-ma-lie-biao/">汇编指令对应机器码列表</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="汇编指令对应机器码列表" href="https://Tanggerr.github.io/post/hui-bian-zhi-ling-dui-ying-ji-qi-ma-lie-biao/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="[2019Ciscn初赛] Strange int" href="https://Tanggerr.github.io/post/2019ciscn-chu-sai-strange-int/">[2019Ciscn初赛] Strange int</a>
        <a class="nav-mobile-next" title="[2019Ciscn初赛] Strange int" href="https://Tanggerr.github.io/post/2019ciscn-chu-sai-strange-int/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '',
    clientSecret: '',
    repo: '',
    owner: '',
    admin: [''],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
    
        <div class="pisces back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
                  
                    
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 150px;bottom: 20px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'rem'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
                      
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/wustctf2020funnyre/"" data-c="
          &lt;h2 id=&#34;去除花指令&#34;&gt;去除花指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接脚本去除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from idc import *
def patch(start, end):
	i = start
	while i &amp;lt; end:
		if print_insn_mnem(i) == &#39;jz&#39; and print_insn_mnem(i + 2) == &#39;jnz&#39;:
			for j in range(i, i + 0x17):
				patch_byte(j, 0x90)
				i += 0x16
		i += 1
for seg in Segments():
	if get_segm_name(seg) == &#39;.text&#39;:
		patch(0x400614,0x401D98)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p完发现是个巨长的加密操作，尝试用angr遍历&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;angr遍历&#34;&gt;angr遍历&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;touch attachment.py # 新建py文件
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import angr
import claripy

p=angr.Project(&#39;./attachment&#39;,load_options={&amp;quot;auto_load_libs&amp;quot;: False})
f=p.factory
state = f.entry_state(addr=0x400605)#设置state开始运行时的地址
flag = claripy.BVS(&#39;flag&#39;,8*32)#要求的内容有32个，用BVS转成二进制给flag变量
state.memory.store(0x603055+0x300+5,flag)#因为程序没有输入，所以直接把字符串设置到内存
state.regs.rdx=0x603055+0x300
state.regs.rdi=0x603055+0x300+5#然后设置两个寄存器

sm = p.factory.simulation_manager(state)#准备从state开始遍历路径


print(&amp;quot;ready&amp;quot;)

sm.explore(find=0x401DAE)#遍历到成功的地址

if sm.found:
    print(&amp;quot;success&amp;quot;)
    x=sm.found[0].solver.eval(flag,cast_to=bytes)
    print(x)
else:
    print(&#39;error&#39;)


&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接爆破出flag即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">[WUSTCTF2020]funnyre</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/an-xun-bei-2019-crackme/"" data-c="
          &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;main函数：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl __noreturn main_0(int argc, const char **argv, const char **envp)
{
  _BYTE v3[6]; // [esp-4h] [ebp-D0h]

  printf(&amp;quot;please Input the flag:\n&amp;quot;);
  scanf_s(&amp;quot;%s&amp;quot;, &amp;amp;input_string);
  MessageBoxW(0, L&amp;quot;Exception&amp;quot;, L&amp;quot;Warning&amp;quot;, 0);
  *(_DWORD *)v3 = sub_A3100F;
  MEMORY[0] = 1;
  sub_A31136(*(int *)&amp;amp;v3[2]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;看到汇编中注册了SEH函数：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;push    offset sub_A3100F
push    large dword ptr fs:0
mov     large fs:0, esp
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跟进&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char __cdecl sub_A319F0(int a1, unsigned int *a2, _BYTE *a3)
{
  int v3; // eax
  char result; // al
  int v5[38]; // [esp+D0h] [ebp-A4h] BYREF
  unsigned int v6; // [esp+168h] [ebp-Ch]

  v6 = 0;
  j_memset(v5, 0, 0x90u);
  v5[0] = _byteswap_ulong(*a2);
  v5[1] = _byteswap_ulong(a2[1]);
  v5[2] = _byteswap_ulong(a2[2]);
  v5[3] = _byteswap_ulong(a2[3]);
  while ( v6 &amp;lt; 0x20 )
  {
    v3 = sub_A31700(v5[v6], v5[v6 + 1], v5[v6 + 2], v5[v6 + 3], *(_DWORD *)(a1 + 4 * v6));
    v5[v6++ + 4] = v3;
  }
  *a3 = HIBYTE(v5[35]);
  a3[1] = BYTE2(v5[35]);
  a3[2] = BYTE1(v5[35]);
  a3[3] = v5[35];
  a3[4] = HIBYTE(v5[34]);
  a3[5] = BYTE2(v5[34]);
  a3[6] = BYTE1(v5[34]);
  a3[7] = v5[34];
  a3[8] = HIBYTE(v5[33]);
  a3[9] = BYTE2(v5[33]);
  a3[10] = BYTE1(v5[33]);
  a3[11] = v5[33];
  a3[12] = HIBYTE(v5[32]);
  a3[13] = BYTE2(v5[32]);
  a3[14] = BYTE1(v5[32]);
  result = v5[32];
  a3[15] = v5[32];
  return result;
}
unsigned int __cdecl sub_581700(int a1, int a2, int a3, int a4, int a5)
{
  return a1 ^ sub_581760(a5 ^ a4 ^ a3 ^ a2);
}
int __cdecl sub_581760(int a1)
{
  unsigned int v2; // [esp+D0h] [ebp-2Ch]
  unsigned int v3; // [esp+F4h] [ebp-8h]

  LOBYTE(v2) = sub_5819A0(HIBYTE(a1));
  BYTE1(v2) = sub_5819A0(BYTE2(a1));
  BYTE2(v2) = sub_5819A0(BYTE1(a1));
  HIBYTE(v2) = sub_5819A0(a1);
  v3 = _byteswap_ulong(v2);
  return ((v3 &amp;gt;&amp;gt; 8) | (v3 &amp;lt;&amp;lt; 24)) ^ ((v3 &amp;gt;&amp;gt; 14) | (v3 &amp;lt;&amp;lt; 18)) ^ ((v3 &amp;gt;&amp;gt; 22) | (v3 &amp;lt;&amp;lt; 10)) ^ v3 ^ ((v3 &amp;gt;&amp;gt; 30) | (4 * v3));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其实是个SM4加密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要找到key的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交叉引用到Handler函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __stdcall Handler_0(_DWORD **a1)
{
  unsigned int v2[5]; // [esp+D0h] [ebp-18h] BYREF

  if ( **a1 == 0xC0000005 )
  {
    qmemcpy(v2, &amp;quot;where_are_u_now?&amp;quot;, 16);
    sub_581172(key, v2);
    SetUnhandledExceptionFilter(TopLevelExceptionFilter);
  }
  return 0;
}

unsigned int __cdecl sub_A31F50(int a1, unsigned int *a2)
{
  unsigned int result; // eax
  unsigned int v3; // [esp+D0h] [ebp-B8h]
  unsigned int v4; // [esp+DCh] [ebp-ACh]
  unsigned int v5; // [esp+E0h] [ebp-A8h]
  unsigned int v6; // [esp+E4h] [ebp-A4h]
  int v7[35]; // [esp+E8h] [ebp-A0h]
  unsigned int v8; // [esp+174h] [ebp-14h]
  unsigned int v9; // [esp+178h] [ebp-10h]
  unsigned int v10; // [esp+17Ch] [ebp-Ch]
  unsigned int v11; // [esp+180h] [ebp-8h]

  v3 = 0;
  v8 = _byteswap_ulong(*a2);
  v9 = _byteswap_ulong(a2[1]);
  v10 = _byteswap_ulong(a2[2]);
  v11 = _byteswap_ulong(a2[3]);
  v4 = v8 ^ 0xA3B1BAC6;
  v5 = dword_A37A68[1] ^ v9;
  v6 = dword_A37A68[2] ^ v10;
  result = 12;
  v7[0] = dword_A37A68[3] ^ v11;
  while ( v3 &amp;lt; 0x20 )
  {
    v7[v3 + 1] = *(&amp;amp;v4 + v3) ^ sub_A314E0(dword_A37A78[v3] ^ v7[v3] ^ v7[v3 - 1] ^ *(&amp;amp;v5 + v3));
    *(_DWORD *)(a1 + 4 * v3) = v7[v3 + 1];
    result = ++v3;
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以直接动调出来key（0xA3B1BAC6 SM4一个特征值）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有一个UEH&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl sub_582C30(_DWORD *a1)
{
  int result; // eax
  char v2; // [esp+D3h] [ebp-11h]
  size_t i; // [esp+DCh] [ebp-8h]

  result = (int)a1;
  if ( *(_DWORD *)*a1 == 0xC0000005 )
  {
    for ( i = 0; i &amp;lt; j_strlen(Str2); i += 2 )
    {
      v2 = Str2[i];
      Str2[i] = Str2[i + 1];
      Str2[i + 1] = v2;
    }
    Str1 = sub_58126C(output_string);
    *(_DWORD *)(a1[1] + 176) = *(_DWORD *)(*a1 + 20);//eax
    *(_DWORD *)(a1[1] + 164) = *(_DWORD *)(*a1 + 24);//ebx
    *(_DWORD *)(a1[1] + 172) = *(_DWORD *)(*a1 + 28);//ecx
    *(_DWORD *)(a1[1] + 168) = *(_DWORD *)(*a1 + 32);//edx
    *(_DWORD *)(a1[1] + 156) = *(_DWORD *)(*a1 + 36);//edi
    *(_DWORD *)(a1[1] + 160) = *(_DWORD *)(*a1 + 40);//esi
    *(_DWORD *)(a1[1] + 184) = sub_581136;//eip
    return -1;
  }
  return result;
}
_BYTE *__cdecl sub_583090(char *Str)
{
  int k; // [esp+E4h] [ebp-5Ch]
  int v3; // [esp+F0h] [ebp-50h]
  int j; // [esp+FCh] [ebp-44h]
  int v5; // [esp+108h] [ebp-38h]
  signed int i; // [esp+114h] [ebp-2Ch]
  _BYTE *v7; // [esp+120h] [ebp-20h]
  signed int v8; // [esp+12Ch] [ebp-14h]
  int v9; // [esp+138h] [ebp-8h]

  v5 = 0;
  v8 = j_strlen(Str);
  if ( v8 % 3 )
    v9 = 4 * (v8 / 3) + 4;
  else
    v9 = 4 * (v8 / 3);
  v7 = malloc(__CFADD__(v9, 1) ? -1 : v9 + 1);
  v7[v9] = 0;
  for ( i = 0; i &amp;lt; v8; i += 3 )
  {
    v3 = 0;
    for ( j = 0; j &amp;lt; 3; ++j )
      v3 |= (unsigned __int8)Str[j + i] &amp;lt;&amp;lt; (8 * (2 - j));
    for ( k = 0; k &amp;lt; 4; ++k )
    {
      if ( k &amp;gt;= 4 - (i + 3 - v8) &amp;amp;&amp;amp; i + 3 &amp;gt; v8 )
        v7[v5] = 33;
      else
        v7[v5] = ::Str[sub_5810FF((v3 &amp;gt;&amp;gt; (6 * (3 - k))) &amp;amp; 0x3F)];
      ++v5;
    }
  }
  return v7;
}

int __cdecl sub_582760(int a1)
{
  return (a1 + 24) % 64;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对str2进行处理，将sm4产生的输出进行处理，发现是一个魔改的base64&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（其中对表进行凯撒加密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UEH里面还修改了eip为sub_581136，进行最后的字符串比较&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后result=-1，异常返回继续执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关于hadler0是怎么调用的&#34;&gt;关于hadler0是怎么调用的&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __stdcall sub_582AB0(int a1, int a2, int a3, int a4)
{
  size_t i; // [esp+D8h] [ebp-8h]

  for ( i = 0; i &amp;lt; j_strlen(Str); ++i )
  {
    if ( Str[i] &amp;lt;= 122 &amp;amp;&amp;amp; Str[i] &amp;gt;= 97 )
    {
      Str[i] -= 32;
    }
    else if ( Str[i] &amp;lt;= 90 &amp;amp;&amp;amp; Str[i] &amp;gt;= 65 )
    {
      Str[i] += 32;
    }
  }
  MessageBoxA(0, &amp;quot;hooked&amp;quot;, &amp;quot;successed&amp;quot;, 0);
  AddVectoredExceptionHandler(0, Handler);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交叉引用到上面这个函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现其对base64码表进行变换，并注册VEH，从而调用Handler&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再交叉引用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl sub_5827B0(int a1, char *String2, int a3)
{
  DWORD LastError; // eax
  int flOldProtect[3]; // [esp+D0h] [ebp-90h] BYREF
  void *v6[3]; // [esp+DCh] [ebp-84h] BYREF
  LPCVOID lpAddress; // [esp+E8h] [ebp-78h]
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+F4h] [ebp-6Ch] BYREF
  LPVOID lpBaseAddress; // [esp+118h] [ebp-48h]
  int v10; // [esp+124h] [ebp-3Ch]
  char *String1; // [esp+130h] [ebp-30h]
  int i; // [esp+13Ch] [ebp-24h]
  int v13; // [esp+148h] [ebp-18h]
  int v14; // [esp+154h] [ebp-Ch]

  v14 = a1;
  v13 = a1 + *(_DWORD *)(a1 + 60) + 24;
  for ( i = *(_DWORD *)(v13 + 104) + a1; i; i += 20 )
  {
    String1 = (char *)GetModuleHandleW(0) + *(_DWORD *)(i + 12);
    if ( !stricmp(String1, String2) )
      break;
  }
  if ( !i )
    return 0;
  v10 = *(_DWORD *)(i + 16) + a1;
  if ( !v10 )
    return 0;
  while ( 1 )
  {
    if ( !*(_DWORD *)v10 )
      return 0;
    lpBaseAddress = (LPVOID)v10;
    if ( *(_DWORD *)v10 == a3 )
      break;
    v10 += 4;
  }
  lpAddress = (LPCVOID)(v10 &amp;gt;&amp;gt; 12 &amp;lt;&amp;lt; 12);
  VirtualQuery(lpAddress, &amp;amp;Buffer, 0x3E8u);
  VirtualProtect((LPVOID)lpAddress, Buffer.RegionSize, 0x40u, &amp;amp;Buffer.Protect);
  v6[0] = sub_581023;
  if ( WriteProcessMemory((HANDLE)0xFFFFFFFF, lpBaseAddress, v6, 4u, 0) )
  {
    VirtualProtect(Buffer.BaseAddress, Buffer.RegionSize, Buffer.Protect, (PDWORD)flOldProtect);
    return 1;
  }
  else
  {
    LastError = GetLastError();
    printf(&amp;quot;%d\n&amp;quot;, LastError);
    return 0;
  }
}//找到 user32.dll 对应的 IMAGE_IMPORT_DESCRIPTOR 结构体地址，然后找到 MessageBoxW 对应的 IMAGE_THUNK_DATA 结构体地址，用VirtualProtect修改页属性为可写，用WriteProcessMemory将IMAGE_THUNK_DATA字段覆写为sub_581023函数地址
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int sub_581E40()
{
  HMODULE ModuleHandleW; // eax

  ModuleHandleW = GetModuleHandleW(0);
  sub_58114A((int)ModuleHandleW, &amp;quot;User32.dll&amp;quot;, &amp;quot;MessageBoxW&amp;quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其实就是IAT hook，将MessageBoxW的IAT地址替换为了sub_581023的函数地址，该函数完成了VEH的注册&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再往上交叉，就找到一个rdata区的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;.rdata:00587618 dd offset sub_581235
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// write access to const memory has been detected, the output may be wrong!
int __tmainCRTStartup()
{
  int v1; // [esp+18h] [ebp-24h]
  signed __int32 v2; // [esp+1Ch] [ebp-20h]
  signed __int32 v3; // [esp+20h] [ebp-1Ch]

  v2 = *(_DWORD *)(j__NtCurrentTeb() + 4);
  v1 = 0;
  while ( 1 )
  {
    v3 = _InterlockedCompareExchange(dword_58A6EC, v2, 0);
    if ( !v3 )
      break;
    if ( v3 == v2 )
    {
      v1 = 1;
      break;
    }
  }
  if ( dword_58A6FC == 1 )
  {
    j__amsg_exit(31);
    goto LABEL_13;
  }
  if ( dword_58A6FC )
  {
    dword_58A2DC = 1;
    goto LABEL_13;
  }
  dword_58A6FC = 1;
  if ( !j__initterm_e((_PIFV *)&amp;amp;First, (_PIFV *)&amp;amp;Last) )
  {
LABEL_13:
    if ( dword_58A6FC == 1 )
    {
      j__initterm((_PVFV *)&amp;amp;dword_587000, (_PVFV *)&amp;amp;dword_587208);
      dword_58A6FC = 2;
    }
    if ( dword_58A6FC != 2
      &amp;amp;&amp;amp; CrtDbgReportW(
           2,
           L&amp;quot;f:\\dd\\vctools\\crt\\crtw32\\dllstuff\\crtexe.c&amp;quot;,
           553,
           0,
           L&amp;quot;%s&amp;quot;,
           L&amp;quot;__native_startup_state == __initialized&amp;quot;) == 1 )
    {
      __debugbreak();
    }
    if ( !v1 )
      _InterlockedExchange(dword_58A6EC, 0);
    if ( dword_58A714 )
    {
      if ( j___IsNonwritableInCurrentImage(&amp;amp;dword_58A714) )
        dword_58A714(0, 2, 0);
    }
    CrtSetCheckCount(1);
    _initenv = envp;
    main(argc, (const char **)argv, (const char **)envp);
  }
  return 255;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;j__initterm_e函数调用了那个数据，且对全局/静态C++类的构造函数进行了初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再往上就到了start&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;异常处理的注册&#34;&gt;异常处理的注册&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;有个调用链：start -&amp;gt; tmainCRTStartUp-&amp;gt;initterm_e-&amp;gt;IAThook ,修改了MessageBox中的IAT表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这时main函数里会调用Messageboxw，就调用了注册VEH的函数，并对码表进行变换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在main中注册了SEH&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在VEH的handler中注册了UEH&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;异常处理的回调&#34;&gt;异常处理的回调&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Windows异常处理：用户态发生异常-&amp;gt;调试器-VEH--SEH--UEH&lt;/li&gt;
&lt;li&gt;在main中内存写异常，各级异常处理的返回状态都未完成处理，那么会进行上述的完整回调&lt;/li&gt;
&lt;li&gt;VEH对sm4进行初始，得到key&lt;/li&gt;
&lt;li&gt;SEH对输入进行sm4加密，&lt;/li&gt;
&lt;li&gt;UEH进行base64魔改加密，最后比较&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最后写下脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;import sm4
key = sm4.SM4Key(b&amp;quot;where_are_u_now?&amp;quot;)
print key.decrypt(sm4_encoded)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;flag{SM4foRExcepioN?!}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;&#34;&gt;&lt;/h2&gt;
&lt;h2 id=&#34;一些小tips&#34;&gt;一些小tips&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;initterm：用于访问函数指针表并将其初始化的内部方法。&lt;/p&gt;
&lt;p&gt;第一个指针位于表中的起始位置，第二个指针位于结束位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GetModuleHandleW:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HMODULE GetModuleHandleW(
  [in, optional] LPCWSTR lpModuleName//加载的模块的名称 
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;HMODULE LoadLibraryA(
  [in] LPCSTR lpLibFileName
);将指定的模块加载到调用进程的地址空间中
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;FARPROC GetProcAddress(
  [in] HMODULE hModule,
  [in] LPCSTR  lpProcName
);从指定的动态链接库 (DLL) 检索导出函数 (也称为过程) 或变量的地址。

BOOL WriteProcessMemory(将数据写入到指定进程中的内存区域。
  [in]  HANDLE  hProcess,
  [in]  LPVOID  lpBaseAddress,
  [in]  LPCVOID lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesWritten
);

PVOID AddVectoredExceptionHandler(
  ULONG                       First,
  PVECTORED_EXCEPTION_HANDLER Handler
);注册向量化异常处理程序。
Firse:处理程序的调用顺序。 如果参数为非零值，则处理程序是要调用的第一个处理程序。 如果 参数为零，则处理程序是最后一个要调用的处理程序。
Handler:指向要调用的处理程序的指针。 

LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(
  [in] LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter//指向顶级异常筛选器函数的指针，每当 UnhandledExceptionFilter 函数获得控制权且进程未调试时，将调用该函数。
);
使应用程序能够取代进程每个线程的顶级异常处理程序。
调用此函数后，如果在未调试的进程中发生异常，并且异常会将其引入未经处理的异常筛选器，该筛选器将调用 由 lpTopLevelExceptionFilter 参数指定的异常筛选器函数。

LONG UnhandledExceptionFilter(
  [in] _EXCEPTION_POINTERS *ExceptionInfo//指向 EXCEPTION_POINTERS 结构的指针，该结构指定异常和异常时处理器上下文的说明。
);应用程序定义的函数，它将未经处理的异常传递给调试器（如果正在调试进程）。 否则，它会选择显示 应用程序错误消息 框，并导致执行异常处理程序。 只能从异常处理程序的筛选器表达式内调用此函数。

typedef struct _EXCEPTION_POINTERS {
  PEXCEPTION_RECORD ExceptionRecord;
  PCONTEXT          ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
ExceptionRecord:指向 EXCEPTION_RECORD 结构的指针，该结构包含与计算机无关的异常说明。
ContextRecord:指向 CONTEXT 结构的指针，该结构包含异常时处理器状态的特定于处理器的说明。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结：&lt;/h2&gt;
&lt;p&gt;很全面的一道题，知识点明确&lt;/p&gt;
">安洵杯2019 Crackme</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/suctf2019-babyunic/"" data-c="
          &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;unicorn CPU 模拟器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看main&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __fastcall sub_CBA(const char *a1, __int64 a2, const char *a3)
{
  size_t v3; // rax
  int v5; // [rsp+20h] [rbp-30h] BYREF
  int v6; // [rsp+24h] [rbp-2Ch] BYREF
  int v7; // [rsp+28h] [rbp-28h] BYREF
  int v8; // [rsp+2Ch] [rbp-24h] BYREF
  __int64 v9; // [rsp+30h] [rbp-20h] BYREF
  FILE *stream; // [rsp+38h] [rbp-18h]
  void *ptr; // [rsp+40h] [rbp-10h]
  unsigned __int64 v12; // [rsp+48h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  stream = fopen(a3, &amp;quot;rb&amp;quot;);
  ptr = malloc(0x7100uLL);
  fread(ptr, 1uLL, 0x7100uLL, stream);
  v5 = 270532544;
  v6 = 270532544;
  v7 = 270531328;
  v8 = 270531072;
  uc_open(3LL, 1073741828LL, &amp;amp;v9);
  uc_mem_map(v9, 0x400000LL, 0x200000LL, 7LL);
  uc_mem_map(v9, 0x10000000LL, 0x200000LL, 7LL);
  v3 = strlen(a1);
  uc_mem_write(v9, 270531328LL, a1, v3);
  uc_mem_write(v9, 0x400000LL, ptr, 28928LL);
  uc_reg_write(v9, 31LL, (__int64)&amp;amp;v5);
  uc_reg_write(v9, 32LL, (__int64)&amp;amp;v6);
  uc_reg_write(v9, 7LL, (__int64)&amp;amp;v8);
  uc_reg_write(v9, 6LL, (__int64)&amp;amp;v7);
  uc_emu_start(v9, 0x400000LL, 4223084LL, 0LL, 0LL);
  uc_mem_read(v9, 270531072LL, a2, 200LL);
  uc_close(v9);
  return fclose(stream);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;babyunic会通过un.so.1去模拟执行func&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;un.so.1反汇编后发现是对上述main函数中的一些函数进行解释，其实就是模拟CPU&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看unicorn.h文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到参数对应常量意义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef enum uc_arch {
    UC_ARCH_ARM = 1, // ARM architecture (including Thumb, Thumb-2)
    UC_ARCH_ARM64,   // ARM-64, also called AArch64
    UC_ARCH_MIPS,    // Mips architecture
    UC_ARCH_X86,     // X86 architecture (including x86 &amp;amp; x86-64)
    UC_ARCH_PPC,     // PowerPC architecture
    UC_ARCH_SPARC,   // Sparc architecture
    UC_ARCH_M68K,    // M68K architecture
    UC_ARCH_RISCV,   // RISCV architecture
    UC_ARCH_S390X,   // S390X architecture
    UC_ARCH_TRICORE, // TriCore architecture
    UC_ARCH_MAX,
} uc_arch;

// Mode type
typedef enum uc_mode {
    UC_MODE_LITTLE_ENDIAN = 0,    // little-endian mode (default mode)
    UC_MODE_BIG_ENDIAN = 1 &amp;lt;&amp;lt; 30, // big-endian mode

    // arm / arm64
    UC_MODE_ARM = 0,        // ARM mode
    UC_MODE_THUMB = 1 &amp;lt;&amp;lt; 4, // THUMB mode (including Thumb-2)
    // Depreciated, use UC_ARM_CPU_* with uc_ctl instead.
    UC_MODE_MCLASS = 1 &amp;lt;&amp;lt; 5,  // ARM&#39;s Cortex-M series.
    UC_MODE_V8 = 1 &amp;lt;&amp;lt; 6,      // ARMv8 A32 encodings for ARM
    UC_MODE_ARMBE8 = 1 &amp;lt;&amp;lt; 10, // Big-endian data and Little-endian code.
                              // Legacy support for UC1 only.

    // arm (32bit) cpu types
    // Depreciated, use UC_ARM_CPU_* with uc_ctl instead.
    UC_MODE_ARM926 = 1 &amp;lt;&amp;lt; 7,  // ARM926 CPU type
    UC_MODE_ARM946 = 1 &amp;lt;&amp;lt; 8,  // ARM946 CPU type
    UC_MODE_ARM1176 = 1 &amp;lt;&amp;lt; 9, // ARM1176 CPU type

    // mips
    UC_MODE_MICRO = 1 &amp;lt;&amp;lt; 4,    // MicroMips mode (currently unsupported)
    UC_MODE_MIPS3 = 1 &amp;lt;&amp;lt; 5,    // Mips III ISA (currently unsupported)
    UC_MODE_MIPS32R6 = 1 &amp;lt;&amp;lt; 6, // Mips32r6 ISA (currently unsupported)
    UC_MODE_MIPS32 = 1 &amp;lt;&amp;lt; 2,   // Mips32 ISA
    UC_MODE_MIPS64 = 1 &amp;lt;&amp;lt; 3,   // Mips64 ISA

    // x86 / x64
    UC_MODE_16 = 1 &amp;lt;&amp;lt; 1, // 16-bit mode
    UC_MODE_32 = 1 &amp;lt;&amp;lt; 2, // 32-bit mode
    UC_MODE_64 = 1 &amp;lt;&amp;lt; 3, // 64-bit mode

    // ppc
    UC_MODE_PPC32 = 1 &amp;lt;&amp;lt; 2, // 32-bit mode
    UC_MODE_PPC64 = 1 &amp;lt;&amp;lt; 3, // 64-bit mode (currently unsupported)
    UC_MODE_QPX =
        1 &amp;lt;&amp;lt; 4, // Quad Processing eXtensions mode (currently unsupported)

    // sparc
    UC_MODE_SPARC32 = 1 &amp;lt;&amp;lt; 2, // 32-bit mode
    UC_MODE_SPARC64 = 1 &amp;lt;&amp;lt; 3, // 64-bit mode
    UC_MODE_V9 = 1 &amp;lt;&amp;lt; 4,      // SparcV9 mode (currently unsupported)

    // riscv
    UC_MODE_RISCV32 = 1 &amp;lt;&amp;lt; 2, // 32-bit mode
    UC_MODE_RISCV64 = 1 &amp;lt;&amp;lt; 3, // 64-bit mode

    // m68k
} uc_mode;

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现是mips32位大端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后用ghidra进行反编译&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;./ghidrarun，codebrowser&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;void UndefinedFunction_00000000(byte *param_1,int *param_2)

{
  int iStack_10;
  int iStack_c;
  
  for (iStack_c = 0; param_1[iStack_c] != 0; iStack_c = iStack_c + 1) {
  }
  for (iStack_10 = 0; iStack_10 &amp;lt; iStack_c; iStack_10 = iStack_10 + 1) {
    param_1[iStack_10] = (param_1[iStack_10] &amp;lt;&amp;lt; 3 | param_1[iStack_10] &amp;gt;&amp;gt; 5) ^ (byte)iStack_10;
  }
  *param_2 = ((((((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2]) -
                                          (uint)param_1[3]) + (uint)param_1[4]) - (uint)param_1[5])
                                       - (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8]) +
                                     (uint)param_1[9] + (uint)param_1[10]) - (uint)param_1[0xb]) +
                                  (uint)param_1[0xc]) - (uint)param_1[0xd]) - (uint)param_1[0xe]) +
                               (uint)param_1[0xf]) - (uint)param_1[0x10]) - (uint)param_1[0x11]) +
                             (uint)param_1[0x12] + (uint)param_1[0x13]) - (uint)param_1[0x14]) +
                           (uint)param_1[0x15] + (uint)param_1[0x16] + (uint)param_1[0x17] +
                          (uint)param_1[0x18]) - (uint)param_1[0x19]) + (uint)param_1[0x1a]) -
                       (uint)param_1[0x1b]) + (uint)param_1[0x1c] + (uint)param_1[0x1d]) -
                     (uint)param_1[0x1e]) - (uint)param_1[0x1f]) + (uint)param_1[0x20]) -
                  (uint)param_1[0x21]) + (uint)param_1[0x22] + (uint)param_1[0x23]) -
                (uint)param_1[0x24]) - (uint)param_1[0x25]) + (uint)param_1[0x26]) -
             (uint)param_1[0x27]) + (uint)param_1[0x28] + (uint)param_1[0x29];
  param_2[1] = (((((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) +
                                               (uint)param_1[2]) - (uint)param_1[3]) -
                                             (uint)param_1[4]) + (uint)param_1[5]) -
                                           (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8])
                                        - (uint)param_1[9]) + (uint)param_1[10]) -
                                      (uint)param_1[0xb]) + (uint)param_1[0xc]) - (uint)param_1[0xd]
                                    ) - (uint)param_1[0xe]) + (uint)param_1[0xf]) -
                                 (uint)param_1[0x10]) - (uint)param_1[0x11]) + (uint)param_1[0x12])
                              - (uint)param_1[0x13]) + (uint)param_1[0x14] + (uint)param_1[0x15]) -
                            (uint)param_1[0x16]) - (uint)param_1[0x17]) - (uint)param_1[0x18]) +
                         (uint)param_1[0x19]) - (uint)param_1[0x1a]) + (uint)param_1[0x1b]) -
                      (uint)param_1[0x1c]) - (uint)param_1[0x1d]) + (uint)param_1[0x1e] +
                     (uint)param_1[0x1f] + (uint)param_1[0x20] + (uint)param_1[0x21] +
                     (uint)param_1[0x22] + (uint)param_1[0x23]) - (uint)param_1[0x24]) -
                  (uint)param_1[0x25]) - (uint)param_1[0x26]) - (uint)param_1[0x27]) -
               (uint)param_1[0x28]) + (uint)param_1[0x29];
  param_2[2] = ((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2] +
                                          (uint)param_1[3]) - (uint)param_1[4]) + (uint)param_1[5])
                                       - (uint)param_1[6]) - (uint)param_1[7]) + (uint)param_1[8]) -
                                    (uint)param_1[9]) - (uint)param_1[10]) - (uint)param_1[0xb]) -
                                 (uint)param_1[0xc]) - (uint)param_1[0xd]) + (uint)param_1[0xe]) -
                              (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11] +
                             (uint)param_1[0x12] + (uint)param_1[0x13] + (uint)param_1[0x14] +
                            (uint)param_1[0x15]) - (uint)param_1[0x16]) + (uint)param_1[0x17] +
                           (uint)param_1[0x18] + (uint)param_1[0x19] + (uint)param_1[0x1a]) -
                         (uint)param_1[0x1b]) + (uint)param_1[0x1c]) - (uint)param_1[0x1d]) +
                      (uint)param_1[0x1e]) - (uint)param_1[0x1f]) + (uint)param_1[0x20] +
                    (uint)param_1[0x21]) - (uint)param_1[0x22]) - (uint)param_1[0x23]) +
                  (uint)param_1[0x24] + (uint)param_1[0x25] + (uint)param_1[0x26]) -
                (uint)param_1[0x27]) + (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[3] = ((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) - (uint)param_1[2])
                                           - (uint)param_1[3]) - (uint)param_1[4]) -
                                         (uint)param_1[5]) + (uint)param_1[6] + (uint)param_1[7]) -
                                       (uint)param_1[8]) - (uint)param_1[9]) - (uint)param_1[10]) -
                                    (uint)param_1[0xb]) + (uint)param_1[0xc]) - (uint)param_1[0xd])
                                 + (uint)param_1[0xe]) - (uint)param_1[0xf]) + (uint)param_1[0x10])
                              - (uint)param_1[0x11]) + (uint)param_1[0x12] + (uint)param_1[0x13] +
                             (uint)param_1[0x14]) - (uint)param_1[0x15]) + (uint)param_1[0x16] +
                            (uint)param_1[0x17] + (uint)param_1[0x18]) - (uint)param_1[0x19]) -
                         (uint)param_1[0x1a]) + (uint)param_1[0x1b]) - (uint)param_1[0x1c]) +
                       (uint)param_1[0x1d] + (uint)param_1[0x1e]) - (uint)param_1[0x1f]) -
                    (uint)param_1[0x20]) - (uint)param_1[0x21]) + (uint)param_1[0x22]) -
                 (uint)param_1[0x23]) + (uint)param_1[0x24] + (uint)param_1[0x25] +
                (uint)param_1[0x26]) - (uint)param_1[0x27]) + (uint)param_1[0x28] +
               (uint)param_1[0x29];
  param_2[4] = ((((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) -
                                              (uint)param_1[2]) + (uint)param_1[3]) -
                                            (uint)param_1[4]) - (uint)param_1[5]) + (uint)param_1[6]
                                           + (uint)param_1[7] + (uint)param_1[8] + (uint)param_1[9])
                                         - (uint)param_1[10]) + (uint)param_1[0xb] +
                                        (uint)param_1[0xc]) - (uint)param_1[0xd]) +
                                      (uint)param_1[0xe]) - (uint)param_1[0xf]) +
                                     (uint)param_1[0x10] + (uint)param_1[0x11]) -
                                   (uint)param_1[0x12]) + (uint)param_1[0x13]) - (uint)param_1[0x14]
                                 ) + (uint)param_1[0x15]) - (uint)param_1[0x16]) -
                              (uint)param_1[0x17]) - (uint)param_1[0x18]) + (uint)param_1[0x19]) -
                           (uint)param_1[0x1a]) - (uint)param_1[0x1b]) - (uint)param_1[0x1c]) +
                         (uint)param_1[0x1d] + (uint)param_1[0x1e] + (uint)param_1[0x1f]) -
                       (uint)param_1[0x20]) + (uint)param_1[0x21]) - (uint)param_1[0x22]) -
                    (uint)param_1[0x23]) + (uint)param_1[0x24]) - (uint)param_1[0x25]) +
                 (uint)param_1[0x26]) - (uint)param_1[0x27]) - (uint)param_1[0x28]) -
               (uint)param_1[0x29];
  param_2[5] = (((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2] +
                                           (uint)param_1[3] + (uint)param_1[4] + (uint)param_1[5] +
                                           (uint)param_1[6] + (uint)param_1[7] + (uint)param_1[8]) -
                                         (uint)param_1[9]) - (uint)param_1[10]) - (uint)param_1[0xb]
                                       ) - (uint)param_1[0xc]) - (uint)param_1[0xd]) -
                                    (uint)param_1[0xe]) + (uint)param_1[0xf]) - (uint)param_1[0x10])
                                 + (uint)param_1[0x11]) - (uint)param_1[0x12]) + (uint)param_1[0x13]
                               + (uint)param_1[0x14]) - (uint)param_1[0x15]) + (uint)param_1[0x16])
                            - (uint)param_1[0x17]) + (uint)param_1[0x18]) - (uint)param_1[0x19]) +
                          (uint)param_1[0x1a] + (uint)param_1[0x1b]) - (uint)param_1[0x1c]) +
                       (uint)param_1[0x1d]) - (uint)param_1[0x1e]) + (uint)param_1[0x1f] +
                      (uint)param_1[0x20] + (uint)param_1[0x21]) - (uint)param_1[0x22]) -
                   (uint)param_1[0x23]) - (uint)param_1[0x24]) + (uint)param_1[0x25]) -
                (uint)param_1[0x26]) - (uint)param_1[0x27]) + (uint)param_1[0x28] +
               (uint)param_1[0x29];
  param_2[6] = ((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2] +
                                         (uint)param_1[3] + (uint)param_1[4]) - (uint)param_1[5]) +
                                       (uint)param_1[6] + (uint)param_1[7] + (uint)param_1[8] +
                                      (uint)param_1[9]) - (uint)param_1[10]) + (uint)param_1[0xb] +
                                    (uint)param_1[0xc]) - (uint)param_1[0xd]) + (uint)param_1[0xe] +
                                   (uint)param_1[0xf] + (uint)param_1[0x10] + (uint)param_1[0x11]) -
                                 (uint)param_1[0x12]) - (uint)param_1[0x13]) - (uint)param_1[0x14])
                              - (uint)param_1[0x15]) - (uint)param_1[0x16]) - (uint)param_1[0x17]) +
                            (uint)param_1[0x18] + (uint)param_1[0x19]) - (uint)param_1[0x1a]) +
                          (uint)param_1[0x1b] + (uint)param_1[0x1c] + (uint)param_1[0x1d]) -
                        (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
                     (uint)param_1[0x21]) - (uint)param_1[0x22]) - (uint)param_1[0x23]) +
                   (uint)param_1[0x24] + (uint)param_1[0x25]) - (uint)param_1[0x26]) -
                (uint)param_1[0x27]) + (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[7] = (((((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1]) - (uint)param_1[2])
                                          - (uint)param_1[3]) - (uint)param_1[4]) + (uint)param_1[5]
                                        + (uint)param_1[6]) - (uint)param_1[7]) + (uint)param_1[8] +
                                      (uint)param_1[9]) - (uint)param_1[10]) + (uint)param_1[0xb]) -
                                   (uint)param_1[0xc]) + (uint)param_1[0xd]) - (uint)param_1[0xe]) +
                                (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11]) -
                             (uint)param_1[0x12]) - (uint)param_1[0x13]) + (uint)param_1[0x14]) -
                          (uint)param_1[0x15]) + (uint)param_1[0x16]) - (uint)param_1[0x17]) -
                       (uint)param_1[0x18]) + (uint)param_1[0x19]) - (uint)param_1[0x1a]) +
                     (uint)param_1[0x1b] + (uint)param_1[0x1c] + (uint)param_1[0x1d] +
                     (uint)param_1[0x1e] + (uint)param_1[0x1f] + (uint)param_1[0x20]) -
                   (uint)param_1[0x21]) + (uint)param_1[0x22]) - (uint)param_1[0x23]) +
                 (uint)param_1[0x24] + (uint)param_1[0x25] + (uint)param_1[0x26] +
                (uint)param_1[0x27]) - (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[8] = ((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) - (uint)param_1[2]) +
                                          (uint)param_1[3] + (uint)param_1[4]) - (uint)param_1[5]) +
                                        (uint)param_1[6] + (uint)param_1[7] + (uint)param_1[8] +
                                        (uint)param_1[9] + (uint)param_1[10]) - (uint)param_1[0xb])
                                     - (uint)param_1[0xc]) + (uint)param_1[0xd]) -
                                   (uint)param_1[0xe]) + (uint)param_1[0xf] + (uint)param_1[0x10] +
                                   (uint)param_1[0x11] + (uint)param_1[0x12]) - (uint)param_1[0x13])
                                 + (uint)param_1[0x14] + (uint)param_1[0x15]) - (uint)param_1[0x16])
                              - (uint)param_1[0x17]) + (uint)param_1[0x18] + (uint)param_1[0x19] +
                             (uint)param_1[0x1a]) - (uint)param_1[0x1b]) + (uint)param_1[0x1c]) -
                          (uint)param_1[0x1d]) - (uint)param_1[0x1e]) - (uint)param_1[0x1f]) -
                       (uint)param_1[0x20]) - (uint)param_1[0x21]) + (uint)param_1[0x22]) -
                    (uint)param_1[0x23]) - (uint)param_1[0x24]) + (uint)param_1[0x25]) -
                 (uint)param_1[0x26]) - (uint)param_1[0x27]) + (uint)param_1[0x28]) -
               (uint)param_1[0x29];
  param_2[9] = ((((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2]) -
                                          (uint)param_1[3]) + (uint)param_1[4] + (uint)param_1[5] +
                                         (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8]) -
                                      (uint)param_1[9]) - (uint)param_1[10]) + (uint)param_1[0xb] +
                                     (uint)param_1[0xc] + (uint)param_1[0xd]) - (uint)param_1[0xe])
                                   + (uint)param_1[0xf] + (uint)param_1[0x10]) - (uint)param_1[0x11]
                                 ) - (uint)param_1[0x12]) + (uint)param_1[0x13] +
                               (uint)param_1[0x14]) - (uint)param_1[0x15]) - (uint)param_1[0x16]) -
                            (uint)param_1[0x17]) + (uint)param_1[0x18]) - (uint)param_1[0x19]) -
                         (uint)param_1[0x1a]) - (uint)param_1[0x1b]) + (uint)param_1[0x1c] +
                        (uint)param_1[0x1d] + (uint)param_1[0x1e]) - (uint)param_1[0x1f]) +
                      (uint)param_1[0x20] + (uint)param_1[0x21]) - (uint)param_1[0x22]) -
                   (uint)param_1[0x23]) - (uint)param_1[0x24]) - (uint)param_1[0x25]) +
                (uint)param_1[0x26]) - (uint)param_1[0x27]) + (uint)param_1[0x28] +
               (uint)param_1[0x29];
  param_2[10] = (((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) +
                                               (uint)param_1[2] + (uint)param_1[3]) -
                                             (uint)param_1[4]) - (uint)param_1[5]) +
                                            (uint)param_1[6] + (uint)param_1[7]) - (uint)param_1[8])
                                         - (uint)param_1[9]) - (uint)param_1[10]) -
                                       (uint)param_1[0xb]) + (uint)param_1[0xc] + (uint)param_1[0xd]
                                      + (uint)param_1[0xe]) - (uint)param_1[0xf]) +
                                    (uint)param_1[0x10]) - (uint)param_1[0x11]) +
                                   (uint)param_1[0x12] + (uint)param_1[0x13] + (uint)param_1[0x14])
                                 - (uint)param_1[0x15]) + (uint)param_1[0x16]) - (uint)param_1[0x17]
                               ) - (uint)param_1[0x18]) - (uint)param_1[0x19]) + (uint)param_1[0x1a]
                            ) - (uint)param_1[0x1b]) - (uint)param_1[0x1c]) + (uint)param_1[0x1d]) -
                        (uint)param_1[0x1e]) + (uint)param_1[0x1f] + (uint)param_1[0x20]) -
                      (uint)param_1[0x21]) - (uint)param_1[0x22]) + (uint)param_1[0x23]) -
                   (uint)param_1[0x24]) - (uint)param_1[0x25]) + (uint)param_1[0x26]) -
                (uint)param_1[0x27]) + (uint)param_1[0x28] + (uint)param_1[0x29];
  param_2[0xb] = (((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2]
                                              + (uint)param_1[3] + (uint)param_1[4]) -
                                            (uint)param_1[5]) + (uint)param_1[6] + (uint)param_1[7])
                                          - (uint)param_1[8]) + (uint)param_1[9] + (uint)param_1[10]
                                         ) - (uint)param_1[0xb]) - (uint)param_1[0xc]) -
                                      (uint)param_1[0xd]) - (uint)param_1[0xe]) + (uint)param_1[0xf]
                                    ) - (uint)param_1[0x10]) - (uint)param_1[0x11]) -
                                 (uint)param_1[0x12]) + (uint)param_1[0x13] + (uint)param_1[0x14]) -
                               (uint)param_1[0x15]) + (uint)param_1[0x16]) - (uint)param_1[0x17]) +
                             (uint)param_1[0x18] + (uint)param_1[0x19] + (uint)param_1[0x1a] +
                            (uint)param_1[0x1b]) - (uint)param_1[0x1c]) + (uint)param_1[0x1d] +
                          (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
                       (uint)param_1[0x21]) - (uint)param_1[0x22]) - (uint)param_1[0x23]) +
                     (uint)param_1[0x24] + (uint)param_1[0x25]) - (uint)param_1[0x26]) -
                  (uint)param_1[0x27]) - (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0xc] = ((((((((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) -
                                                    (uint)param_1[2]) - (uint)param_1[3]) +
                                                  (uint)param_1[4]) - (uint)param_1[5]) -
                                                (uint)param_1[6]) + (uint)param_1[7] +
                                               (uint)param_1[8]) - (uint)param_1[9]) +
                                             (uint)param_1[10]) - (uint)param_1[0xb]) -
                                           (uint)param_1[0xc]) - (uint)param_1[0xd]) +
                                         (uint)param_1[0xe]) - (uint)param_1[0xf]) +
                                       (uint)param_1[0x10]) - (uint)param_1[0x11]) +
                                     (uint)param_1[0x12]) - (uint)param_1[0x13]) -
                                   (uint)param_1[0x14]) - (uint)param_1[0x15]) - (uint)param_1[0x16]
                                 ) + (uint)param_1[0x17]) - (uint)param_1[0x18]) +
                              (uint)param_1[0x19]) - (uint)param_1[0x1a]) + (uint)param_1[0x1b]) -
                           (uint)param_1[0x1c]) + (uint)param_1[0x1d]) - (uint)param_1[0x1e]) -
                        (uint)param_1[0x1f]) + (uint)param_1[0x20] + (uint)param_1[0x21] +
                       (uint)param_1[0x22]) - (uint)param_1[0x23]) - (uint)param_1[0x24]) -
                    (uint)param_1[0x25]) - (uint)param_1[0x26]) + (uint)param_1[0x27]) -
                 (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0xd] = ((((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) +
                                                (uint)param_1[2]) - (uint)param_1[3]) +
                                              (uint)param_1[4]) - (uint)param_1[5]) +
                                            (uint)param_1[6]) - (uint)param_1[7]) + (uint)param_1[8]
                                          ) - (uint)param_1[9]) + (uint)param_1[10]) -
                                       (uint)param_1[0xb]) + (uint)param_1[0xc] + (uint)param_1[0xd]
                                       + (uint)param_1[0xe] + (uint)param_1[0xf]) -
                                     (uint)param_1[0x10]) - (uint)param_1[0x11]) -
                                   (uint)param_1[0x12]) + (uint)param_1[0x13] + (uint)param_1[0x14]
                                  + (uint)param_1[0x15]) - (uint)param_1[0x16]) -
                                (uint)param_1[0x17]) + (uint)param_1[0x18] + (uint)param_1[0x19]) -
                              (uint)param_1[0x1a]) - (uint)param_1[0x1b]) + (uint)param_1[0x1c] +
                            (uint)param_1[0x1d]) - (uint)param_1[0x1e]) - (uint)param_1[0x1f]) -
                         (uint)param_1[0x20]) + (uint)param_1[0x21]) - (uint)param_1[0x22]) -
                      (uint)param_1[0x23]) + (uint)param_1[0x24]) - (uint)param_1[0x25]) -
                   (uint)param_1[0x26]) - (uint)param_1[0x27]) + (uint)param_1[0x28]) -
                 (uint)param_1[0x29];
  param_2[0xe] = ((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2]) -
                                        (uint)param_1[3]) - (uint)param_1[4]) - (uint)param_1[5]) +
                                     (uint)param_1[6]) - (uint)param_1[7]) + (uint)param_1[8] +
                                    (uint)param_1[9] + (uint)param_1[10]) - (uint)param_1[0xb]) +
                                 (uint)param_1[0xc]) - (uint)param_1[0xd]) - (uint)param_1[0xe]) +
                               (uint)param_1[0xf] + (uint)param_1[0x10] + (uint)param_1[0x11]) -
                             (uint)param_1[0x12]) - (uint)param_1[0x13]) - (uint)param_1[0x14]) -
                          (uint)param_1[0x15]) + (uint)param_1[0x16] + (uint)param_1[0x17] +
                         (uint)param_1[0x18]) - (uint)param_1[0x19]) + (uint)param_1[0x1a] +
                        (uint)param_1[0x1b] + (uint)param_1[0x1c]) - (uint)param_1[0x1d]) -
                     (uint)param_1[0x1e]) - (uint)param_1[0x1f]) + (uint)param_1[0x20] +
                    (uint)param_1[0x21] + (uint)param_1[0x22] + (uint)param_1[0x23] +
                    (uint)param_1[0x24] + (uint)param_1[0x25] + (uint)param_1[0x26]) -
                  (uint)param_1[0x27]) - (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0xf] = (((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2] +
                                          (uint)param_1[3] + (uint)param_1[4] + (uint)param_1[5]) -
                                        (uint)param_1[6]) + (uint)param_1[7]) - (uint)param_1[8]) -
                                     (uint)param_1[9]) - (uint)param_1[10]) + (uint)param_1[0xb] +
                                    (uint)param_1[0xc] + (uint)param_1[0xd]) - (uint)param_1[0xe]) -
                                 (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11]) -
                              (uint)param_1[0x12]) - (uint)param_1[0x13]) - (uint)param_1[0x14]) -
                           (uint)param_1[0x15]) + (uint)param_1[0x16] + (uint)param_1[0x17] +
                           (uint)param_1[0x18] + (uint)param_1[0x19] + (uint)param_1[0x1a] +
                          (uint)param_1[0x1b]) - (uint)param_1[0x1c]) - (uint)param_1[0x1d]) -
                       (uint)param_1[0x1e]) - (uint)param_1[0x1f]) + (uint)param_1[0x20]) -
                    (uint)param_1[0x21]) + (uint)param_1[0x22] + (uint)param_1[0x23] +
                    (uint)param_1[0x24] + (uint)param_1[0x25]) - (uint)param_1[0x26]) +
                  (uint)param_1[0x27] + (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0x10] =
       (((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2] +
                                   (uint)param_1[3]) - (uint)param_1[4]) - (uint)param_1[5]) +
                                 (uint)param_1[6] + (uint)param_1[7] + (uint)param_1[8] +
                                 (uint)param_1[9] + (uint)param_1[10]) - (uint)param_1[0xb]) +
                              (uint)param_1[0xc]) - (uint)param_1[0xd]) + (uint)param_1[0xe] +
                             (uint)param_1[0xf] + (uint)param_1[0x10]) - (uint)param_1[0x11]) +
                          (uint)param_1[0x12]) - (uint)param_1[0x13]) + (uint)param_1[0x14]) -
                       (uint)param_1[0x15]) - (uint)param_1[0x16]) - (uint)param_1[0x17]) -
                    (uint)param_1[0x18]) - (uint)param_1[0x19]) + (uint)param_1[0x1a] +
                   (uint)param_1[0x1b] + (uint)param_1[0x1c] + (uint)param_1[0x1d]) -
                 (uint)param_1[0x1e]) - (uint)param_1[0x1f]) + (uint)param_1[0x20]) -
              (uint)param_1[0x21]) - (uint)param_1[0x22]) + (uint)param_1[0x23]) -
           (uint)param_1[0x24]) + (uint)param_1[0x25]) - (uint)param_1[0x26]) + (uint)param_1[0x27])
       - (uint)param_1[0x28]) + (uint)param_1[0x29];
  param_2[0x11] =
       (((((((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2] +
                                       (uint)param_1[3] + (uint)param_1[4]) - (uint)param_1[5]) +
                                     (uint)param_1[6] + (uint)param_1[7] + (uint)param_1[8]) -
                                   (uint)param_1[9]) - (uint)param_1[10]) + (uint)param_1[0xb]) -
                                (uint)param_1[0xc]) + (uint)param_1[0xd] + (uint)param_1[0xe] +
                               (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11]) -
                            (uint)param_1[0x12]) - (uint)param_1[0x13]) + (uint)param_1[0x14]) -
                         (uint)param_1[0x15]) + (uint)param_1[0x16]) - (uint)param_1[0x17]) -
                      (uint)param_1[0x18]) + (uint)param_1[0x19]) - (uint)param_1[0x1a]) +
                   (uint)param_1[0x1b]) - (uint)param_1[0x1c]) + (uint)param_1[0x1d]) -
                (uint)param_1[0x1e]) - (uint)param_1[0x1f]) + (uint)param_1[0x20]) -
             (uint)param_1[0x21]) - (uint)param_1[0x22]) + (uint)param_1[0x23]) -
          (uint)param_1[0x24]) + (uint)param_1[0x25]) - (uint)param_1[0x26]) + (uint)param_1[0x27] +
       (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0x12] =
       (((((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) - (uint)param_1[2]) -
                                      (uint)param_1[3]) + (uint)param_1[4] + (uint)param_1[5]) -
                                    (uint)param_1[6]) + (uint)param_1[7]) - (uint)param_1[8]) +
                                  (uint)param_1[9] + (uint)param_1[10]) - (uint)param_1[0xb]) -
                               (uint)param_1[0xc]) - (uint)param_1[0xd]) + (uint)param_1[0xe]) -
                            (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11] +
                           (uint)param_1[0x12] + (uint)param_1[0x13]) - (uint)param_1[0x14]) -
                        (uint)param_1[0x15]) - (uint)param_1[0x16]) - (uint)param_1[0x17]) -
                     (uint)param_1[0x18]) - (uint)param_1[0x19]) - (uint)param_1[0x1a]) -
                  (uint)param_1[0x1b]) + (uint)param_1[0x1c] + (uint)param_1[0x1d] +
                 (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
              (uint)param_1[0x21]) + (uint)param_1[0x22]) - (uint)param_1[0x23]) -
           (uint)param_1[0x24]) - (uint)param_1[0x25]) - (uint)param_1[0x26]) - (uint)param_1[0x27])
       - (uint)param_1[0x28]) + (uint)param_1[0x29];
  param_2[0x13] =
       (((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2] +
                                (uint)param_1[3]) - (uint)param_1[4]) - (uint)param_1[5]) +
                             (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8]) -
                          (uint)param_1[9]) - (uint)param_1[10]) - (uint)param_1[0xb]) -
                       (uint)param_1[0xc]) - (uint)param_1[0xd]) + (uint)param_1[0xe] +
                      (uint)param_1[0xf] + (uint)param_1[0x10]) - (uint)param_1[0x11]) +
                    (uint)param_1[0x12] + (uint)param_1[0x13] + (uint)param_1[0x14] +
                   (uint)param_1[0x15]) - (uint)param_1[0x16]) + (uint)param_1[0x17] +
                 (uint)param_1[0x18]) - (uint)param_1[0x19]) + (uint)param_1[0x1a] +
               (uint)param_1[0x1b]) - (uint)param_1[0x1c]) + (uint)param_1[0x1d] +
              (uint)param_1[0x1e] + (uint)param_1[0x1f] + (uint)param_1[0x20] + (uint)param_1[0x21])
            - (uint)param_1[0x22]) + (uint)param_1[0x23]) - (uint)param_1[0x24]) -
         (uint)param_1[0x25]) - (uint)param_1[0x26]) + (uint)param_1[0x27] + (uint)param_1[0x28]) -
       (uint)param_1[0x29];
  param_2[0x14] =
       (((((((((((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1]) - (uint)param_1[2]) -
                                        (uint)param_1[3]) - (uint)param_1[4]) + (uint)param_1[5]) -
                                     (uint)param_1[6]) + (uint)param_1[7]) - (uint)param_1[8]) -
                                  (uint)param_1[9]) + (uint)param_1[10] + (uint)param_1[0xb]) -
                                (uint)param_1[0xc]) - (uint)param_1[0xd]) + (uint)param_1[0xe]) -
                             (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11]) -
                          (uint)param_1[0x12]) - (uint)param_1[0x13]) + (uint)param_1[0x14] +
                        (uint)param_1[0x15]) - (uint)param_1[0x16]) + (uint)param_1[0x17] +
                      (uint)param_1[0x18]) - (uint)param_1[0x19]) - (uint)param_1[0x1a]) -
                   (uint)param_1[0x1b]) - (uint)param_1[0x1c]) - (uint)param_1[0x1d]) -
                (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) +
             (uint)param_1[0x21]) - (uint)param_1[0x22]) + (uint)param_1[0x23] + (uint)param_1[0x24]
           ) - (uint)param_1[0x25]) + (uint)param_1[0x26]) - (uint)param_1[0x27]) +
       (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0x15] =
       ((((((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) - (uint)param_1[2]) -
                                       (uint)param_1[3]) + (uint)param_1[4] + (uint)param_1[5] +
                                       (uint)param_1[6] + (uint)param_1[7]) - (uint)param_1[8]) -
                                    (uint)param_1[9]) - (uint)param_1[10]) - (uint)param_1[0xb]) -
                                 (uint)param_1[0xc]) - (uint)param_1[0xd]) - (uint)param_1[0xe]) -
                              (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11]) -
                           (uint)param_1[0x12]) - (uint)param_1[0x13]) + (uint)param_1[0x14]) -
                        (uint)param_1[0x15]) + (uint)param_1[0x16] + (uint)param_1[0x17] +
                       (uint)param_1[0x18]) - (uint)param_1[0x19]) - (uint)param_1[0x1a]) +
                    (uint)param_1[0x1b]) - (uint)param_1[0x1c]) - (uint)param_1[0x1d]) -
                 (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
              (uint)param_1[0x21]) - (uint)param_1[0x22]) - (uint)param_1[0x23]) -
           (uint)param_1[0x24]) + (uint)param_1[0x25]) - (uint)param_1[0x26]) - (uint)param_1[0x27])
       - (uint)param_1[0x28]) + (uint)param_1[0x29];
  param_2[0x16] =
       ((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2] +
                                  (uint)param_1[3] + (uint)param_1[4] + (uint)param_1[5] +
                                  (uint)param_1[6] + (uint)param_1[7]) - (uint)param_1[8]) +
                               (uint)param_1[9]) - (uint)param_1[10]) + (uint)param_1[0xb]) -
                            (uint)param_1[0xc]) + (uint)param_1[0xd] + (uint)param_1[0xe] +
                           (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11] +
                         (uint)param_1[0x12]) - (uint)param_1[0x13]) - (uint)param_1[0x14]) +
                       (uint)param_1[0x15] + (uint)param_1[0x16]) - (uint)param_1[0x17]) +
                    (uint)param_1[0x18]) - (uint)param_1[0x19]) - (uint)param_1[0x1a]) +
                 (uint)param_1[0x1b]) - (uint)param_1[0x1c]) + (uint)param_1[0x1d] +
                (uint)param_1[0x1e] + (uint)param_1[0x1f]) - (uint)param_1[0x20]) +
             (uint)param_1[0x21]) - (uint)param_1[0x22]) - (uint)param_1[0x23]) -
          (uint)param_1[0x24]) - (uint)param_1[0x25]) + (uint)param_1[0x26]) - (uint)param_1[0x27])
       + (uint)param_1[0x28] + (uint)param_1[0x29];
  param_2[0x17] =
       ((((((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2] +
                                        (uint)param_1[3]) - (uint)param_1[4]) - (uint)param_1[5]) -
                                     (uint)param_1[6]) - (uint)param_1[7]) + (uint)param_1[8]) -
                                  (uint)param_1[9]) - (uint)param_1[10]) + (uint)param_1[0xb] +
                                (uint)param_1[0xc]) - (uint)param_1[0xd]) - (uint)param_1[0xe]) +
                             (uint)param_1[0xf]) - (uint)param_1[0x10]) - (uint)param_1[0x11]) +
                           (uint)param_1[0x12] + (uint)param_1[0x13]) - (uint)param_1[0x14]) -
                        (uint)param_1[0x15]) + (uint)param_1[0x16]) - (uint)param_1[0x17]) +
                      (uint)param_1[0x18] + (uint)param_1[0x19]) - (uint)param_1[0x1a]) +
                   (uint)param_1[0x1b]) - (uint)param_1[0x1c]) + (uint)param_1[0x1d] +
                 (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
              (uint)param_1[0x21]) - (uint)param_1[0x22]) - (uint)param_1[0x23]) -
           (uint)param_1[0x24]) - (uint)param_1[0x25]) + (uint)param_1[0x26]) - (uint)param_1[0x27])
       - (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0x18] =
       ((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1]) - (uint)param_1[2]) +
                              (uint)param_1[3] + (uint)param_1[4]) - (uint)param_1[5]) +
                            (uint)param_1[6] + (uint)param_1[7]) - (uint)param_1[8]) +
                          (uint)param_1[9] + (uint)param_1[10]) - (uint)param_1[0xb]) -
                       (uint)param_1[0xc]) - (uint)param_1[0xd]) - (uint)param_1[0xe]) +
                     (uint)param_1[0xf] + (uint)param_1[0x10] + (uint)param_1[0x11]) -
                   (uint)param_1[0x12]) + (uint)param_1[0x13] + (uint)param_1[0x14] +
                   (uint)param_1[0x15] + (uint)param_1[0x16] + (uint)param_1[0x17] +
                   (uint)param_1[0x18] + (uint)param_1[0x19]) - (uint)param_1[0x1a]) -
                (uint)param_1[0x1b]) - (uint)param_1[0x1c]) + (uint)param_1[0x1d] +
              (uint)param_1[0x1e]) - (uint)param_1[0x1f]) + (uint)param_1[0x20] +
             (uint)param_1[0x21] + (uint)param_1[0x22]) - (uint)param_1[0x23]) - (uint)param_1[0x24]
          ) - (uint)param_1[0x25]) - (uint)param_1[0x26]) + (uint)param_1[0x27] +
       (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0x19] =
       (((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2] +
                                     (uint)param_1[3]) - (uint)param_1[4]) + (uint)param_1[5] +
                                   (uint)param_1[6]) - (uint)param_1[7]) + (uint)param_1[8] +
                                  (uint)param_1[9] + (uint)param_1[10]) - (uint)param_1[0xb]) -
                               (uint)param_1[0xc]) + (uint)param_1[0xd]) - (uint)param_1[0xe]) +
                            (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11] +
                           (uint)param_1[0x12] + (uint)param_1[0x13]) - (uint)param_1[0x14]) -
                        (uint)param_1[0x15]) + (uint)param_1[0x16] + (uint)param_1[0x17]) -
                      (uint)param_1[0x18]) - (uint)param_1[0x19]) + (uint)param_1[0x1a]) -
                   (uint)param_1[0x1b]) + (uint)param_1[0x1c]) - (uint)param_1[0x1d]) +
                (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) +
             (uint)param_1[0x21]) - (uint)param_1[0x22]) - (uint)param_1[0x23]) -
          (uint)param_1[0x24]) - (uint)param_1[0x25]) + (uint)param_1[0x26]) - (uint)param_1[0x27])
       + (uint)param_1[0x28] + (uint)param_1[0x29];
  param_2[0x1a] =
       ((((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2] +
                                    (uint)param_1[3] + (uint)param_1[4]) - (uint)param_1[5]) -
                                 (uint)param_1[6]) + (uint)param_1[7]) - (uint)param_1[8]) -
                              (uint)param_1[9]) - (uint)param_1[10]) - (uint)param_1[0xb]) +
                           (uint)param_1[0xc]) - (uint)param_1[0xd]) + (uint)param_1[0xe]) -
                        (uint)param_1[0xf]) + (uint)param_1[0x10]) - (uint)param_1[0x11]) +
                     (uint)param_1[0x12]) - (uint)param_1[0x13]) - (uint)param_1[0x14]) +
                   (uint)param_1[0x15] + (uint)param_1[0x16] + (uint)param_1[0x17] +
                   (uint)param_1[0x18] + (uint)param_1[0x19]) - (uint)param_1[0x1a]) -
                (uint)param_1[0x1b]) - (uint)param_1[0x1c]) - (uint)param_1[0x1d]) +
              (uint)param_1[0x1e] + (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
           (uint)param_1[0x21]) - (uint)param_1[0x22]) + (uint)param_1[0x23] + (uint)param_1[0x24])
        - (uint)param_1[0x25]) - (uint)param_1[0x26]) + (uint)param_1[0x27] + (uint)param_1[0x28] +
       (uint)param_1[0x29];
  param_2[0x1b] =
       ((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2]) -
                                   (uint)param_1[3]) + (uint)param_1[4]) - (uint)param_1[5]) -
                                (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8]) -
                             (uint)param_1[9]) - (uint)param_1[10]) - (uint)param_1[0xb]) +
                           (uint)param_1[0xc] + (uint)param_1[0xd]) - (uint)param_1[0xe]) +
                         (uint)param_1[0xf] + (uint)param_1[0x10] + (uint)param_1[0x11] +
                         (uint)param_1[0x12] + (uint)param_1[0x13]) - (uint)param_1[0x14]) -
                      (uint)param_1[0x15]) - (uint)param_1[0x16]) - (uint)param_1[0x17]) +
                    (uint)param_1[0x18] + (uint)param_1[0x19] + (uint)param_1[0x1a]) -
                  (uint)param_1[0x1b]) + (uint)param_1[0x1c] + (uint)param_1[0x1d] +
                 (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
              (uint)param_1[0x21]) - (uint)param_1[0x22]) + (uint)param_1[0x23]) -
           (uint)param_1[0x24]) - (uint)param_1[0x25]) - (uint)param_1[0x26]) - (uint)param_1[0x27])
       - (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0x1c] =
       (((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2] +
                                    (uint)param_1[3] + (uint)param_1[4]) - (uint)param_1[5]) +
                                  (uint)param_1[6] + (uint)param_1[7]) - (uint)param_1[8]) -
                               (uint)param_1[9]) + (uint)param_1[10] + (uint)param_1[0xb]) -
                             (uint)param_1[0xc]) + (uint)param_1[0xd]) - (uint)param_1[0xe]) +
                          (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11] +
                         (uint)param_1[0x12] + (uint)param_1[0x13]) - (uint)param_1[0x14]) -
                      (uint)param_1[0x15]) + (uint)param_1[0x16]) - (uint)param_1[0x17]) -
                   (uint)param_1[0x18]) - (uint)param_1[0x19]) - (uint)param_1[0x1a]) +
                (uint)param_1[0x1b]) - (uint)param_1[0x1c]) - (uint)param_1[0x1d]) -
             (uint)param_1[0x1e]) + (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
          (uint)param_1[0x21]) + (uint)param_1[0x22] + (uint)param_1[0x23] + (uint)param_1[0x24]) -
        (uint)param_1[0x25]) - (uint)param_1[0x26]) + (uint)param_1[0x27] + (uint)param_1[0x28] +
       (uint)param_1[0x29];
  param_2[0x1d] =
       (((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1]) - (uint)param_1[2]) -
                              (uint)param_1[3]) - (uint)param_1[4]) + (uint)param_1[5] +
                             (uint)param_1[6] + (uint)param_1[7]) - (uint)param_1[8]) +
                          (uint)param_1[9]) - (uint)param_1[10]) - (uint)param_1[0xb]) +
                       (uint)param_1[0xc]) - (uint)param_1[0xd]) + (uint)param_1[0xe] +
                     (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11] +
                   (uint)param_1[0x12]) - (uint)param_1[0x13]) + (uint)param_1[0x14] +
                  (uint)param_1[0x15] + (uint)param_1[0x16] + (uint)param_1[0x17]) -
                (uint)param_1[0x18]) + (uint)param_1[0x19] + (uint)param_1[0x1a]) -
              (uint)param_1[0x1b]) + (uint)param_1[0x1c] + (uint)param_1[0x1d] + (uint)param_1[0x1e]
              + (uint)param_1[0x1f] + (uint)param_1[0x20]) - (uint)param_1[0x21]) -
           (uint)param_1[0x22]) + (uint)param_1[0x23] + (uint)param_1[0x24]) - (uint)param_1[0x25])
         + (uint)param_1[0x26] + (uint)param_1[0x27]) - (uint)param_1[0x28]) + (uint)param_1[0x29];
  param_2[0x1e] =
       (((((((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2] +
                                      (uint)param_1[3]) - (uint)param_1[4]) - (uint)param_1[5]) -
                                   (uint)param_1[6]) - (uint)param_1[7]) + (uint)param_1[8] +
                                 (uint)param_1[9]) - (uint)param_1[10]) - (uint)param_1[0xb]) -
                              (uint)param_1[0xc]) + (uint)param_1[0xd]) - (uint)param_1[0xe]) -
                           (uint)param_1[0xf]) + (uint)param_1[0x10]) - (uint)param_1[0x11]) -
                        (uint)param_1[0x12]) - (uint)param_1[0x13]) + (uint)param_1[0x14]) -
                     (uint)param_1[0x15]) - (uint)param_1[0x16]) + (uint)param_1[0x17] +
                   (uint)param_1[0x18]) - (uint)param_1[0x19]) - (uint)param_1[0x1a]) +
                (uint)param_1[0x1b]) - (uint)param_1[0x1c]) - (uint)param_1[0x1d]) -
             (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
          (uint)param_1[0x21]) - (uint)param_1[0x22]) + (uint)param_1[0x23] + (uint)param_1[0x24] +
        (uint)param_1[0x25]) - (uint)param_1[0x26]) + (uint)param_1[0x27] + (uint)param_1[0x28] +
       (uint)param_1[0x29];
  param_2[0x1f] =
       (((((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1]) - (uint)param_1[2]) +
                                   (uint)param_1[3] + (uint)param_1[4]) - (uint)param_1[5]) -
                                (uint)param_1[6]) + (uint)param_1[7] + (uint)param_1[8] +
                                (uint)param_1[9] + (uint)param_1[10] + (uint)param_1[0xb] +
                               (uint)param_1[0xc]) - (uint)param_1[0xd]) - (uint)param_1[0xe]) -
                            (uint)param_1[0xf]) + (uint)param_1[0x10] + (uint)param_1[0x11] +
                            (uint)param_1[0x12] + (uint)param_1[0x13]) - (uint)param_1[0x14]) +
                         (uint)param_1[0x15]) - (uint)param_1[0x16]) + (uint)param_1[0x17]) -
                      (uint)param_1[0x18]) - (uint)param_1[0x19]) + (uint)param_1[0x1a] +
                    (uint)param_1[0x1b]) - (uint)param_1[0x1c]) + (uint)param_1[0x1d]) -
                 (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) +
              (uint)param_1[0x21]) - (uint)param_1[0x22]) + (uint)param_1[0x23]) -
           (uint)param_1[0x24]) + (uint)param_1[0x25]) - (uint)param_1[0x26]) + (uint)param_1[0x27])
       - (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0x20] =
       ((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2] +
                                (uint)param_1[3]) - (uint)param_1[4]) + (uint)param_1[5] +
                               (uint)param_1[6] + (uint)param_1[7] + (uint)param_1[8]) -
                             (uint)param_1[9]) + (uint)param_1[10] + (uint)param_1[0xb]) -
                           (uint)param_1[0xc]) + (uint)param_1[0xd] + (uint)param_1[0xe]) -
                         (uint)param_1[0xf]) + (uint)param_1[0x10]) - (uint)param_1[0x11]) +
                       (uint)param_1[0x12] + (uint)param_1[0x13] + (uint)param_1[0x14]) -
                     (uint)param_1[0x15]) - (uint)param_1[0x16]) + (uint)param_1[0x17]) -
                  (uint)param_1[0x18]) + (uint)param_1[0x19] + (uint)param_1[0x1a] +
                 (uint)param_1[0x1b]) - (uint)param_1[0x1c]) - (uint)param_1[0x1d]) -
              (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
           (uint)param_1[0x21]) + (uint)param_1[0x22] + (uint)param_1[0x23] + (uint)param_1[0x24] +
          (uint)param_1[0x25]) - (uint)param_1[0x26]) + (uint)param_1[0x27]) - (uint)param_1[0x28])
       + (uint)param_1[0x29];
  param_2[0x21] =
       ((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) - (uint)param_1[2]) +
                                    (uint)param_1[3] + (uint)param_1[4] + (uint)param_1[5] +
                                   (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8]) +
                                 (uint)param_1[9] + (uint)param_1[10] + (uint)param_1[0xb]) -
                               (uint)param_1[0xc]) - (uint)param_1[0xd]) + (uint)param_1[0xe] +
                             (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11]) -
                          (uint)param_1[0x12]) + (uint)param_1[0x13]) - (uint)param_1[0x14]) +
                        (uint)param_1[0x15] + (uint)param_1[0x16] + (uint)param_1[0x17]) -
                      (uint)param_1[0x18]) - (uint)param_1[0x19]) + (uint)param_1[0x1a] +
                    (uint)param_1[0x1b]) - (uint)param_1[0x1c]) + (uint)param_1[0x1d]) -
                 (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
              (uint)param_1[0x21]) - (uint)param_1[0x22]) - (uint)param_1[0x23]) +
           (uint)param_1[0x24]) - (uint)param_1[0x25]) + (uint)param_1[0x26]) - (uint)param_1[0x27])
       - (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0x22] =
       (((((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1]) - (uint)param_1[2]) +
                                  (uint)param_1[3]) - (uint)param_1[4]) - (uint)param_1[5]) -
                               (uint)param_1[6]) + (uint)param_1[7] + (uint)param_1[8] +
                               (uint)param_1[9] + (uint)param_1[10] + (uint)param_1[0xb]) -
                             (uint)param_1[0xc]) - (uint)param_1[0xd]) - (uint)param_1[0xe]) +
                          (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11]) -
                       (uint)param_1[0x12]) + (uint)param_1[0x13]) - (uint)param_1[0x14]) -
                    (uint)param_1[0x15]) + (uint)param_1[0x16] + (uint)param_1[0x17]) -
                  (uint)param_1[0x18]) - (uint)param_1[0x19]) + (uint)param_1[0x1a] +
                 (uint)param_1[0x1b] + (uint)param_1[0x1c] + (uint)param_1[0x1d]) -
               (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
            (uint)param_1[0x21]) - (uint)param_1[0x22]) - (uint)param_1[0x23]) - (uint)param_1[0x24]
         ) + (uint)param_1[0x25] + (uint)param_1[0x26] + (uint)param_1[0x27]) - (uint)param_1[0x28])
       - (uint)param_1[0x29];
  param_2[0x23] =
       (((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2] +
                                (uint)param_1[3] + (uint)param_1[4]) - (uint)param_1[5]) -
                             (uint)param_1[6]) + (uint)param_1[7] + (uint)param_1[8]) -
                           (uint)param_1[9]) - (uint)param_1[10]) + (uint)param_1[0xb] +
                          (uint)param_1[0xc] + (uint)param_1[0xd]) - (uint)param_1[0xe]) -
                       (uint)param_1[0xf]) + (uint)param_1[0x10]) - (uint)param_1[0x11]) +
                     (uint)param_1[0x12] + (uint)param_1[0x13]) - (uint)param_1[0x14]) -
                  (uint)param_1[0x15]) - (uint)param_1[0x16]) + (uint)param_1[0x17] +
                (uint)param_1[0x18]) - (uint)param_1[0x19]) - (uint)param_1[0x1a]) +
              (uint)param_1[0x1b] + (uint)param_1[0x1c]) - (uint)param_1[0x1d]) -
           (uint)param_1[0x1e]) + (uint)param_1[0x1f] + (uint)param_1[0x20]) - (uint)param_1[0x21])
         + (uint)param_1[0x22] + (uint)param_1[0x23] + (uint)param_1[0x24] + (uint)param_1[0x25] +
         (uint)param_1[0x26] + (uint)param_1[0x27]) - (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0x24] =
       ((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2]) -
                              (uint)param_1[3]) - (uint)param_1[4]) - (uint)param_1[5]) -
                           (uint)param_1[6]) + (uint)param_1[7] + (uint)param_1[8] +
                          (uint)param_1[9]) - (uint)param_1[10]) + (uint)param_1[0xb] +
                        (uint)param_1[0xc]) - (uint)param_1[0xd]) + (uint)param_1[0xe] +
                       (uint)param_1[0xf] + (uint)param_1[0x10] + (uint)param_1[0x11] +
                       (uint)param_1[0x12] + (uint)param_1[0x13] + (uint)param_1[0x14] +
                      (uint)param_1[0x15]) - (uint)param_1[0x16]) - (uint)param_1[0x17]) +
                   (uint)param_1[0x18]) - (uint)param_1[0x19]) - (uint)param_1[0x1a]) -
                (uint)param_1[0x1b]) - (uint)param_1[0x1c]) + (uint)param_1[0x1d] +
               (uint)param_1[0x1e] + (uint)param_1[0x1f] + (uint)param_1[0x20]) -
             (uint)param_1[0x21]) - (uint)param_1[0x22]) - (uint)param_1[0x23]) -
          (uint)param_1[0x24]) + (uint)param_1[0x25]) - (uint)param_1[0x26]) + (uint)param_1[0x27] +
       (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0x25] =
       (((((((((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) - (uint)param_1[2])
                                          + (uint)param_1[3]) - (uint)param_1[4]) + (uint)param_1[5]
                                        ) - (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8]
                                     ) - (uint)param_1[9]) + (uint)param_1[10]) - (uint)param_1[0xb]
                                  ) - (uint)param_1[0xc]) - (uint)param_1[0xd]) - (uint)param_1[0xe]
                               ) - (uint)param_1[0xf]) - (uint)param_1[0x10]) + (uint)param_1[0x11]
                            + (uint)param_1[0x12]) - (uint)param_1[0x13]) - (uint)param_1[0x14]) -
                         (uint)param_1[0x15]) + (uint)param_1[0x16]) - (uint)param_1[0x17]) +
                      (uint)param_1[0x18]) - (uint)param_1[0x19]) - (uint)param_1[0x1a]) +
                   (uint)param_1[0x1b]) - (uint)param_1[0x1c]) - (uint)param_1[0x1d]) +
                 (uint)param_1[0x1e] + (uint)param_1[0x1f]) - (uint)param_1[0x20]) +
              (uint)param_1[0x21]) - (uint)param_1[0x22]) + (uint)param_1[0x23]) -
           (uint)param_1[0x24]) - (uint)param_1[0x25]) + (uint)param_1[0x26]) - (uint)param_1[0x27])
       - (uint)param_1[0x28]) - (uint)param_1[0x29];
  param_2[0x26] =
       (((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2] +
                                (uint)param_1[3]) - (uint)param_1[4]) + (uint)param_1[5] +
                               (uint)param_1[6] + (uint)param_1[7]) - (uint)param_1[8]) -
                            (uint)param_1[9]) - (uint)param_1[10]) + (uint)param_1[0xb] +
                           (uint)param_1[0xc] + (uint)param_1[0xd]) - (uint)param_1[0xe]) -
                        (uint)param_1[0xf]) - (uint)param_1[0x10]) - (uint)param_1[0x11]) -
                     (uint)param_1[0x12]) - (uint)param_1[0x13]) + (uint)param_1[0x14] +
                   (uint)param_1[0x15]) - (uint)param_1[0x16]) + (uint)param_1[0x17] +
                  (uint)param_1[0x18] + (uint)param_1[0x19] + (uint)param_1[0x1a] +
                 (uint)param_1[0x1b]) - (uint)param_1[0x1c]) - (uint)param_1[0x1d]) +
               (uint)param_1[0x1e] + (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
            (uint)param_1[0x21]) + (uint)param_1[0x22]) - (uint)param_1[0x23]) - (uint)param_1[0x24]
         ) - (uint)param_1[0x25]) + (uint)param_1[0x26] + (uint)param_1[0x27] + (uint)param_1[0x28])
       - (uint)param_1[0x29];
  param_2[0x27] =
       ((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) - (uint)param_1[2]) -
                             (uint)param_1[3]) - (uint)param_1[4]) + (uint)param_1[5]) -
                          (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8]) +
                       (uint)param_1[9]) - (uint)param_1[10]) + (uint)param_1[0xb]) -
                    (uint)param_1[0xc]) + (uint)param_1[0xd] + (uint)param_1[0xe]) -
                  (uint)param_1[0xf]) - (uint)param_1[0x10]) - (uint)param_1[0x11]) +
                (uint)param_1[0x12] + (uint)param_1[0x13] + (uint)param_1[0x14] +
                (uint)param_1[0x15] + (uint)param_1[0x16]) - (uint)param_1[0x17]) +
              (uint)param_1[0x18] + (uint)param_1[0x19] + (uint)param_1[0x1a] + (uint)param_1[0x1b]
             + (uint)param_1[0x1c]) - (uint)param_1[0x1d]) + (uint)param_1[0x1e] +
            (uint)param_1[0x1f] + (uint)param_1[0x20] + (uint)param_1[0x21] + (uint)param_1[0x22]) -
          (uint)param_1[0x23]) - (uint)param_1[0x24]) + (uint)param_1[0x25] + (uint)param_1[0x26] +
        (uint)param_1[0x27]) - (uint)param_1[0x28]) + (uint)param_1[0x29];
  param_2[0x28] =
       (((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) - (uint)param_1[2]) -
                          (uint)param_1[3]) + (uint)param_1[4] + (uint)param_1[5] + (uint)param_1[6]
                         ) - (uint)param_1[7]) + (uint)param_1[8] + (uint)param_1[9]) -
                      (uint)param_1[10]) + (uint)param_1[0xb]) - (uint)param_1[0xc]) -
                   (uint)param_1[0xd]) - (uint)param_1[0xe]) + (uint)param_1[0xf] +
                  (uint)param_1[0x10] + (uint)param_1[0x11] + (uint)param_1[0x12] +
                  (uint)param_1[0x13] + (uint)param_1[0x14] + (uint)param_1[0x15] +
                 (uint)param_1[0x16]) - (uint)param_1[0x17]) + (uint)param_1[0x18] +
               (uint)param_1[0x19]) - (uint)param_1[0x1a]) + (uint)param_1[0x1b] +
             (uint)param_1[0x1c]) - (uint)param_1[0x1d]) + (uint)param_1[0x1e] + (uint)param_1[0x1f]
           + (uint)param_1[0x20]) - (uint)param_1[0x21]) - (uint)param_1[0x22]) +
         (uint)param_1[0x23] + (uint)param_1[0x24]) - (uint)param_1[0x25]) + (uint)param_1[0x26] +
       (uint)param_1[0x27] + (uint)param_1[0x28] + (uint)param_1[0x29];
  param_2[0x29] =
       ((((((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2] +
                                      (uint)param_1[3] + (uint)param_1[4] + (uint)param_1[5] +
                                     (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8]) -
                                  (uint)param_1[9]) + (uint)param_1[10] + (uint)param_1[0xb]) -
                                (uint)param_1[0xc]) + (uint)param_1[0xd]) - (uint)param_1[0xe]) -
                             (uint)param_1[0xf]) - (uint)param_1[0x10]) - (uint)param_1[0x11]) -
                          (uint)param_1[0x12]) - (uint)param_1[0x13]) + (uint)param_1[0x14]) -
                       (uint)param_1[0x15]) + (uint)param_1[0x16]) - (uint)param_1[0x17]) -
                    (uint)param_1[0x18]) + (uint)param_1[0x19] + (uint)param_1[0x1a] +
                    (uint)param_1[0x1b] + (uint)param_1[0x1c]) - (uint)param_1[0x1d]) -
                 (uint)param_1[0x1e]) - (uint)param_1[0x1f]) - (uint)param_1[0x20]) -
              (uint)param_1[0x21]) - (uint)param_1[0x22]) - (uint)param_1[0x23]) -
           (uint)param_1[0x24]) - (uint)param_1[0x25]) - (uint)param_1[0x26]) - (uint)param_1[0x27])
       - (uint)param_1[0x28]) + (uint)param_1[0x29];
  return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个简单异或，再用z3解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意原始密文应该改成大端序排列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-PYTHON&#34;&gt;from z3 import *
import ctypes
from pwn import *
import struct
data=[0xFF, 0xFF, 0xFF, 0x94, 0xFF, 0xFF, 0xFF, 0x38, 0x00, 0x00, 0x01, 0x26, 0xFF, 0xFF, 0xFF, 0x28, 0xFF, 0xFF, 0xFC, 0x10, 0x00, 0x00, 0x02, 0x94, 0xFF, 0xFF, 0xFC, 0x9E, 0x00, 0x00, 0x06, 0xEA, 0x00, 0x00, 0x00, 0xDC, 0x00, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0xFD, 0xF6, 0xFF, 0xFF, 0xFA, 0x82, 0xFF, 0xFF, 0xFC, 0xD0, 0x00, 0x00, 0x01, 0x82, 0x00, 0x00, 0x03, 0xDE, 0x00, 0x00, 0x01, 0x4E, 0x00, 0x00, 0x02, 0xB2, 0xFF, 0xFF, 0xF8, 0xD8, 0x00, 0x00, 0x01, 0x74, 0xFF, 0xFF, 0xFA, 0xA6, 0xFF, 0xFF, 0xF9, 0xD4, 0x00, 0x00, 0x01, 0xC2, 0xFF, 0xFF, 0xF9, 0x7C, 0x00, 0x00, 0x03, 0x5A, 0x00, 0x00, 0x01, 0x46, 0xFF, 0xFF, 0xFF, 0x3C, 0xFF, 0xFF, 0xFA, 0x14, 0x00, 0x00, 0x01, 0xCE, 0x00, 0x00, 0x07, 0xDC, 0xFF, 0xFF, 0xFD, 0x48, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x08, 0x5E, 0xFF, 0xFF, 0xFD, 0xB0, 0xFF, 0xFF, 0xFF, 0xBC, 0x00, 0x00, 0x03, 0x6E, 0xFF, 0xFF, 0xFF, 0x4E, 0xFF, 0xFF, 0xF8, 0x36, 0x00, 0x00, 0x05, 0xC0, 0x00, 0x00, 0x06, 0xAE, 0x00, 0x00, 0x06, 0x94, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00]
ee=[]
e=[]
# 将列表转换为字节流
byte_data = bytes(data)
# 按照大端序解析字节流为32位整数
for i in range(0, len(byte_data), 4):
    value = struct.unpack(&#39;&amp;gt;I&#39;, byte_data[i:i+4])[0]
    ee.append(hex(value))
print(ee)
for i in range(len(ee)):
    e.append(int(ee[i],16))
print(e)
#e = [0xFFFFFF94,0xFFFFFF38,0x00000126,0xFFFFFF28,0xFFFFFC10,0x00000294,0xFFFFFC9E,0x000006EA,0x000000DC,0x00000006,0xFFFFFF0C,0xFFFFFDF6,0xFFFFFA82,0xFFFFFCD0,0x00000182,0x000003DE,0x0000014E,0x000002B2,0xFFFFF8D8,0x00000174,0xFFFFFAA6,0xFFFFF9D4,0x000001C2,0xFFFFF97C,0x0000035A,0x00000146,0xFFFFFF3C,0xFFFFFA14,0x000001CE,0x000007DC,0xFFFFFD48,0x00000098,0x0000085E,0xFFFFFDB0,0xFFFFFFBC,0x0000036E,0xFFFFFF4E,0xFFFFF836,0x000005C0,0x000006AE,0x00000694,0x00000022]
en = map(lambda x: ctypes.c_int32(x).value,e)
enc = [IntVal(i) for i in en]
c = [Int(&#39;c%d&#39; % i) for i in range(42)]
flag = []
s = Solver()
for v in c :
    s.add(v &amp;gt;= 0x0)
    s.add(v &amp;lt;= 0xff)

s.add(enc[0]==(((((((((((((((((((((((((((((((c[0]+c[1]+c[2])-c[3])+c[4])-c[5])-c[6])-c[7])-c[8])+c[9]+c[10])-c[0xb])+c[0xc])-c[0xd])-c[0xe])+c[0xf])-c[0x10])-c[0x11])+c[0x12]+c[0x13])-c[0x14])+c[0x15]+c[0x16]+c[0x17]+c[0x18])-c[0x19])+c[0x1a])-c[0x1b])+c[0x1c]+c[0x1d])-c[0x1e])-c[0x1f])+c[0x20])-c[0x21])+c[0x22]+c[0x23])-c[0x24])-c[0x25])+c[0x26])-c[0x27])+c[0x28]+c[0x29])

s.add(enc[1]==((((((((((((((((((((((((((((((((((c[0]-c[1])+c[2])-c[3])-c[4])+c[5])-c[6])-c[7])-c[8])-c[9])+c[10])-c[0xb])+c[0xc])-c[0xd])-c[0xe])+c[0xf])-c[0x10])-c[0x11])+c[0x12])-c[0x13])+c[0x14]+c[0x15])-c[0x16])-c[0x17])-c[0x18])+c[0x19])-c[0x1a])+c[0x1b])-c[0x1c])-c[0x1d])+c[0x1e]+c[0x1f]+c[0x20]+c[0x21]+c[0x22]+c[0x23])-c[0x24])-c[0x25])-c[0x26])-c[0x27])-c[0x28])+c[0x29])

s.add(enc[2]==(((((((((((((((((((((((((((((c[0]-c[1])+c[2]+c[3])-c[4])+c[5])-c[6])-c[7])+c[8])-c[9])-c[10])-c[0xb])-c[0xc])-c[0xd])+c[0xe])-c[0xf])-c[0x10])+c[0x11]+c[0x12]+c[0x13]+c[0x14]+c[0x15])-c[0x16])+c[0x17]+c[0x18]+c[0x19]+c[0x1a])-c[0x1b])+c[0x1c])-c[0x1d])+c[0x1e])-c[0x1f])+c[0x20]+c[0x21])-c[0x22])-c[0x23])+c[0x24]+c[0x25]+c[0x26])-c[0x27])+c[0x28])-c[0x29])

s.add(enc[3]==(((((((((((((((((((((((((((((((c[0]-c[1])-c[2])-c[3])-c[4])-c[5])+c[6]+c[7])-c[8])-c[9])-c[10])-c[0xb])+c[0xc])-c[0xd])+c[0xe])-c[0xf])+c[0x10])-c[0x11])+c[0x12]+c[0x13]+c[0x14])-c[0x15])+c[0x16]+c[0x17]+c[0x18])-c[0x19])-c[0x1a])+c[0x1b])-c[0x1c])+c[0x1d]+c[0x1e])-c[0x1f])-c[0x20])-c[0x21])+c[0x22])-c[0x23])+c[0x24]+c[0x25]+c[0x26])-c[0x27])+c[0x28]+c[0x29])

s.add(enc[4]==(((((((((((((((((((((((((((((((((c[0]-c[1])-c[2])+c[3])-c[4])-c[5])+c[6]+c[7]+c[8]+c[9])-c[10])+c[0xb]+c[0xc])-c[0xd])+c[0xe])-c[0xf])+c[0x10]+c[0x11])-c[0x12])+c[0x13])-c[0x14])+c[0x15])-c[0x16])-c[0x17])-c[0x18])+c[0x19])-c[0x1a])-c[0x1b])-c[0x1c])+c[0x1d]+c[0x1e]+c[0x1f])-c[0x20])+c[0x21])-c[0x22])-c[0x23])+c[0x24])-c[0x25])+c[0x26])-c[0x27])-c[0x28])-c[0x29])

s.add(enc[5]==((((((((((((((((((((((((((((c[0]+c[1]+c[2]+c[3]+c[4]+c[5]+c[6]+c[7]+c[8])-c[9])-c[10])-c[0xb])-c[0xc])-c[0xd])-c[0xe])+c[0xf])-c[0x10])+c[0x11])-c[0x12])+c[0x13]+c[0x14])-c[0x15])+c[0x16])-c[0x17])+c[0x18])-c[0x19])+c[0x1a]+c[0x1b])-c[0x1c])+c[0x1d])-c[0x1e])+c[0x1f]+c[0x20]+c[0x21])-c[0x22])-c[0x23])-c[0x24])+c[0x25])-c[0x26])-c[0x27])+c[0x28]+c[0x29])

s.add(enc[6]==(((((((((((((((((((((((((((c[0]-c[1])+c[2]+c[3]+c[4])-c[5])+c[6]+c[7]+c[8]+c[9])-c[10])+c[0xb]+c[0xc])-c[0xd])+c[0xe]+c[0xf]+c[0x10]+c[0x11])-c[0x12])-c[0x13])-c[0x14])-c[0x15])-c[0x16])-c[0x17])+c[0x18]+c[0x19])-c[0x1a])+c[0x1b]+c[0x1c]+c[0x1d])-c[0x1e])-c[0x1f])-c[0x20])-c[0x21])-c[0x22])-c[0x23])+c[0x24]+c[0x25])-c[0x26])-c[0x27])+c[0x28])-c[0x29])

s.add(enc[7]==((((((((((((((((((((((((((((((c[0]+c[1])-c[2])-c[3])-c[4])+c[5]+c[6])-c[7])+c[8]+c[9])-c[10])+c[0xb])-c[0xc])+c[0xd])-c[0xe])+c[0xf])-c[0x10])+c[0x11])-c[0x12])-c[0x13])+c[0x14])-c[0x15])+c[0x16])-c[0x17])-c[0x18])+c[0x19])-c[0x1a])+c[0x1b]+c[0x1c]+c[0x1d]+c[0x1e]+c[0x1f]+c[0x20])-c[0x21])+c[0x22])-c[0x23])+c[0x24]+c[0x25]+c[0x26]+c[0x27])-c[0x28])-c[0x29])

s.add(enc[8]==(((((((((((((((((((((((((((((c[0]-c[1])-c[2])+c[3]+c[4])-c[5])+c[6]+c[7]+c[8]+c[9]+c[10])-c[0xb])-c[0xc])+c[0xd])-c[0xe])+c[0xf]+c[0x10]+c[0x11]+c[0x12])-c[0x13])+c[0x14]+c[0x15])-c[0x16])-c[0x17])+c[0x18]+c[0x19]+c[0x1a])-c[0x1b])+c[0x1c])-c[0x1d])-c[0x1e])-c[0x1f])-c[0x20])-c[0x21])+c[0x22])-c[0x23])-c[0x24])+c[0x25])-c[0x26])-c[0x27])+c[0x28])-c[0x29])

s.add(enc[9]==(((((((((((((((((((((((((((((c[0]+c[1]+c[2])-c[3])+c[4]+c[5]+c[6])-c[7])-c[8])-c[9])-c[10])+c[0xb]+c[0xc]+c[0xd])-c[0xe])+c[0xf]+c[0x10])-c[0x11])-c[0x12])+c[0x13]+c[0x14])-c[0x15])-c[0x16])-c[0x17])+c[0x18])-c[0x19])-c[0x1a])-c[0x1b])+c[0x1c]+c[0x1d]+c[0x1e])-c[0x1f])+c[0x20]+c[0x21])-c[0x22])-c[0x23])-c[0x24])-c[0x25])+c[0x26])-c[0x27])+c[0x28]+c[0x29])

s.add(enc[10]==((((((((((((((((((((((((((((((((c[0]-c[1])+c[2]+c[3])-c[4])-c[5])+c[6]+c[7])-c[8])-c[9])-c[10])-c[0xb])+c[0xc]+c[0xd]+c[0xe])-c[0xf])+c[0x10])-c[0x11])+c[0x12]+c[0x13]+c[0x14])-c[0x15])+c[0x16])-c[0x17])-c[0x18])-c[0x19])+c[0x1a])-c[0x1b])-c[0x1c])+c[0x1d])-c[0x1e])+c[0x1f]+c[0x20])-c[0x21])-c[0x22])+c[0x23])-c[0x24])-c[0x25])+c[0x26])-c[0x27])+c[0x28]+c[0x29])

s.add(enc[0xb]==((((((((((((((((((((((((((((((c[0]-c[1])+c[2]+c[3]+c[4])-c[5])+c[6]+c[7])-c[8])+c[9]+c[10])-c[0xb])-c[0xc])-c[0xd])-c[0xe])+c[0xf])-c[0x10])-c[0x11])-c[0x12])+c[0x13]+c[0x14])-c[0x15])+c[0x16])-c[0x17])+c[0x18]+c[0x19]+c[0x1a]+c[0x1b])-c[0x1c])+c[0x1d]+c[0x1e])-c[0x1f])-c[0x20])-c[0x21])-c[0x22])-c[0x23])+c[0x24]+c[0x25])-c[0x26])-c[0x27])-c[0x28])-c[0x29])

s.add(enc[0xc]==(((((((((((((((((((((((((((((((((((((c[0]-c[1])-c[2])-c[3])+c[4])-c[5])-c[6])+c[7]+c[8])-c[9])+c[10])-c[0xb])-c[0xc])-c[0xd])+c[0xe])-c[0xf])+c[0x10])-c[0x11])+c[0x12])-c[0x13])-c[0x14])-c[0x15])-c[0x16])+c[0x17])-c[0x18])+c[0x19])-c[0x1a])+c[0x1b])-c[0x1c])+c[0x1d])-c[0x1e])-c[0x1f])+c[0x20]+c[0x21]+c[0x22])-c[0x23])-c[0x24])-c[0x25])-c[0x26])+c[0x27])-c[0x28])-c[0x29])

s.add(enc[0xd]==(((((((((((((((((((((((((((((((((c[0]-c[1])+c[2])-c[3])+c[4])-c[5])+c[6])-c[7])+c[8])-c[9])+c[10])-c[0xb])+c[0xc]+c[0xd]+c[0xe]+c[0xf])-c[0x10])-c[0x11])-c[0x12])+c[0x13]+c[0x14]+c[0x15])-c[0x16])-c[0x17])+c[0x18]+c[0x19])-c[0x1a])-c[0x1b])+c[0x1c]+c[0x1d])-c[0x1e])-c[0x1f])-c[0x20])+c[0x21])-c[0x22])-c[0x23])+c[0x24])-c[0x25])-c[0x26])-c[0x27])+c[0x28])-c[0x29])

s.add(enc[0xe]==(((((((((((((((((((((((((c[0]+c[1]+c[2])-c[3])-c[4])-c[5])+c[6])-c[7])+c[8]+c[9]+c[10])-c[0xb])+c[0xc])-c[0xd])-c[0xe])+c[0xf]+c[0x10]+c[0x11])-c[0x12])-c[0x13])-c[0x14])-c[0x15])+c[0x16]+c[0x17]+c[0x18])-c[0x19])+c[0x1a]+c[0x1b]+c[0x1c])-c[0x1d])-c[0x1e])-c[0x1f])+c[0x20]+c[0x21]+c[0x22]+c[0x23]+c[0x24]+c[0x25]+c[0x26])-c[0x27])-c[0x28])-c[0x29])

s.add(enc[0xf]==((((((((((((((((((((((((((c[0]-c[1])+c[2]+c[3]+c[4]+c[5])-c[6])+c[7])-c[8])-c[9])-c[10])+c[0xb]+c[0xc]+c[0xd])-c[0xe])-c[0xf])-c[0x10])+c[0x11])-c[0x12])-c[0x13])-c[0x14])-c[0x15])+c[0x16]+c[0x17]+c[0x18]+c[0x19]+c[0x1a]+c[0x1b])-c[0x1c])-c[0x1d])-c[0x1e])-c[0x1f])+c[0x20])-c[0x21])+c[0x22]+c[0x23]+c[0x24]+c[0x25])-c[0x26])+c[0x27]+c[0x28])-c[0x29])

s.add(enc[0x10]==((((((((((((((((((((((((((((((c[0]-c[1])+c[2]+c[3])-c[4])-c[5])+c[6]+c[7]+c[8]+c[9]+c[10])-c[0xb])+c[0xc])-c[0xd])+c[0xe]+c[0xf]+c[0x10])-c[0x11])+c[0x12])-c[0x13])+c[0x14])-c[0x15])-c[0x16])-c[0x17])-c[0x18])-c[0x19])+c[0x1a]+c[0x1b]+c[0x1c]+c[0x1d])-c[0x1e])-c[0x1f])+c[0x20])-c[0x21])-c[0x22])+c[0x23])-c[0x24])+c[0x25])-c[0x26])+c[0x27])-c[0x28])+c[0x29])

s.add(enc[0x11]==((((((((((((((((((((((((((((((((c[0]+c[1]+c[2]+c[3]+c[4])-c[5])+c[6]+c[7]+c[8])-c[9])-c[10])+c[0xb])-c[0xc])+c[0xd]+c[0xe]+c[0xf])-c[0x10])+c[0x11])-c[0x12])-c[0x13])+c[0x14])-c[0x15])+c[0x16])-c[0x17])-c[0x18])+c[0x19])-c[0x1a])+c[0x1b])-c[0x1c])+c[0x1d])-c[0x1e])-c[0x1f])+c[0x20])-c[0x21])-c[0x22])+c[0x23])-c[0x24])+c[0x25])-c[0x26])+c[0x27]+c[0x28])-c[0x29])

s.add(enc[0x12]==((((((((((((((((((((((((((((((((((c[0]-c[1])-c[2])-c[3])+c[4]+c[5])-c[6])+c[7])-c[8])+c[9]+c[10])-c[0xb])-c[0xc])-c[0xd])+c[0xe])-c[0xf])-c[0x10])+c[0x11]+c[0x12]+c[0x13])-c[0x14])-c[0x15])-c[0x16])-c[0x17])-c[0x18])-c[0x19])-c[0x1a])-c[0x1b])+c[0x1c]+c[0x1d]+c[0x1e])-c[0x1f])-c[0x20])-c[0x21])+c[0x22])-c[0x23])-c[0x24])-c[0x25])-c[0x26])-c[0x27])-c[0x28])+c[0x29])

s.add(enc[0x13]==((((((((((((((((((((((((((c[0]+c[1]+c[2]+c[3])-c[4])-c[5])+c[6])-c[7])-c[8])-c[9])-c[10])-c[0xb])-c[0xc])-c[0xd])+c[0xe]+c[0xf]+c[0x10])-c[0x11])+c[0x12]+c[0x13]+c[0x14]+c[0x15])-c[0x16])+c[0x17]+c[0x18])-c[0x19])+c[0x1a]+c[0x1b])-c[0x1c])+c[0x1d]+c[0x1e]+c[0x1f]+c[0x20]+c[0x21])-c[0x22])+c[0x23])-c[0x24])-c[0x25])-c[0x26])+c[0x27]+c[0x28])-c[0x29])

s.add(enc[0x14]==((((((((((((((((((((((((((((((((((((c[0]+c[1])-c[2])-c[3])-c[4])+c[5])-c[6])+c[7])-c[8])-c[9])+c[10]+c[0xb])-c[0xc])-c[0xd])+c[0xe])-c[0xf])-c[0x10])+c[0x11])-c[0x12])-c[0x13])+c[0x14]+c[0x15])-c[0x16])+c[0x17]+c[0x18])-c[0x19])-c[0x1a])-c[0x1b])-c[0x1c])-c[0x1d])-c[0x1e])-c[0x1f])-c[0x20])+c[0x21])-c[0x22])+c[0x23]+c[0x24])-c[0x25])+c[0x26])-c[0x27])+c[0x28])-c[0x29])

s.add(enc[0x15]==(((((((((((((((((((((((((((((((((((c[0]-c[1])-c[2])-c[3])+c[4]+c[5]+c[6]+c[7])-c[8])-c[9])-c[10])-c[0xb])-c[0xc])-c[0xd])-c[0xe])-c[0xf])-c[0x10])+c[0x11])-c[0x12])-c[0x13])+c[0x14])-c[0x15])+c[0x16]+c[0x17]+c[0x18])-c[0x19])-c[0x1a])+c[0x1b])-c[0x1c])-c[0x1d])-c[0x1e])-c[0x1f])-c[0x20])-c[0x21])-c[0x22])-c[0x23])-c[0x24])+c[0x25])-c[0x26])-c[0x27])-c[0x28])+c[0x29])

s.add(enc[0x16]==(((((((((((((((((((((((((((c[0]+c[1]+c[2]+c[3]+c[4]+c[5]+c[6]+c[7])-c[8])+c[9])-c[10])+c[0xb])-c[0xc])+c[0xd]+c[0xe]+c[0xf])-c[0x10])+c[0x11]+c[0x12])-c[0x13])-c[0x14])+c[0x15]+c[0x16])-c[0x17])+c[0x18])-c[0x19])-c[0x1a])+c[0x1b])-c[0x1c])+c[0x1d]+c[0x1e]+c[0x1f])-c[0x20])+c[0x21])-c[0x22])-c[0x23])-c[0x24])-c[0x25])+c[0x26])-c[0x27])+c[0x28]+c[0x29])

s.add(enc[0x17]==(((((((((((((((((((((((((((((((((((c[0]-c[1])+c[2]+c[3])-c[4])-c[5])-c[6])-c[7])+c[8])-c[9])-c[10])+c[0xb]+c[0xc])-c[0xd])-c[0xe])+c[0xf])-c[0x10])-c[0x11])+c[0x12]+c[0x13])-c[0x14])-c[0x15])+c[0x16])-c[0x17])+c[0x18]+c[0x19])-c[0x1a])+c[0x1b])-c[0x1c])+c[0x1d]+c[0x1e])-c[0x1f])-c[0x20])-c[0x21])-c[0x22])-c[0x23])-c[0x24])-c[0x25])+c[0x26])-c[0x27])-c[0x28])-c[0x29])

s.add(enc[0x18]==(((((((((((((((((((((((((c[0]+c[1])-c[2])+c[3]+c[4])-c[5])+c[6]+c[7])-c[8])+c[9]+c[10])-c[0xb])-c[0xc])-c[0xd])-c[0xe])+c[0xf]+c[0x10]+c[0x11])-c[0x12])+c[0x13]+c[0x14]+c[0x15]+c[0x16]+c[0x17]+c[0x18]+c[0x19])-c[0x1a])-c[0x1b])-c[0x1c])+c[0x1d]+c[0x1e])-c[0x1f])+c[0x20]+c[0x21]+c[0x22])-c[0x23])-c[0x24])-c[0x25])-c[0x26])+c[0x27]+c[0x28])-c[0x29])

s.add(enc[0x19]==((((((((((((((((((((((((((((((((c[0]-c[1])+c[2]+c[3])-c[4])+c[5]+c[6])-c[7])+c[8]+c[9]+c[10])-c[0xb])-c[0xc])+c[0xd])-c[0xe])+c[0xf])-c[0x10])+c[0x11]+c[0x12]+c[0x13])-c[0x14])-c[0x15])+c[0x16]+c[0x17])-c[0x18])-c[0x19])+c[0x1a])-c[0x1b])+c[0x1c])-c[0x1d])+c[0x1e])-c[0x1f])-c[0x20])+c[0x21])-c[0x22])-c[0x23])-c[0x24])-c[0x25])+c[0x26])-c[0x27])+c[0x28]+c[0x29])

s.add(enc[0x1a]==(((((((((((((((((((((((((((((c[0]+c[1]+c[2]+c[3]+c[4])-c[5])-c[6])+c[7])-c[8])-c[9])-c[10])-c[0xb])+c[0xc])-c[0xd])+c[0xe])-c[0xf])+c[0x10])-c[0x11])+c[0x12])-c[0x13])-c[0x14])+c[0x15]+c[0x16]+c[0x17]+c[0x18]+c[0x19])-c[0x1a])-c[0x1b])-c[0x1c])-c[0x1d])+c[0x1e]+c[0x1f])-c[0x20])-c[0x21])-c[0x22])+c[0x23]+c[0x24])-c[0x25])-c[0x26])+c[0x27]+c[0x28]+c[0x29])

s.add(enc[0x1b]==(((((((((((((((((((((((((((((((c[0]-c[1])+c[2])-c[3])+c[4])-c[5])-c[6])-c[7])-c[8])-c[9])-c[10])-c[0xb])+c[0xc]+c[0xd])-c[0xe])+c[0xf]+c[0x10]+c[0x11]+c[0x12]+c[0x13])-c[0x14])-c[0x15])-c[0x16])-c[0x17])+c[0x18]+c[0x19]+c[0x1a])-c[0x1b])+c[0x1c]+c[0x1d]+c[0x1e])-c[0x1f])-c[0x20])-c[0x21])-c[0x22])+c[0x23])-c[0x24])-c[0x25])-c[0x26])-c[0x27])-c[0x28])-c[0x29])

s.add(enc[0x1c]==((((((((((((((((((((((((((((((c[0]-c[1])+c[2]+c[3]+c[4])-c[5])+c[6]+c[7])-c[8])-c[9])+c[10]+c[0xb])-c[0xc])+c[0xd])-c[0xe])+c[0xf])-c[0x10])+c[0x11]+c[0x12]+c[0x13])-c[0x14])-c[0x15])+c[0x16])-c[0x17])-c[0x18])-c[0x19])-c[0x1a])+c[0x1b])-c[0x1c])-c[0x1d])-c[0x1e])+c[0x1f])-c[0x20])-c[0x21])+c[0x22]+c[0x23]+c[0x24])-c[0x25])-c[0x26])+c[0x27]+c[0x28]+c[0x29])

s.add(enc[0x1d]==((((((((((((((((((((((((((c[0]+c[1])-c[2])-c[3])-c[4])+c[5]+c[6]+c[7])-c[8])+c[9])-c[10])-c[0xb])+c[0xc])-c[0xd])+c[0xe]+c[0xf])-c[0x10])+c[0x11]+c[0x12])-c[0x13])+c[0x14]+c[0x15]+c[0x16]+c[0x17])-c[0x18])+c[0x19]+c[0x1a])-c[0x1b])+c[0x1c]+c[0x1d]+c[0x1e]+c[0x1f]+c[0x20])-c[0x21])-c[0x22])+c[0x23]+c[0x24])-c[0x25])+c[0x26]+c[0x27])-c[0x28])+c[0x29])

s.add(enc[0x1e]==((((((((((((((((((((((((((((((((c[0]+c[1]+c[2]+c[3])-c[4])-c[5])-c[6])-c[7])+c[8]+c[9])-c[10])-c[0xb])-c[0xc])+c[0xd])-c[0xe])-c[0xf])+c[0x10])-c[0x11])-c[0x12])-c[0x13])+c[0x14])-c[0x15])-c[0x16])+c[0x17]+c[0x18])-c[0x19])-c[0x1a])+c[0x1b])-c[0x1c])-c[0x1d])-c[0x1e])-c[0x1f])-c[0x20])-c[0x21])-c[0x22])+c[0x23]+c[0x24]+c[0x25])-c[0x26])+c[0x27]+c[0x28]+c[0x29])

s.add(enc[0x1f]==((((((((((((((((((((((((((((((c[0]+c[1])-c[2])+c[3]+c[4])-c[5])-c[6])+c[7]+c[8]+c[9]+c[10]+c[0xb]+c[0xc])-c[0xd])-c[0xe])-c[0xf])+c[0x10]+c[0x11]+c[0x12]+c[0x13])-c[0x14])+c[0x15])-c[0x16])+c[0x17])-c[0x18])-c[0x19])+c[0x1a]+c[0x1b])-c[0x1c])+c[0x1d])-c[0x1e])-c[0x1f])-c[0x20])+c[0x21])-c[0x22])+c[0x23])-c[0x24])+c[0x25])-c[0x26])+c[0x27])-c[0x28])-c[0x29])

s.add(enc[0x20]==(((((((((((((((((((((((((((c[0]-c[1])+c[2]+c[3])-c[4])+c[5]+c[6]+c[7]+c[8])-c[9])+c[10]+c[0xb])-c[0xc])+c[0xd]+c[0xe])-c[0xf])+c[0x10])-c[0x11])+c[0x12]+c[0x13]+c[0x14])-c[0x15])-c[0x16])+c[0x17])-c[0x18])+c[0x19]+c[0x1a]+c[0x1b])-c[0x1c])-c[0x1d])-c[0x1e])-c[0x1f])-c[0x20])-c[0x21])+c[0x22]+c[0x23]+c[0x24]+c[0x25])-c[0x26])+c[0x27])-c[0x28])+c[0x29])

s.add(enc[0x21]==(((((((((((((((((((((((((((((((c[0]-c[1])-c[2])+c[3]+c[4]+c[5]+c[6])-c[7])-c[8])+c[9]+c[10]+c[0xb])-c[0xc])-c[0xd])+c[0xe]+c[0xf])-c[0x10])+c[0x11])-c[0x12])+c[0x13])-c[0x14])+c[0x15]+c[0x16]+c[0x17])-c[0x18])-c[0x19])+c[0x1a]+c[0x1b])-c[0x1c])+c[0x1d])-c[0x1e])-c[0x1f])-c[0x20])-c[0x21])-c[0x22])-c[0x23])+c[0x24])-c[0x25])+c[0x26])-c[0x27])-c[0x28])-c[0x29])

s.add(enc[0x22]==((((((((((((((((((((((((((((((c[0]+c[1])-c[2])+c[3])-c[4])-c[5])-c[6])+c[7]+c[8]+c[9]+c[10]+c[0xb])-c[0xc])-c[0xd])-c[0xe])+c[0xf])-c[0x10])+c[0x11])-c[0x12])+c[0x13])-c[0x14])-c[0x15])+c[0x16]+c[0x17])-c[0x18])-c[0x19])+c[0x1a]+c[0x1b]+c[0x1c]+c[0x1d])-c[0x1e])-c[0x1f])-c[0x20])-c[0x21])-c[0x22])-c[0x23])-c[0x24])+c[0x25]+c[0x26]+c[0x27])-c[0x28])-c[0x29])

s.add(enc[0x23]==((((((((((((((((((((((((((c[0]-c[1])+c[2]+c[3]+c[4])-c[5])-c[6])+c[7]+c[8])-c[9])-c[10])+c[0xb]+c[0xc]+c[0xd])-c[0xe])-c[0xf])+c[0x10])-c[0x11])+c[0x12]+c[0x13])-c[0x14])-c[0x15])-c[0x16])+c[0x17]+c[0x18])-c[0x19])-c[0x1a])+c[0x1b]+c[0x1c])-c[0x1d])-c[0x1e])+c[0x1f]+c[0x20])-c[0x21])+c[0x22]+c[0x23]+c[0x24]+c[0x25]+c[0x26]+c[0x27])-c[0x28])-c[0x29])

s.add(enc[0x24]==(((((((((((((((((((((((((c[0]+c[1]+c[2])-c[3])-c[4])-c[5])-c[6])+c[7]+c[8]+c[9])-c[10])+c[0xb]+c[0xc])-c[0xd])+c[0xe]+c[0xf]+c[0x10]+c[0x11]+c[0x12]+c[0x13]+c[0x14]+c[0x15])-c[0x16])-c[0x17])+c[0x18])-c[0x19])-c[0x1a])-c[0x1b])-c[0x1c])+c[0x1d]+c[0x1e]+c[0x1f]+c[0x20])-c[0x21])-c[0x22])-c[0x23])-c[0x24])+c[0x25])-c[0x26])+c[0x27]+c[0x28])-c[0x29])

s.add(enc[0x25]==((((((((((((((((((((((((((((((((((((((c[0]-c[1])-c[2])+c[3])-c[4])+c[5])-c[6])-c[7])-c[8])-c[9])+c[10])-c[0xb])-c[0xc])-c[0xd])-c[0xe])-c[0xf])-c[0x10])+c[0x11]+c[0x12])-c[0x13])-c[0x14])-c[0x15])+c[0x16])-c[0x17])+c[0x18])-c[0x19])-c[0x1a])+c[0x1b])-c[0x1c])-c[0x1d])+c[0x1e]+c[0x1f])-c[0x20])+c[0x21])-c[0x22])+c[0x23])-c[0x24])-c[0x25])+c[0x26])-c[0x27])-c[0x28])-c[0x29])

s.add(enc[0x26]==((((((((((((((((((((((((((c[0]+c[1]+c[2]+c[3])-c[4])+c[5]+c[6]+c[7])-c[8])-c[9])-c[10])+c[0xb]+c[0xc]+c[0xd])-c[0xe])-c[0xf])-c[0x10])-c[0x11])-c[0x12])-c[0x13])+c[0x14]+c[0x15])-c[0x16])+c[0x17]+c[0x18]+c[0x19]+c[0x1a]+c[0x1b])-c[0x1c])-c[0x1d])+c[0x1e]+c[0x1f])-c[0x20])-c[0x21])+c[0x22])-c[0x23])-c[0x24])-c[0x25])+c[0x26]+c[0x27]+c[0x28])-c[0x29])

s.add(enc[0x27]==(((((((((((((((((((((((((c[0]-c[1])-c[2])-c[3])-c[4])+c[5])-c[6])-c[7])-c[8])+c[9])-c[10])+c[0xb])-c[0xc])+c[0xd]+c[0xe])-c[0xf])-c[0x10])-c[0x11])+c[0x12]+c[0x13]+c[0x14]+c[0x15]+c[0x16])-c[0x17])+c[0x18]+c[0x19]+c[0x1a]+c[0x1b]+c[0x1c])-c[0x1d])+c[0x1e]+c[0x1f]+c[0x20]+c[0x21]+c[0x22])-c[0x23])-c[0x24])+c[0x25]+c[0x26]+c[0x27])-c[0x28])+c[0x29])

s.add(enc[0x28]==((((((((((((((((((((((c[0]-c[1])-c[2])-c[3])+c[4]+c[5]+c[6])-c[7])+c[8]+c[9])-c[10])+c[0xb])-c[0xc])-c[0xd])-c[0xe])+c[0xf]+c[0x10]+c[0x11]+c[0x12]+c[0x13]+c[0x14]+c[0x15]+c[0x16])-c[0x17])+c[0x18]+c[0x19])-c[0x1a])+c[0x1b]+c[0x1c])-c[0x1d])+c[0x1e]+c[0x1f]+c[0x20])-c[0x21])-c[0x22])+c[0x23]+c[0x24])-c[0x25])+c[0x26]+c[0x27]+c[0x28]+c[0x29])

s.add(enc[0x29]==(((((((((((((((((((((((((((((((c[0]+c[1]+c[2]+c[3]+c[4]+c[5]+c[6])-c[7])-c[8])-c[9])+c[10]+c[0xb])-c[0xc])+c[0xd])-c[0xe])-c[0xf])-c[0x10])-c[0x11])-c[0x12])-c[0x13])+c[0x14])-c[0x15])+c[0x16])-c[0x17])-c[0x18])+c[0x19]+c[0x1a]+c[0x1b]+c[0x1c])-c[0x1d])-c[0x1e])-c[0x1f])-c[0x20])-c[0x21])-c[0x22])-c[0x23])-c[0x24])-c[0x25])-c[0x26])-c[0x27])-c[0x28])+c[0x29])

if s.check() == sat :
    r = s.model()
    for i in range(42) :
        flag.append(r[c[i]].as_long()^i)

    flag = &#39;&#39;.join(map(lambda x : chr(((x &amp;gt;&amp;gt; 3) | (x &amp;lt;&amp;lt; 5)) &amp;amp; 0xff),flag))
    print(flag)

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;SUCTF{Un1c0rn_Engin3_Is@P0wer7ul_TO0ls!}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">SUCTF2019 babyunic</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/yang-cheng-bei-2023-quals-reverse-writeup/"" data-c="
          &lt;ul&gt;
&lt;li&gt;文件夹里突然发现的一篇远古复现wp，发出来&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-csgo&#34;&gt;一. CSGO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;go1.18写的exe，找到main函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void __golang main_main()
{
  __int64 v0; // r14
  _QWORD *v1; // rax
  __int64 i; // rax
  __int64 v3; // rdi
  main__Ctype_char *v4; // rax
  void (**v5)(void); // rax
  __int64 v6; // rbx
  main__Ctype_char *v7; // rax
  char v8; // al
  io_Writer_0 p0; // [rsp+0h] [rbp-C8h]
  runtime__type_0 *p0b; // [rsp+0h] [rbp-C8h]
  io_Writer_0 p0c; // [rsp+0h] [rbp-C8h]
  io_Reader_0 p0d; // [rsp+0h] [rbp-C8h]
  _BYTE p0a[40]; // [rsp+0h] [rbp-C8h] OVERLAPPED
  main__Ctype_char *p0e; // [rsp+0h] [rbp-C8h]
  string p0f; // [rsp+0h] [rbp-C8h]
  uint8 *p0g; // [rsp+0h] [rbp-C8h]
  _slice_interface_ v17; // [rsp+10h] [rbp-B8h]
  _slice_interface_ v18; // [rsp+10h] [rbp-B8h]
  string v19; // [rsp+10h] [rbp-B8h]
  _slice_interface_ v20; // [rsp+20h] [rbp-A8h]
  main__Ctype_char *p1; // [rsp+50h] [rbp-78h]
  _QWORD *v22; // [rsp+60h] [rbp-68h]
  __int128 v23; // [rsp+78h] [rbp-50h] BYREF
  const char *v24; // [rsp+88h] [rbp-40h]
  _QWORD *v25; // [rsp+90h] [rbp-38h]
  void *v26; // [rsp+98h] [rbp-30h]
  char **v27; // [rsp+A0h] [rbp-28h]
  void *v28; // [rsp+A8h] [rbp-20h]
  char **v29; // [rsp+B0h] [rbp-18h]
  void (**v30)(void); // [rsp+B8h] [rbp-10h]

  if ( (unsigned __int64)&amp;amp;v23 + 8 &amp;lt;= *(_QWORD *)(v0 + 16) )
    runtime_morestack_noctxt_abi0();
  v30 = 0LL;
  v28 = &amp;amp;unk_17E120;
  v29 = &amp;amp;main__stmp_0;
  fmt_Fprintln(p0, v17);
  p0c.data = runtime_newobject(p0b);
  v22 = v1;
  *v1 = 0LL;
  v26 = &amp;amp;unk_17E120;
  v27 = &amp;amp;main__stmp_1;
  *(_OWORD *)&amp;amp;v20.len = (unsigned __int128)fmt_Fprint(p0c, v18);
  v24 = &amp;quot;\b&amp;quot;;
  v25 = v22;
  fmt_Fscanf(p0d, v19, v20);
  for ( i = 0LL; i &amp;lt; 64; i = v3 + 1 )
  {
    v3 = i;
    if ( (unsigned __int64)(i - ((i + 11) &amp;gt;&amp;gt; 6 &amp;lt;&amp;lt; 6) + 11) &amp;gt;= 0x40 )
      runtime_panicIndex();
    *(string *)&amp;amp;p0a[16] = runtime_intstring(*(uint8 (**)[4])p0a, *(int64 *)&amp;amp;p0a[8]);
    runtime_concatstring2(*(runtime_tmpBuf **)p0a, *(string *)&amp;amp;p0a[8], *(string *)&amp;amp;p0a[24]);
  }
  main__Cfunc_CString(*(string *)p0a);
  p1 = v4;
  p0f.len = (__int64)main_main_func1(p0e);
  v30 = v5;
  v6 = v22[1];
  main__Cfunc_CString(p0f);
  main__Cfunc_enc_abi0(v7, p1);
  *(string *)&amp;amp;p0a[8] = runtime_gostring(p0g);
  if ( v6 == 60 &amp;amp;&amp;amp; (runtime_memequal(), v8) )
  {
    fmt_Fprintln(*(io_Writer_0 *)p0a, *(_slice_interface_ *)&amp;amp;p0a[16]);
  }
  else
  {
    *((_QWORD *)&amp;amp;v23 + 1) = &amp;amp;main__stmp_2;
    fmt_Fprintln(*(io_Writer_0 *)p0a, *(_slice_interface_ *)&amp;amp;p0a[16]);
  }
  (*v30)();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析逻辑：输入字符串，base64换表加密，比较&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动调得到表：LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解密得到：&lt;em&gt;&lt;strong&gt;DASCTF{73913519-A0A6-5575-0F10-DDCBF50FA8CA}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-blast&#34;&gt;二. Blast&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;控制流混淆，写脚本去除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from idc import *
def patch(start, end):
	i = start
	while i &amp;lt; end:
		if print_insn_mnem(i) == &#39;jnz&#39; and print_insn_mnem(i + 6) == &#39;jmp&#39; and print_operand(i + 0xb, 0) == &#39;$+5&#39; and print_insn_mnem(i + 0xb) == &#39;jmp&#39;:
			print(hex(i))
			for j in range(i, i + 0x10):
				patch_byte(j, 0x90)
				i += 0xf
		i += 1
for seg in Segments():
	if get_segm_name(seg) == &#39;.text&#39;:
		patch(seg, 0x40B7E4)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用findcrypt插件或动调识别出其实就是两次md5加密，最后比较&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接爆破&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from hashlib import *

result = [
    &#39;14d89c38cd0fb23a14be2798d449c182&#39;,
    &#39;a94837b18f8f43f29448b40a6e7386ba&#39;,
    &#39;af85d512594fc84a5c65ec9970956ea5&#39;,
    &#39;af85d512594fc84a5c65ec9970956ea5&#39;,
    &#39;10e21da237a4a1491e769df6f4c3b419&#39;,
    &#39;a705e8280082f93f07e3486636f3827a&#39;,
    &#39;297e7ca127d2eef674c119331fe30dff&#39;,
    &#39;b5d2099e49bdb07b8176dff5e23b3c14&#39;,
    &#39;83be264eb452fcf0a1c322f2c7cbf987&#39;,
    &#39;a94837b18f8f43f29448b40a6e7386ba&#39;,
    &#39;71b0438bf46aa26928c7f5a371d619e1&#39;,
    &#39;a705e8280082f93f07e3486636f3827a&#39;,
    &#39;ac49073a7165f41c57eb2c1806a7092e&#39;,
    &#39;a94837b18f8f43f29448b40a6e7386ba&#39;,
    &#39;af85d512594fc84a5c65ec9970956ea5&#39;,
    &#39;ed108f6919ebadc8e809f8b86ef40b05&#39;,
    &#39;10e21da237a4a1491e769df6f4c3b419&#39;,
    &#39;3cfd436919bc3107d68b912ee647f341&#39;,
    &#39;a705e8280082f93f07e3486636f3827a&#39;,
    &#39;65c162f7c43612ba1bdf4d0f2912bbc0&#39;,
    &#39;10e21da237a4a1491e769df6f4c3b419&#39;,
    &#39;a705e8280082f93f07e3486636f3827a&#39;,
    &#39;3cfd436919bc3107d68b912ee647f341&#39;,
    &#39;557460d317ae874c924e9be336a83cbe&#39;,
    &#39;a705e8280082f93f07e3486636f3827a&#39;,
    &#39;9203d8a26e241e63e4b35b3527440998&#39;,
    &#39;10e21da237a4a1491e769df6f4c3b419&#39;,
    &#39;f91b2663febba8a884487f7de5e1d249&#39;,
    &#39;a705e8280082f93f07e3486636f3827a&#39;,
    &#39;d7afde3e7059cd0a0fe09eec4b0008cd&#39;,
    &#39;488c428cd4a8d916deee7c1613c8b2fd&#39;,
    &#39;39abe4bca904bca5a11121955a2996bf&#39;,
    &#39;a705e8280082f93f07e3486636f3827a&#39;,
    &#39;3cfd436919bc3107d68b912ee647f341&#39;,
    &#39;39abe4bca904bca5a11121955a2996bf&#39;,
    &#39;4e44f1ac85cd60e3caa56bfd4afb675e&#39;,
    &#39;45cf8ddfae1d78741d8f1c622689e4af&#39;,
    &#39;3cfd436919bc3107d68b912ee647f341&#39;,
    &#39;39abe4bca904bca5a11121955a2996bf&#39;,
    &#39;4e44f1ac85cd60e3caa56bfd4afb675e&#39;,
    &#39;37327bb06c83cb29cefde1963ea588aa&#39;,
    &#39;a705e8280082f93f07e3486636f3827a&#39;,
    &#39;23e65a679105b85c5dc7034fded4fb5f&#39;,
    &#39;10e21da237a4a1491e769df6f4c3b419&#39;,
    &#39;71b0438bf46aa26928c7f5a371d619e1&#39;,
    &#39;af85d512594fc84a5c65ec9970956ea5&#39;,
    &#39;39abe4bca904bca5a11121955a2996bf&#39;,
]
for i in range(len(result)):
    for j in range(30,128):
        if md5(md5(chr(j).encode()).hexdigest().encode()).hexdigest() == result[i]:
            print(chr(j),end=&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;得到&lt;em&gt;&lt;strong&gt;Hello_Ctfer_Velcom_To_my_Mov_and_md5(md5)_world&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-ez加密器&#34;&gt;三. ez加密器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;根据字符串提示找到如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 sub_1400140E0()
{
  char *v0; // r8
  char *v1; // rcx
  char *v2; // r9
  char v3; // si
  unsigned __int8 v4; // di
  int v5; // eax
  int v6; // edx
  int v7; // edi
  int v8; // eax
  int v9; // edi
  int v10; // ebp
  int v11; // edi
  int v12; // r12d
  int v13; // edi
  char v14; // di
  int v15; // eax
  int v16; // edx
  int v18; // esi
  int v19; // eax
  int v20; // esi
  int v21; // edi
  int v22; // esi
  int v23; // ebp
  int v24; // esi
  char *v25; // [rsp+20h] [rbp-D8h] BYREF
  __int64 v26; // [rsp+28h] [rbp-D0h]
  char v27[8]; // [rsp+38h] [rbp-C0h] BYREF
  char Str2[184]; // [rsp+40h] [rbp-B8h] BYREF

  sub_140003D87();
  sub_140003C30((__int64)a000000, (__int64)a11111111111111);
  sub_1400036A0((__int64)a000000, 6u, (unsigned __int8 *)v27);
  sub_140003AE0((__int64)&amp;amp;v25, (__int64)v27, a11111111111111, 40);
  v0 = v25;
  if ( (int)v26 &amp;lt;= 0 )
  {
    v2 = Str2;
  }
  else
  {
    v1 = Str2;
    v2 = &amp;amp;Str2[2 * (int)v26];
    do
    {
      v3 = *v0;
      v4 = (unsigned __int8)*v0 &amp;gt;&amp;gt; 4;
      v5 = v4;
      if ( v4 &amp;lt;= 9u )
      {
        LOBYTE(v6) = v4 ^ 0x30;
        if ( !v4 )
          LOBYTE(v6) = 48;
      }
      else
      {
        v6 = 65;
        do
        {
          v7 = v6 &amp;amp; v5;
          v6 ^= v5;
          v5 = 2 * v7;
        }
        while ( 2 * v7 );
        v8 = 0xFFFFFFF5;
        v9 = 1;
        do
        {
          v10 = v9;
          v11 = v8 &amp;amp; v9;
          v12 = v8;
          v8 ^= v10;
          v9 = 2 * v11;
        }
        while ( v9 );
        if ( v10 != v12 )
        {
          do
          {
            v13 = v6 &amp;amp; v8;
            v6 ^= v8;
            v8 = 2 * v13;
          }
          while ( 2 * v13 );
        }
      }
      *v1 = v6;
      v1 += 2;
      v14 = v3 &amp;amp; 0xF;
      v15 = v3 &amp;amp; 0xF;
      if ( (v3 &amp;amp; 0xFu) &amp;gt; 9 )
      {
        v16 = 65;
        do
        {
          v18 = v16 &amp;amp; v15;
          v16 ^= v15;
          v15 = 2 * v18;
        }
        while ( 2 * v18 );
        v19 = -11;
        v20 = 1;
        do
        {
          v21 = v20;
          v22 = v19 &amp;amp; v20;
          v23 = v19;
          v19 ^= v21;
          v20 = 2 * v22;
        }
        while ( v20 );
        if ( v21 != v23 )
        {
          do
          {
            v24 = v16;
            v16 ^= v19;
            v19 = 2 * (v19 &amp;amp; v24);
          }
          while ( v19 );
        }
      }
      else
      {
        LOBYTE(v16) = v14 ^ 0x30;
        if ( !v14 )
          LOBYTE(v16) = 48;
      }
      *(v1 - 1) = v16;
      ++v0;
    }
    while ( v1 != v2 );
  }
  *v2 = 0;
  if ( !strcmp(Big_Numbers1_1400150A0, Str2) )
    sub_1400016E0((__int64)&amp;quot;------\nGetFlag!\n------&amp;quot;);
  system(&amp;quot;pause&amp;quot;);
  return 0i64;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall sub_140003C30(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  sub_1400016E0((__int64)&amp;quot;Please enter the verification code: \n&amp;quot;);
  sub_140001730(&amp;amp;unk_140016000, a1);
  if ( !(unsigned __int8)sub_140003A20(a1)
    || (sub_1400016E0((__int64)&amp;quot;Please enter the flag: \n&amp;quot;),
        sub_140001730(&amp;amp;unk_140016000, a2),
        result = sub_140003910(a2),
        !(_BYTE)result) )
  {
    exit(-1);
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入函数，输入6位code以及flag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall sub_1400036A0(__int64 a1, unsigned __int16 a2, unsigned __int8 *a3)
{
  signed int v6; // esi
  unsigned int v7; // edx
  __int64 v8; // rdi
  int v9; // ecx
  _BYTE *v10; // r12
  _BYTE *v11; // rbp
  int v12; // eax
  int v13; // r9d
  int v14; // eax
  unsigned int v15; // r9d
  unsigned __int8 *v16; // rax
  __int64 v17; // rcx
  __int16 v18; // r11
  _BYTE *v19; // r9
  unsigned __int8 *v20; // r11
  _BYTE *v21; // rbx
  int v22; // eax
  int v23; // ecx
  _BYTE *v25; // r11
  unsigned __int8 *v26; // r10
  int v27; // eax
  int v28; // ecx

  v6 = 3 * (a2 / 3u);
  if ( a2 &amp;lt;= 2u )
    goto LABEL_19;
  LOWORD(v7) = 0;
  v8 = 0i64;
  v9 = 0;
  do
  {
    v10 = (_BYTE *)(a1 + v8 + 1);
    a3[(unsigned __int16)v7] = *(_BYTE *)(a1 + v8) &amp;gt;&amp;gt; 2;
    v11 = (_BYTE *)(a1 + v8 + 2);
    a3[(unsigned __int16)v7 + 1] = (*v10 &amp;gt;&amp;gt; 4) | (16 * *(_BYTE *)(a1 + v8)) &amp;amp; 0x30;
    a3[(unsigned __int16)v7 + 2] = (*v11 &amp;gt;&amp;gt; 6) | (4 * *v10) &amp;amp; 0x3C;
    a3[(unsigned __int16)v7 + 3] = *v11 &amp;amp; 0x3F;
    v12 = 3;
    do
    {
      v13 = v9 &amp;amp; v12;
      v9 ^= v12;
      v12 = 2 * v13;
    }
    while ( 2 * v13 );
    v8 = (unsigned __int16)v9;
    v7 = (unsigned __int16)v7;
    v14 = 4;
    do
    {
      v15 = v7;
      v7 ^= v14;
      v14 = 2 * (v14 &amp;amp; v15);
    }
    while ( v14 );
    v9 = (unsigned __int16)v9;
  }
  while ( (unsigned __int16)v9 &amp;lt; v6 );
  if ( (_WORD)v7 )
  {
    v16 = a3;
    do
    {
      v17 = *v16++;
      *(v16 - 1) = off_140015108[v17];
    }
    while ( v16 != &amp;amp;a3[(unsigned __int16)(v7 - 1) + 1] );
  }
  else
  {
LABEL_19:
    v7 = 0;
  }
  v18 = a2 - 3 * (a2 / 3u);
  if ( v18 == 1 )
  {
    v7 = (unsigned __int16)v7;
    v25 = (_BYTE *)(a1 + a2 - 1);
    v26 = &amp;amp;a3[(unsigned __int16)v7];
    *v26 = *v25 &amp;gt;&amp;gt; 2;
    v26[1] = (16 * *v25) &amp;amp; 0x30;
    *v26 = off_140015108[*v26];
    v26[1] = off_140015108[v26[1]];
    v27 = 4;
    v26[2] = 61;
    v26[3] = 61;
    do
    {
      v28 = v7 &amp;amp; v27;
      v7 ^= v27;
      v27 = 2 * v28;
    }
    while ( 2 * v28 );
    return v7;
  }
  else
  {
    if ( v18 == 2 )
    {
      v7 = (unsigned __int16)v7;
      v19 = (_BYTE *)(a1 + a2 - 2);
      v20 = &amp;amp;a3[(unsigned __int16)v7];
      v21 = (_BYTE *)(a1 + a2 - 1);
      *v20 = *v19 &amp;gt;&amp;gt; 2;
      v20[1] = (*v21 &amp;gt;&amp;gt; 4) | (16 * *v19) &amp;amp; 0x30;
      v20[2] = (4 * *v21) &amp;amp; 0x3C;
      *v20 = off_140015108[*v20];
      v20[1] = off_140015108[v20[1]];
      v20[2] = off_140015108[v20[2]];
      v22 = 4;
      v20[3] = 61;
      do
      {
        v23 = v7 &amp;amp; v22;
        v7 ^= v22;
        v22 = 2 * v23;
      }
      while ( 2 * v23 );
    }
    return v7;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BASE64换表加密，对code进行加密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall sub_140003AE0(__int64 a1, __int64 a2, const void *a3, int a4)
{
  size_t v6; // rbx
  unsigned __int8 v8; // r14
  int v9; // ebp
  char *v10; // rdi
  __int64 *v11; // r8
  __int64 v12; // rdx
  char *v13; // rbx
  char *v14; // r8
  char *v15; // rcx
  __int64 result; // rax
  unsigned __int64 v17; // r9
  unsigned int v18; // eax
  unsigned int v19; // ecx
  __int64 v20; // r8
  char v21[184]; // [rsp+20h] [rbp-B8h] BYREF

  v6 = a4;
  sub_1400016E0(&amp;amp;unk_140016003);
  sub_140001A20(a2, v21);
  v8 = ((unsigned int)((int)v6 &amp;gt;&amp;gt; 31) &amp;gt;&amp;gt; 29) - ((v6 + ((unsigned int)((int)v6 &amp;gt;&amp;gt; 31) &amp;gt;&amp;gt; 29)) &amp;amp; 7) + 8;
  v9 = v6 + v8;
  v10 = (char *)malloc(v9);
  memcpy(v10, a3, v6);
  v11 = (__int64 *)&amp;amp;v10[v6];
  v12 = 0x101010101010101i64 * v8;
  if ( v8 &amp;gt;= 8u )
  {
    *v11 = v12;
    v17 = (unsigned __int64)(v11 + 1) &amp;amp; 0xFFFFFFFFFFFFFFF8ui64;
    *(__int64 *)((char *)v11 + v8 - 8) = v12;
    if ( (((_DWORD)v11 - (_DWORD)v17 + v8) &amp;amp; 0xFFFFFFF8) &amp;gt;= 8 )
    {
      v18 = ((_DWORD)v11 - v17 + v8) &amp;amp; 0xFFFFFFF8;
      v19 = 0;
      do
      {
        v20 = v19;
        v19 += 8;
        *(_QWORD *)(v17 + v20) = v12;
      }
      while ( v19 &amp;lt; v18 );
    }
  }
  else if ( (v8 &amp;amp; 4) != 0 )
  {
    *(_DWORD *)v11 = v12;
    *(_DWORD *)((char *)v11 + v8 - 4) = v12;
  }
  else if ( ((unsigned int)((int)v6 &amp;gt;&amp;gt; 31) &amp;gt;&amp;gt; 29) - (((_BYTE)v6 + ((unsigned int)((int)v6 &amp;gt;&amp;gt; 31) &amp;gt;&amp;gt; 29)) &amp;amp; 7) != 0xF8 )
  {
    *(_BYTE *)v11 = v8;
    if ( (v8 &amp;amp; 2) != 0 )
      *(_WORD *)((char *)v11 + v8 - 2) = v12;
  }
  if ( v9 &amp;gt; 0 )
  {
    v13 = v10;
    do
    {
      v14 = v13;
      v15 = v13;
      v13 += 8;
      sub_140002180(v15, v21, v14);
    }
    while ( v13 != &amp;amp;v10[8 * ((unsigned int)(v9 - 1) &amp;gt;&amp;gt; 3) + 8] );
  }
  sub_1400016E0(&amp;amp;unk_140016003);
  result = a1;
  *(_QWORD *)a1 = v10;
  *(_DWORD *)(a1 + 8) = v9;
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DES，用加密后的code进行flag的加密，此时code正好8字节，符合DES加密标准&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;故爆破六位code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from Crypto.Cipher import DES
import base64

c= bytes.fromhex(&amp;quot;0723105D5C12217DCDC3601F5ECB54DA9CCEC2279F1684A13A0D716D17217F4C9EA85FF1A42795731CA3C55D3A4D7BEA&amp;quot;)
tab1 = &#39;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ+/&#39;
tab2 = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;
for i in range(1000000):
    key = base64.b64encode(str(i).rjust(6,&amp;quot;0&amp;quot;).encode()).decode().translate(str.maketrans(tab2,tab1)).encode()
    cipher = DES.new(key, DES.MODE_ECB)
    m= cipher.decrypt(c)
    if b&amp;quot;DASCTF{&amp;quot; in m:
        print(m)
        exit(1)


&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;DASCTF{f771b96b71514bb6bc20f3275fa9404e}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四-vm_wo&#34;&gt;四. vm_wo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;逻辑很简单&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写个反汇编脚本提取指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;opcode= [26, 0, 3, 25, 1, 1, 13, 2, 7, 24, 1, 2, 1, 0, 3, 26, 0, 3, 25,
          1, 2, 13, 2, 6, 24, 1, 2, 1, 0, 4, 26, 0, 3, 25, 1, 3, 13, 2, 5,
          24, 1, 2, 1, 0, 5, 26, 0, 3, 25, 1, 4, 13, 2, 4, 24, 1, 2, 1, 0, 6]

pc=0
while pc&amp;lt;len(opcode):
    print(&#39;0x%04x: &#39;%pc,end=&amp;quot;&amp;quot;)
    if opcode[pc] == 0:
        print(&#39;swap reg%d reg%d&#39;% (opcode[pc+1],opcode[pc+2]))
    elif opcode[pc]==1:
        print(&#39;xor reg%d reg%d&#39;% (opcode[pc+1],opcode[pc+2]))
    elif opcode[pc]==2:
        print(&#39;add reg%d %d&#39;%(opcode[pc+1],pc+2))
    elif opcode[pc]==3:
        print(&#39;add reg%d reg%d&#39;% (opcode[pc+1],opcode[pc+2]))
    elif opcode[pc]==4:
        print(&#39;sub reg%d %d&#39;% (opcode[pc+1],pc+2))
    elif opcode[pc]==5:
        print(&#39;sub reg%d reg%d&#39;% (opcode[pc+1],opcode[pc+2]))
    elif opcode[pc]==6:
        print(&#39;mul reg%d %d&#39;% (opcode[pc+1],pc+2))
    elif opcode[pc]==7:
        print(&#39;mul reg%d reg%d&#39;% (opcode[pc+1],opcode[pc+2]))
    elif opcode[pc]==8:
        print(&#39;div reg%d %d&#39;% (opcode[pc+1],pc+2))
    elif opcode[pc]==9:
        print(&#39;div reg%d reg%d&#39;% (opcode[pc+1],opcode[pc+2]))
    elif opcode[pc]==13:
        print(&#39;mov reg%d reg0&amp;lt;&amp;lt;%d&#39;% (opcode[pc+1],opcode[pc+2]))
    elif opcode[pc] == 24:
        print(&#39;reg0 = reg2 | reg1&#39;)
    elif opcode[pc]==25:
        print(&#39;mov reg%d reg0&amp;gt;&amp;gt;%d&#39;% (opcode[pc+1],opcode[pc+2]))
    elif opcode[pc]==26:
        print(&#39;mov reg%d %d&#39;% (opcode[pc+1],opcode[pc+2]))
    pc+=3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;0x0000: mov reg0 3
0x0003: mov reg1 reg0&amp;gt;&amp;gt;1
0x0006: mov reg2 reg0&amp;lt;&amp;lt;7
0x0009: reg0 = reg2 | reg1
0x000c: xor reg0 reg3
0x000f: mov reg0 3
0x0012: mov reg1 reg0&amp;gt;&amp;gt;2
0x0015: mov reg2 reg0&amp;lt;&amp;lt;6
0x0018: reg0 = reg2 | reg1
0x001b: xor reg0 reg4
0x001e: mov reg0 3
0x0021: mov reg1 reg0&amp;gt;&amp;gt;3
0x0024: mov reg2 reg0&amp;lt;&amp;lt;5
0x0027: reg0 = reg2 | reg1
0x002a: xor reg0 reg5
0x002d: mov reg0 3
0x0030: mov reg1 reg0&amp;gt;&amp;gt;4
0x0033: mov reg2 reg0&amp;lt;&amp;lt;4
0x0036: reg0 = reg2 | reg1
0x0039: xor reg0 reg6

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑比较简单&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接找到reg3到reg6的值逆就完了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;enc = [0xDF, 0xD5, 0xF1, 0xD1, 0xFF, 0xDB, 0xA1, 0xA5, 0x89, 0xBD, 0xE9, 0x95, 0xB3, 0x9D, 0xE9, 0xB3, 0x85, 0x99, 0x87,
       0xBF, 0xE9, 0xB1, 0x89, 0xE9, 0x91, 0x89, 0x89, 0x8F, 0xAD]
key = 0xBEEDBEEF.to_bytes(4, &#39;little&#39;)
def decode(s):
    s = (s &amp;gt;&amp;gt; 3 | s &amp;lt;&amp;lt; 5) &amp;amp; 0xFF
    s = s ^ key[3]
    s = (s &amp;lt;&amp;lt; 4 | s &amp;gt;&amp;gt; 4) &amp;amp; 0xFF
    s = s ^ key[2]
    s = (s &amp;lt;&amp;lt; 3 | s &amp;gt;&amp;gt; 5) &amp;amp; 0xFF
    s = s ^ key[1]
    s = (s &amp;lt;&amp;lt; 2 | s &amp;gt;&amp;gt; 6) &amp;amp; 0xFF
    s = s ^ key[0]
    s = (s &amp;lt;&amp;lt; 1 | s &amp;gt;&amp;gt; 7) &amp;amp; 0xFF
    return s

flag=&#39;&#39;
for i in range(len(enc)):
    flag+=chr(decode(enc[i]))
print(flag)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;DASCTF{you_are_right_so_cool}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">羊城杯2023 Quals Reverse WriteUp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/nssctf-round17-reverse-and-crypto-writeupquan/"" data-c="
          &lt;h2 id=&#34;reverse&#34;&gt;Reverse&lt;/h2&gt;
&lt;h3 id=&#34;一-snake&#34;&gt;一. snake&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;go1.19写的&lt;/strong&gt;，直接找到main函数，下断点动调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以下为输入函数（输入wasd）：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for ( i = 0LL; i &amp;lt; 1; i = v11 + 1 )
{
  v11 = i;
  snake_pkg_app_Run();
  v22 = v1;
  v3 = runtime_convT64();
  *(_QWORD *)&amp;amp;v22 = &amp;amp;unk_50C3C0;
  *((_QWORD *)&amp;amp;v22 + 1) = v3;
  fmt_Fprintf();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里找到汇编代码，直接patch&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.text:0000000000503301
.text:0000000000503301 loc_503301:
.text:0000000000503301 cmp     rax, 1
.text:0000000000503305 jl      short loc_50328D


&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以下为输出及check函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if ( i == 1 &amp;amp;&amp;amp; !qword_5C9E78 )
{
  v20 = &amp;amp;unk_50CB00;
  v21 = &amp;amp;off_545D98;
  fmt_Fprintln();
  v18 = snake_pkg_game_All_rand;
  v4 = qword_5C9E78;
  v13 = qword_5C9E78;
  v5 = 0LL;
  v6 = 0LL;
  while ( v5 &amp;lt; v4 )
  {
    v12 = v5;
    v17 = v6;
    v23 = v1;
    v7 = runtime_convT64();
    *(_QWORD *)&amp;amp;v23 = &amp;amp;unk_50C3C0;
    *((_QWORD *)&amp;amp;v23 + 1) = v7;
    fmt_Sprintf();
    v8 = runtime_concatstring2();
    v4 = v13;
    v9 = v8;
    v5 = v12 + 1;
    v6 = v9;
  }
  *((_QWORD *)&amp;amp;v14 + 1) = *((_QWORD *)&amp;amp;v1 + 1);
  sub_4BF36B();
  *((_QWORD *)&amp;amp;v14 + 1) = 0x1032547698BADCFELL;
  v15 = -1009589776;
  v16 = v1;
  runtime_stringtoslicebyte();
  crypto_sha1___digest__Write();
  crypto_sha1___digest__Sum();
  v19 = v1;
  v10 = runtime_convTslice();
  *(_QWORD *)&amp;amp;v19 = &amp;amp;unk_50BAC0;
  *((_QWORD *)&amp;amp;v19 + 1) = v10;
  fmt_Fprintf();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把score为400改成0：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.text:000000000050330D cmp     cs:qword_5C9E78, 0
.text:0000000000503318 jnz     short loc_50338B
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后一直动调到最后就行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;flag{da39a3ee5e6b4b0d3255bfef95601890afd80709}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二-can_can_need_pxory&#34;&gt;二. can_can_need_pxory&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;解包后反编译&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# uncompyle6 version 3.9.0
# Python bytecode version base 3.6 (3379)
# Decompiled from: Python 3.6.12 (default, Feb  9 2021, 09:19:15) 
# [GCC 8.3.0]
# Embedded file name: can_can_need_pxory.py
print(&#39;ccccccccccccccccccccccccccccccccccc!&#39;)
print(&#39;D0 U know C?&#39;)
print(&#39;\n#include &amp;lt;NSSCTF.h&amp;gt;\nv01d bnssst(int FTC[], int lenggggggg) {\n    int i, j, SSN;\n&#39;)
print(&#39;This is CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC&#39;)
print(&#39;6L+Z5piv5L2g6KaB55qEZmxhZ+WQl++8nwpOU1NDVEZ7YjVlMzlkMDktODg3Yy1hZGI0LTE4OWMtMWI0OGEwNWJmOTY2fQ==&#39;)
A = {&#39;flag&#39;: &#39;NSSCTF{a81c0d5e-ec6d-2b80&#39;}
print(&#39;\n                SSN = FTC[j];\n                printf(&amp;quot;flag&amp;quot;);\n            }\n}\nint mian() {\n    int FTC[] = [ -,\n&#39;)
print(&#39;ccccccccccccccccccc&#39;)
print(&#39;\nb, 2, 6, 7, -, d, 5, 8, 4, -, 6, 8, 7, 4, -, f, 1, 2, 6, e, 3, a, 5, 1, 0, 6, 1, }];\n    int lenggggggg = (int) sizeof(FTC) / sizeof(*FTC);\n    bnsScrt(FTC, lenggggggg);\n    int i;\n    for (i = 0; i &amp;lt; lenggggggg; i++)\n        printf(&amp;quot;%d &amp;quot;, FTC[i]);\n    remake 0;\n}\n&#39;)
print(&#39;----------------------------------------------------&#39;)
import base64
flag = &#39;************************************&#39;
r = &#39;&#39;
for x in range(len(flag)):
    if (x + 1) % 4 == 0:
        res = str(ord(chr(ord(flag[x]) ^ 2421)))
    else:
        res = str(ord(chr(ord(flag[x]) &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 7 &amp;gt;&amp;gt; 2 &amp;gt;&amp;gt; 1 ^ 92)))
    r = r + res + &#39;,&#39;

print(base64.b64encode(base64.b16encode(base64.b32encode(r.encode(&#39;utf-8&#39;)))).decode(&#39;utf-8&#39;))
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;r=&#39;NDc1NTMyNTQ0NzRGNDI1OTQ2NTEzMjU0NDc0RDVBNTU0NzQxNTc0NDQzNEQ0QTUzNDczNDVBNTQ0NTRDNDI1MzQ3NEQ1OTU0NEQ0QzQyNTI0NzQ1MzM1NDUxNEU0QTUzNDY1MTMyNDQ1MzRENTI1NTQ3NTE1NzQ0NEI0RDRBNTM0ODQ1NUE0MzU5NEQ1MjU0NDczNDM0NDM1OTRFNDI1NzQ3NDUzMzU0NDU0QzQyNTI0NzQxMzM1NDRENEQ0QTUzNDY1MTU5NTQ0MzRGNDI1OTQ3MzQzMzQzNTk0RDUyNTQ0NzQ5MzM0MzU5NEQ0QTUyNDczNDM0NDQ0QjRENTI0RDQ3NTEzMzQ0NDM0RTVBNTM0NjUxNTk1NDQ1NEQ0MjVBNDc0OTMyNDM1OTRENTI1NDQ3NEQ1OTQzNTk0RDRBNTI0NzU5MzQ0NDQ1NEY0MjRENDc0NTVBNDQ0NzRGNEE1QTQ3NTk1NzQ0NDk0RTUyNTI0NzM0NUE0MzU5NEQ1MjU0NDc0OTM0NTM1OTRENEE1MjQ4NDUzNDU0NDE0RDQyNEQ0NzQ1NTk1NDQ1NEU1QTU0NDc0OTU3NDQ0MzRENEE1MzQ3MzQ1QTU0NDU0QzQyNTM0NzREMzQ0NDRENEM0MjUyNDc0OTVBNTQ1MzRGNEE1NzQ2NTEzMjU0NDE0RDUyNTc0ODQxNTc0NDRCNEY0MjU1NDc1OTU5NDM1OTRENTI1NDQ3NDUzNDUzNTk0RDRBNTM0NzREMzQ1NDUzNEU1MjRENDc0NTU5NDQ0MzRFNDI1NzQ4NDE1NzQ0NDM0RDUyNTQ0ODQ1MzQ1NDRENEM0MjUzNDc0RDU5NTQ1MzRDNDI1NTQ4NDU1QTQ0NDk0RTQyNEQ0NzU1MzM1NDQ5NEQ1QTU3NDY1MTMyNTQ0RDRFNDI1MjQ3NDk1NzQ0NDU0RDVBNTQ0NzQ1NTc0MTNEM0QzRDNE&#39;
rr=base64.b32decode(base64.b16decode(base64.b64decode(r.encode(&#39;utf-8&#39;)))).decode(&#39;utf-8&#39;)
print(rr)
rr=[55388,53340,112732,2316,117852,49244,51292,2378,46172,107612,118876,2326,117852,46172,120924,2330,116828,123996,46172,2329,119900,112732,112732,2386,123996,50268,58460,2319,123996,101468,123996,2319,49244,57436,56412,2331]

for s in range(36):
    for i in range(32, 128):
        if (s + 1) % 4 == 0:
            res = ord(chr(i ^ 2421))
        else:
            res = ord(chr(i &amp;lt;&amp;lt; 6 &amp;lt;&amp;lt; 7 &amp;gt;&amp;gt; 2 &amp;gt;&amp;gt; 1 ^ 92))

        if res == rr[s]:
            print(chr(i), end=&#39;&#39;)

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;得到64nys02?-itcs-vory-lunn&#39;y19zycyz087n&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还是不对的，我看到very和itis这两个词，然后猜了一下，发现是异或10，然后就得到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;NSSCTF{64nss025-itis-very-funn-y19pycyp087d}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;纯纯谜语题，不做评价&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;crypto&#34;&gt;Crypto&lt;/h2&gt;
&lt;h3 id=&#34;一-level1&#34;&gt;一. Level1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;签到，共模攻击&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import libnum
import gmpy2

n = 22517647586235353449147432825948355885962082318127038138351524894369583539246623545565501496312996556897362735789505076324197072008392656511657262430676945685471397862981216472634785622155317188784494912316440866051402627470561626691472280850273482836308002341429493460677206562201947000047718275995355772707947408688836667011206588727438261189233517003341094758634490421007907582147392858070623641389171229435187248184443645883661560636995548332475573072064240073037558031928639832259001407585962782698021735648128101459118863015844905452823095147248865104102562991382119836061161756978764495337874807458182581421229
c1 = 1432393096266401187029059077791766305797845826173887492889260179348416733820890797101745501984437201566364579129066414005659742104885321270122634155922766503333859812540068278962999824043206496595825886026095484801291802992082454776271149083516187121160475839108002133113254134626407840182541809478892306748590016896975053434021666376203540725254480252049443975835307793528287818262102688334515632062552114342619781840154202525919769192765621085008206581226486157149883898548933475155236509073675387541466324512294079413938239828341890576923100769181401944289365386552139418728492565319685207500539721582552448971814
c2 = 13299679392897297864252207869444022461237574801991239380909482153705185317634241850084078027230394830079554676426505967970943836811048777462696506309466535820372917756458083553031417406403895116557560548183674144457502601887632495739472178857537011190162283185735114683172731936834993707871636782206418680404006299140864001776588991141011500807549645227520128216130966268810165946959810884593793452437010902774726405217517557763322690215690606067996057037379898630878638483268362526985225092000670251641184960698506349245915816808028210142606700394584541282682338561482561343076218115042099753144875658666459825545602
e1 = 155861690390761931560700906834977917646203451142415617638229284868013723431003139974975998354830978765979365632120896717380895021936387027045347260400512396388028781862427862974453223157509702913026222541667006325100878113871620322023188372501930117363623076837619478555007555970810681502521309925774889678793
e2 = 144471983652821947847253052623701746810204736865723159569786739658583884214397562204788127484897909964898113250509653721265240138487697822089282456150238116811225975640330930854549232972314642221382625614304415750165289831040623741828600283778523993251940904896081111235859249916040849697146542311990869696453

def exp_def(e1,e2,c1,c2,n):
    s,s1,s2 = gmpy2.gcdext(e1, e2)
    m = (pow(c1,s1,n) * pow(c2 ,s2 ,n)) % n
    return int(m)

m=exp_def(e1,e2,c1,c2,n)
print(libnum.n2s(m))
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;NSSCTF{Y0u_Hav3_S01v3d_Crypt0_Leve1_i}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二level2&#34;&gt;二.Level2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读取文件，猜e=65537&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;f=open(&amp;quot;C:\\Users\\lenovo\\Desktop\\ps.txt&amp;quot;)
data = f.readlines()
f.close()
for i in range(len(data)):
    p=int(data[i],10)
    q=145721736470529261146573065574028992352505611489859183763269215489708531333597694809923949026781460438320576519639268582565188719134157402292313959218961804213310847081787824780075530751842057663327444602428455144829447776271394663729996984613471623158126083062443634493708467568220146024273763894704649472957
    c=17441814714407189483380175736850663249578989775568187792928771544069162420510939242665830363276698262009780462912108642025299275146709817979705069095332726251759039923303627023610865046363171692163473939115438686877494878334016463787558794121885354719336139401336137097548305393030069499625065664884238710759260231321106291200849044147840392021931720902340003746946851806025722944795391356835342258387797980787437188976704677008092850181043891802072500430200735973581081228711070923822341261809453662427341958883142789220800541626034573952425948295446202775198692920613709157662831071515700549093766182579873408465779
    e=65537
    n=p*q
    phi=(p-1)*(q-1)
    d=inverse(e,phi)
    m=long_to_bytes(pow(c,d,n))
    if b&#39;NSSCTF{&#39; in m:
        print(m)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;NSSCTF{Y0u_g0t_1t!!!}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三-level3&#34;&gt;三. Level3&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利用pwn库写个交互脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
from Crypto.Util.number import *
def func(a, b):
    if a == 0:
        return b, 0, 1
    else:
        g, x, y = func(b % a, a)
        return g, y - (b // a) * x, x

io = remote(&amp;quot;node1.anna.nssctf.cn&amp;quot;,28458)
for i in range(666):
    lines = io.recvuntil(&amp;quot;Pl Give Me flaag :&amp;quot;).decode().split(&#39;\n&#39;)
    
    if i &amp;lt; 2:
        n=int(lines[12].split(&#39;=&#39;)[1])
        e1=int(lines[13].split(&#39;=&#39;)[1])
        e2=int(lines[14].split(&#39;=&#39;)[1])
        c1=int(lines[15].split(&#39;=&#39;)[1])
        c2=int(lines[16].split(&#39;=&#39;)[1])
    elif i &amp;gt;=2:
        n=int(lines[13].split(&#39;=&#39;)[1])
        e1=int(lines[14].split(&#39;=&#39;)[1])
        e2=int(lines[15].split(&#39;=&#39;)[1])
        c1=int(lines[16].split(&#39;=&#39;)[1])
        c2=int(lines[17].split(&#39;=&#39;)[1])
    g, b1, b2 = func(e1, e2)

    if g != 1:
        raise ValueError(&amp;quot;e1 and e2 are not coprime&amp;quot;)

    m = pow(c1, b1, n) * pow(c2, b2, n) % n
    flag = long_to_bytes(m)
    io.sendline(flag.decode(&amp;quot;utf-8&amp;quot;))
    print(f&amp;quot;count{i}&amp;quot;)
io.recvuntil(&amp;quot;You get flag!&amp;quot;)
print(io.recvlines(2))
#NSSCTF{220b5065-4e42-47b2-ac83-6656d77fa102}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;NSSCTF{220b5065-4e42-47b2-ac83-6656d77fa102}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">NSSCTF Round17  Reverse & Crypto WriteUp（全）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/xi-hu-lun-jian-2023-quals-reverse-writeup1/"" data-c="
          &lt;ul&gt;
&lt;li&gt;去年西湖论剑没打，今年要打了，补下之前的题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-babyre&#34;&gt;一. BabyRe&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;main函数中只有一句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl main(int argc, const char **argv, const char **envp)
{
  __CheckForDebuggerJustMyCode(&amp;amp;unk_4090A2);
  GetLastError();
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看字符串，并交叉引用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到几个函数：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int sub_401000()
{
  __CheckForDebuggerJustMyCode(&amp;amp;unk_4090A2);
  sub_401170(&amp;amp;unk_4085C6);
  return atexit(sub_405770);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int sub_401050()
{
  __CheckForDebuggerJustMyCode(&amp;amp;unk_4090A2);
  sub_401230(&amp;amp;unk_4085C4);
  return atexit(sub_4057B0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int sub_4010A0()
{
  __CheckForDebuggerJustMyCode(&amp;amp;unk_4090A2);
  sub_4012B0(&amp;amp;unk_4085C5);
  return atexit(sub_4057F0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现了atexit函数，这个函数为登记函数，是在正常程序退出时调用的函数，&lt;strong&gt;⼀个进程可以登记若⼲个（具体⾃⼰验证⼀下）个函数，这些函数由exit⾃动调⽤，这些函数被称为终⽌处理函数， atexit函数可以登记这些函数。 exit调⽤终⽌处理函数的顺序和atexit登记的顺序&lt;em&gt;相反&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再通过打断点动调，即可找到函数调用顺序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-ceylon&#34;&gt;401170
401230
4012B0
main
atexit 4014E0
atexit 4015C0
atexit 401670
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分别分析函数作用如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void *__thiscall sub_401170(void *this)//输入函数
{
  char v2; // [esp+0h] [ebp-E4h]
  size_t i; // [esp+D0h] [ebp-14h]

  __CheckForDebuggerJustMyCode(&amp;amp;unk_4090A2);
  sub_4025A0(&amp;quot;Input:&amp;quot;, v2);
  sub_402620(&amp;quot;%99s&amp;quot;, (char)Str);
  for ( i = 0; i &amp;lt; strlen(Str); ++i )
  {
    if ( Str[i] &amp;lt; 48 || Str[i] &amp;gt; 57 )
      ExitProcess(0);
  }
  return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void *__thiscall sub_401230(void *this)//按位取反，得到01234567的table
{
  int i; // [esp+D0h] [ebp-14h]

  __CheckForDebuggerJustMyCode(&amp;amp;unk_4090A2);
  for ( i = 0; i &amp;lt; 8; ++i )
    byte_408104[i] = ~byte_408104[i];
  return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __thiscall sub_4012B0(void *this)//遍历输入表进行hook
{
  int i; // [esp+DCh] [ebp-9Ch]
  char *v3; // [esp+E8h] [ebp-90h]
  char *v4; // [esp+F4h] [ebp-84h]
  const CHAR *lpModuleName; // [esp+10Ch] [ebp-6Ch]
  _DWORD *v6; // [esp+118h] [ebp-60h]
  DWORD flOldProtect[9]; // [esp+124h] [ebp-54h] BYREF
  int v8; // [esp+148h] [ebp-30h]
  HMODULE v9; // [esp+154h] [ebp-24h]
  HMODULE ModuleHandleA; // [esp+160h] [ebp-18h]
  void *v11; // [esp+16Ch] [ebp-Ch]

  v11 = this;
  __CheckForDebuggerJustMyCode(&amp;amp;unk_4090A2);
  ModuleHandleA = GetModuleHandleA(0);
  v9 = ModuleHandleA;
  v8 = (int)ModuleHandleA + *((_DWORD *)ModuleHandleA + 15) + 4;
  flOldProtect[6] = v8 + 20;
  flOldProtect[3] = v8 + 116;
  v6 = (_DWORD *)((char *)ModuleHandleA + *(_DWORD *)(v8 + 124));
  while ( v6[3] )
  {
    lpModuleName = (char *)ModuleHandleA + v6[3];
    if ( GetModuleHandleA(lpModuleName) || LoadLibraryA(lpModuleName) )
    {
      v4 = (char *)ModuleHandleA + *v6;
      v3 = (char *)ModuleHandleA + v6[4];
      for ( i = 0; *(_DWORD *)&amp;amp;v4[4 * i]; ++i )
      {
        if ( *(int *)&amp;amp;v4[4 * i] &amp;gt;= 0 &amp;amp;&amp;amp; !strcmp((const char *)ModuleHandleA + *(_DWORD *)&amp;amp;v4[4 * i] + 2, &amp;quot;GetLastError&amp;quot;) )
        {
          dword_4085C0 = *(_DWORD *)&amp;amp;v3[4 * i];
          VirtualProtect(&amp;amp;v3[4 * i], 4u, 4u, flOldProtect);
          *(_DWORD *)&amp;amp;v3[4 * i] = sub_4019D0;//将GetLastError函数改为4019D0
          break;
        }
      }
      v6 += 5;
    }
    else
    {
      v6 += 5;
    }
  }
  return (int)v11;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int sub_401670()
{
  int result; // eax

  __CheckForDebuggerJustMyCode(&amp;amp;unk_4090A2);
  sub_401720(&amp;amp;Str, (int)&amp;amp;unk_4081C0);//base8加密
  result = memcmp(&amp;amp;unk_4081D0, a16230465152334, 0x60u);//赋值
  if ( result )
    ExitProcess(0);
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int sub_4015C0()
{
  int result; // eax

  __CheckForDebuggerJustMyCode(&amp;amp;unk_4090A2);
  sub_401CC0((int)&amp;amp;unk_4081C0, 112, 0, Buffer);//sha-1
  result = memcmp(Buffer, a67339fc92b4875, 0x28u);
  if ( result )
    ExitProcess(0);
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl sub_4014E0()//检验
{
  char v1; // [esp+0h] [ebp-E8h]

  __CheckForDebuggerJustMyCode(&amp;amp;unk_4090A2);
  memcpy(&amp;amp;unk_4084C0, &amp;amp;unk_4081C0, 0x70u);//赋值，前16位未知，后面96位已知
  sub_401B60(&amp;amp;unk_4083C0, &amp;amp;unk_408182, 6);//RC4_init，6位密钥为输入的后六位
  sub_401A40(&amp;amp;unk_4083C0, &amp;amp;unk_4084C0, 112);//RC4
  if ( memcmp(&amp;amp;unk_4084C0, &amp;amp;unk_408090, 0x70u) )//比较函数
    ExitProcess(0);
  return sub_4025A0(&amp;quot;Good, flag is DASCTF{your input}&amp;quot;, v1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void *__cdecl sub_401CC0(int a1, __int64 a2, char *Buffer)//换了常数的SHA-1加密
{
  void *result; // eax
  int v4; // [esp+Ch] [ebp-4D4h]
  int v5; // [esp+10h] [ebp-4D0h]
  int v6; // [esp+14h] [ebp-4CCh]
  int v7; // [esp+18h] [ebp-4C8h]
  int v8; // [esp+1A0h] [ebp-340h]
  int v9; // [esp+1ACh] [ebp-334h]
  int v10; // [esp+1B8h] [ebp-328h]
  int v11; // [esp+1C4h] [ebp-31Ch]
  int v12; // [esp+1D0h] [ebp-310h]
  int v13; // [esp+1DCh] [ebp-304h]
  int v14; // [esp+1E4h] [ebp-2FCh]
  int v15; // [esp+1E8h] [ebp-2F8h]
  int v16[2]; // [esp+1ECh] [ebp-2F4h]
  int v17; // [esp+1F4h] [ebp-2ECh]
  int v18; // [esp+200h] [ebp-2E0h]
  int v19[2]; // [esp+204h] [ebp-2DCh]
  int v20; // [esp+20Ch] [ebp-2D4h]
  int v21[167]; // [esp+218h] [ebp-2C8h]
  int i; // [esp+4B4h] [ebp-2Ch]
  size_t Size; // [esp+4C0h] [ebp-20h]
  unsigned int v24; // [esp+4CCh] [ebp-14h]
  unsigned int v25; // [esp+4D8h] [ebp-8h]

  __CheckForDebuggerJustMyCode(&amp;amp;unk_4090A2);
  v12 = 271733878;
  v11 = -1984242434;
  v10 = -271733879;
  v9 = 1732588033;
  v8 = 253635900;
  for ( i = 0; i &amp;lt; 20; ++i )
    v21[i + 85] = dword_408148[0];
  for ( i = 20; i &amp;lt; 40; ++i )
    v21[i + 85] = dword_408148[1];
  for ( i = 40; i &amp;lt; 60; ++i )
    v21[i + 85] = dword_408148[2];
  for ( i = 60; i &amp;lt; 80; ++i )
    v21[i + 85] = dword_408148[3];
  if ( a2 % 64 &amp;lt;= 56 )
    v4 = 64 - a2 % 64;
  else
    v4 = 128 - a2 % 64;
  Size = v4 + a2;
  result = malloc(v4 + a2);
  v25 = (unsigned int)result;
  if ( result )
  {
    for ( i = 0; i &amp;lt; a2; ++i )
      *(_BYTE *)(v25 + i + 3 - 2 * (i % 4)) = *(_BYTE *)(i + a1);
    *(_BYTE *)(v25 + i + 3 - 2 * (i % 4)) = 0x80;
    ++i;
    while ( i &amp;lt; (int)Size )
    {
      *(_BYTE *)(v25 + i + 3 - 2 * (i % 4)) = 0;
      ++i;
    }
    *(_DWORD *)(Size + v25 - 4) = 8 * a2;
    *(_DWORD *)(Size + v25 - 8) = a2 &amp;gt;&amp;gt; 29;
    v24 = Size + v25;
    while ( v25 &amp;lt; v24 )
    {
      for ( i = 0; i &amp;lt; 16; ++i )
        v21[i + 3] = *(_DWORD *)(v25 + 4 * i);
      for ( i = 16; i &amp;lt; 80; ++i )
      {
        dword_4081BC = *(&amp;amp;v14 + i) ^ v16[i] ^ v19[i] ^ v21[i];
        v21[i + 3] = (2 * dword_4081BC) | (dword_4081BC &amp;gt;&amp;gt; 31) &amp;amp; 1;
      }
      v20 = v12;
      v18 = v11;
      v17 = v10;
      v15 = v9;
      v13 = v8;
      for ( i = 0; i &amp;lt; 80; ++i )
      {
        dword_4081BC = v20;
        if ( i &amp;gt;= 40 )
        {
          if ( i &amp;gt;= 60 )
            v5 = v15 ^ v17 ^ v18;
          else
            v5 = v15 &amp;amp; v17 | v15 &amp;amp; v18 | v17 &amp;amp; v18;
          v6 = v5;
        }
        else
        {
          if ( i &amp;gt;= 20 )
            v7 = v15 ^ v17 ^ v18;
          else
            v7 = v15 &amp;amp; ~v18 | v17 &amp;amp; v18;
          v6 = v7;
        }
        v21[0] = v21[i + 85] + v21[i + 3] + v13 + v6 + ((32 * dword_4081BC) | (dword_4081BC &amp;gt;&amp;gt; 27) &amp;amp; 0x1F);
        v13 = v15;
        v15 = v17;
        dword_4081BC = v18;
        v17 = (v18 &amp;lt;&amp;lt; 30) | (v18 &amp;gt;&amp;gt; 2) &amp;amp; 0x3FFFFFFF;
        v18 = v20;
        v20 = v21[0];
      }
      v12 += v20;
      v11 += v18;
      v10 += v17;
      v9 += v15;
      v8 += v13;
      v25 += 64;
    }
    free((void *)(v25 - Size));
    return (void *)sub_4026A0(Buffer, &amp;quot;%08x%08x%08x%08x%08x&amp;quot;, v12);
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;六位密钥，可以先进行爆破&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;c=[0x3F, 0x95, 0xBB, 0xF2, 0x57, 0xF1, 0x7A, 0x5A, 0x22, 0x61,
  0x51, 0x43, 0xA2, 0xFA, 0x9B, 0x6F, 0x44, 0x63, 0xC0, 0x08,
  0x12, 0x65, 0x5C, 0x8A, 0x8C, 0x4C, 0xED, 0x5E, 0xCA, 0x76,
  0xB9, 0x85, 0xAF, 0x05, 0x38, 0xED, 0x42, 0x3E, 0x42, 0xDF,
  0x5D, 0xBE, 0x05, 0x8B, 0x35, 0x6D, 0xF3, 0x1C, 0xCF, 0xF8,
  0x6A, 0x73, 0x25, 0xE4, 0xB7, 0xB9, 0x36, 0xFB, 0x02, 0x11,
  0xA0, 0xF0, 0x57, 0xAB, 0x21, 0xC6, 0xC7, 0x46, 0x99, 0xBD,
  0x1E, 0x61, 0x5E, 0xEE, 0x55, 0x18, 0xEE, 0x03, 0x29, 0x84,
  0x7F, 0x94, 0x5F, 0xB4, 0x6A, 0x29, 0xD8, 0x6C, 0xE4, 0xC0,
  0x9D, 0x6B, 0xCC, 0xD5, 0x94, 0x5C, 0xDD, 0xCC, 0xD5, 0x3D,
  0xC0, 0xEF, 0x0C, 0x29, 0xE5, 0xB0, 0x93, 0xF1, 0xB3, 0xDE,
  0xB0, 0x70]
x=[0]*16+[0x31, 0x36, 0x32, 0x33, 0x30, 0x34, 0x36, 0x35, 0x31, 0x35,
  0x32, 0x33, 0x33, 0x34, 0x36, 0x32, 0x31, 0x34, 0x34, 0x33,
  0x31, 0x34, 0x37, 0x31, 0x31, 0x35, 0x30, 0x33, 0x31, 0x30,
  0x37, 0x30, 0x31, 0x35, 0x30, 0x33, 0x32, 0x30, 0x37, 0x31,
  0x31, 0x36, 0x30, 0x33, 0x32, 0x30, 0x36, 0x33, 0x31, 0x34,
  0x30, 0x33, 0x33, 0x34, 0x36, 0x36, 0x31, 0x35, 0x34, 0x33,
  0x34, 0x34, 0x36, 0x31, 0x31, 0x34, 0x34, 0x33, 0x34, 0x30,
  0x36, 0x36, 0x31, 0x34, 0x32, 0x33, 0x30, 0x34, 0x36, 0x36,
  0x31, 0x35, 0x36, 0x33, 0x34, 0x34, 0x36, 0x36, 0x31, 0x35,
  0x34, 0x33, 0x30, 0x34, 0x36, 0x34]
a1=[0]*256
v5=[0]*256
for i1 in range(48,58):
    for i2 in range(48, 58):
        for i3 in range(48, 58):
            for i4 in range(48, 58):
                for i5 in range(48, 58):
                    for i6 in range(48, 58):
                        key=[i1,i2,i3,i4,i5,i6]
                        v6=0
                        for i in range(256):
                            a1[i]=i
                            v5[i]=key[i%6]
                        for i in range(256):
                            v6=(v5[i]+v6+a1[i])%256
                            v4=a1[i]
                            a1[i]=a1[v6]
                            a1[v6]=v4
                        flag=1
                        v6=0
                        v7=0
                        for i in range(112):
                            v7=(v7+1)%256
                            v6=(v6+a1[v7])%256
                            v4=a1[v7]
                            a1[v7]=a1[v6]
                            a1[v6]=v4
                            if i&amp;lt;16:
                                continue
                            else:
                                if c[i]^a1[(a1[v6]+a1[v7])%256]!=x[i]:
                                    flag=0
                                    break
                        if flag==1:
                            print(i1,i2,i3,i4,i5,i6)
                            exit(0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后直接对密文先进行RC4解密，再进行base8解密即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def base8decode(c):
    flag=&#39;&#39;
    for i in c:
        flag+=bin(int(chr(i)))[2:].rjust(3,&#39;0&#39;)
    return [int(flag[i:i+8],2) for i in range(0,len(flag),8)]
key=[56 ,48 ,55 ,51 ,57, 49]
v6=0
a1=[0]*256
v5=[0]*256
for i in range(256):
    a1[i]=i
    v5[i]=key[i%6]
for i in range(256):
    v6=(v5[i]+v6+a1[i])%256
    a1[i],a1[v6]=a1[v6],a1[i]
v6=0
v7=0
for i in range(112):
    v7=(v7+1)%256
    v6=(v6+a1[v7])%256
    a1[v7],a1[v6]=a1[v6],a1[v7]
    c[i]^=a1[(a1[v6]+a1[v7])%256]
flag=bytes(base8decode(c)+key)
print(flag)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;DASCTF{561516915572239428449843076691286116796614807391}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-dual-personality&#34;&gt;二. &lt;strong&gt;Dual personality&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本题打开就是一片红，发现是依据Window的WoW机制进行实现的天堂之门，那么本题主要思路就是一段一段dump分析即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;main第一段：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.text:004013A0
.text:004013A0                               ; int __cdecl main(int argc, const char **argv, const char **envp)
.text:004013A0                               _main:                                  ; CODE XREF: invoke_main(void)+2E↓p
.text:004013A0 55                            push    ebp
.text:004013A1 8B EC                         mov     ebp, esp
.text:004013A3 81 EC 34 01 00 00             sub     esp, 134h
.text:004013A9 53                            push    ebx
.text:004013AA 56                            push    esi
.text:004013AB 57                            push    edi
.text:004013AC 8D 7D 8C                      lea     edi, [ebp-74h]
.text:004013AF B9 1D 00 00 00                mov     ecx, 1Dh
.text:004013B4 B8 CC CC CC CC                mov     eax, 0CCCCCCCCh
.text:004013B9 F3 AB                         rep stosd
.text:004013BB A1 24 70 40 00                mov     eax, ___security_cookie
.text:004013C0 33 C5                         xor     eax, ebp
.text:004013C2 89 45 FC                      mov     [ebp-4], eax
.text:004013C5 E8 36 FC FF FF                call    sub_401000
.text:004013C5
.text:004013CA 68 60 70 40 00                push    offset unk_407060
.text:004013CF 68 70 51 40 00                push    offset a99s                     ; &amp;quot;%99s&amp;quot;
.text:004013D4 E8 47 02 00 00                call    sub_401620
.text:004013D4
.text:004013D9 83 C4 08                      add     esp, 8
.text:004013DC 68 D0 11 40 00                push    offset dword_4011D0
.text:004013E1 6A 07                         push    7
.text:004013E3 E8 38 FD FF FF                call    sub_401120
.text:004013E3
.text:004013E8 83 C4 08                      add     esp, 8
.text:004013EB 85 C0                         test    eax, eax
.text:004013ED 74 05                         jz      short loc_4013F4
.text:004013ED
.text:004013EF A1 58 70 40 00                mov     eax, dword_407058
.text:004013EF
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主要分析401120函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个参数，一个是长度，一个是地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl sub_401120(size_t Size, int a2)
{
  char *v2; // ebx
  char *retaddr; // [esp+D0h] [ebp+4h]

  dword_407050 = VirtualAlloc(0, Size + 6, 0x3000u, 0x40u);
  dword_407000 = (int)dword_407050;
  memcpy(dword_407050, retaddr, Size);
  v2 = (char *)dword_407050 + Size;
  *v2 = -23;
  *(_DWORD *)(v2 + 1) = &amp;amp;retaddr[Size] - v2 - 5;
  v2[5] = -52;
  *retaddr = -22;
  *(_DWORD *)(retaddr + 1) = a2;
  *(_WORD *)(retaddr + 5) = 51;
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该函数首先创建新空间，将未修改前的指令拷贝至新申请的内存中，将调用函数的后长度个字修改为0xEA地址0x33 ，还有一个跳转回原地址的指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改后的指令实现一个远跳，同时修改cs与ip的地址，并切换成64位模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面将对应地址数据进行dump&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;seg000:0000000000000000                               sub_0 proc near
seg000:0000000000000000 65 48 8B 04 25 60 00 00 00    mov     rax, qword ptr gs:loc_5F+1
seg000:0000000000000009 8A 40 02                      mov     al, [rax+2]
seg000:000000000000000C 88 04 25 5C 70 40 00          mov     ds:40705Ch, al
seg000:0000000000000013 84 C0                         test    al, al
seg000:0000000000000015 75 0E                         jnz     short loc_25
seg000:0000000000000015
seg000:0000000000000017 41 BC AE 66 F9 5D             mov     r12d, 5DF966AEh
seg000:000000000000001D 44 89 24 25 58 70 40 00       mov     ds:407058h, r12d
seg000:000000000000001D
seg000:0000000000000025
seg000:0000000000000025                               loc_25:                                 ; CODE XREF: sub_0+15↑j
seg000:0000000000000025 44 B8 00 70 40 00             mov     eax, 407000h
seg000:000000000000002B 48 FF 28                      jmp     qword ptr [rax]
seg000:000000000000002B
seg000:000000000000002B                               sub_0 endp
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中很明显的使用了Beingdebugged反调试技巧&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并将407058的值进行修改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最终跳回407000中所存的地址处（就是原地址）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继续向下分析主函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.text:004013F4                               loc_4013F4:                             ; CODE XREF: .text:004013ED↑j
.text:004013F4 2D 11 41 52 21                sub     eax, 21524111h
.text:004013F9 A3 58 70 40 00                mov     dword_407058, eax
.text:004013FE C7 45 F4 60 70 40 00          mov     dword ptr [ebp-0Ch], offset unk_407060
.text:00401405 C7 45 E8 00 00 00 00          mov     dword ptr [ebp-18h], 0
.text:0040140C EB 09                         jmp     short loc_401417
.text:0040140C
.text:0040140E                               ; ---------------------------------------------------------------------------
.text:0040140E
.text:0040140E                               loc_40140E:                             ; CODE XREF: .text:0040144A↓j
.text:0040140E 8B 45 E8                      mov     eax, [ebp-18h]
.text:00401411 83 C0 01                      add     eax, 1
.text:00401414 89 45 E8                      mov     [ebp-18h], eax
.text:00401414
.text:00401417
.text:00401417                               loc_401417:                             ; CODE XREF: .text:0040140C↑j
.text:00401417 83 7D E8 08                   cmp     dword ptr [ebp-18h], 8
.text:0040141B 7D 2F                         jge     short loc_40144C
.text:0040141B
.text:0040141D 8B 45 E8                      mov     eax, [ebp-18h]
.text:00401420 8B 4D F4                      mov     ecx, [ebp-0Ch]
.text:00401423 8B 14 81                      mov     edx, [ecx+eax*4]
.text:00401426 03 15 58 70 40 00             add     edx, dword_407058
.text:0040142C 8B 45 E8                      mov     eax, [ebp-18h]
.text:0040142F 8B 4D F4                      mov     ecx, [ebp-0Ch]
.text:00401432 89 14 81                      mov     [ecx+eax*4], edx
.text:00401435 8B 45 E8                      mov     eax, [ebp-18h]
.text:00401438 8B 4D F4                      mov     ecx, [ebp-0Ch]
.text:0040143B 8B 15 58 70 40 00             mov     edx, dword_407058
.text:00401441 33 14 81                      xor     edx, [ecx+eax*4]
.text:00401444 89 15 58 70 40 00             mov     dword_407058, edx
.text:0040144A EB C2                         jmp     short loc_40140E
.text:0040144A
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;很明显的一段加密，循环&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一次加密后继续跳转&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.text:0040144C                               loc_40144C:                             ; CODE XREF: .text:0040141B↑j
.text:0040144C 6A 00                         push    0
.text:0040144E 8D 05 60 70 40 00             lea     eax, unk_407060
.text:00401454 50                            push    eax
.text:00401455 FF 1D 0C 70 40 00             call    fword ptr byte_40700C
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里的call实现第二次向64位的切换，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.data:0040700C byte_40700C db 0, 12h, 40h, 0, 33h, 0  
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将401200处数据dump下来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dump脚本如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static main(void)
{
  auto fp, begin, end, dexbyte;
  fp = fopen(&amp;quot;D:\dump1&amp;quot;, &amp;quot;wb&amp;quot;);
  begin = 0x401200;
  end = 0x401288;
  for ( dexbyte = begin; dexbyte &amp;lt; end; dexbyte ++ )
      fputc(Byte(dexbyte), fp);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void sub_0()
{
  _QWORD *v0; // [rsp+10h] [rbp+10h]

  if ( MEMORY[0x40705C] )
  {
    *v0 = __ROL8__(*v0, 32);
    v0[1] = __ROL8__(v0[1], 32);
    v0[2] = __ROL8__(v0[2], 32);
    v0[3] = __ROL8__(v0[3], 32);
    JUMPOUT(0x7Ci64);
  }
  *v0 = __ROL8__(*v0, 12);
  v0[1] = __ROL8__(v0[1], 34);
  v0[2] = __ROL8__(v0[2], 56);
  v0[3] = __ROL8__(v0[3], 14);
  JUMPOUT(0x77i64);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果调试中，则错误加密，否则正确加密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结束后&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.text:0040127C mov     ebx, 0
.text:00401281 dec     eax
.text:00401282 xor     eax, eax
.text:00401284 dec     eax
.text:00401285 mov     esp, ebp
.text:00401287 pop     ebp
.text:00401288 retf    8
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新切换到32位模式（retf跳回原位置）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继续分析main&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;text:0040145B push    offset dword_401290
.text:00401460 push    7
.text:00401462 call    sub_401120
.text:00401462
.text:00401467 add     esp, 8
.text:0040146A test    eax, eax
.text:0040146C jnz     short near ptr loc_40146F+4
.text:0040146C
.text:0040146E dec     eax
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;又是一个401120函数，第三次切换成64位模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继续dump分析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 sub_0()
{
  MEMORY[0x407000] = 4199621;
  MEMORY[0x407014] &amp;amp;= MEMORY[0x407018];
  MEMORY[0x407018] |= MEMORY[0x40701C];
  MEMORY[0x40701C] ^= MEMORY[0x407020];
  MEMORY[0x407020] = ~MEMORY[0x407020];
  return MEMORY[0x407050]();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里直接返回未修改前保存的指令，并未切换为32位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导致下面的指令无法被IDA32分析，故继续dump&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;seg000:0000000000000000                               sub_0 proc near                         ; CODE XREF: sub_0+4C↓j
seg000:0000000000000000 48 8B 04 25 C8 70 40 00       mov     rax, ds:4070C8h
seg000:0000000000000008 48 83 F8 20                   cmp     rax, 20h ; &#39; &#39;
seg000:000000000000000C 74 40                         jz      short loc_4E
seg000:000000000000000C
seg000:000000000000000E 48 33 D2                      xor     rdx, rdx
seg000:0000000000000011 48 B9 04 00 00 00 00 00 00 00 mov     rcx, 4
seg000:000000000000001B 48 F7 F1                      div     rcx
seg000:000000000000001E 48 8D 1C 25 14 70 40 00       lea     rbx, ds:407014h
seg000:0000000000000026 8A 14 93                      mov     dl, [rbx+rdx*4]
seg000:0000000000000029 48 8B 04 25 C8 70 40 00       mov     rax, ds:4070C8h
seg000:0000000000000031 48 8D 1C 25 60 70 40 00       lea     rbx, ds:407060h
seg000:0000000000000039 8A 0C 03                      mov     cl, [rbx+rax]
seg000:000000000000003C 32 CA                         xor     cl, dl
seg000:000000000000003E 88 0C 03                      mov     [rbx+rax], cl
seg000:0000000000000041 48 FF C0                      inc     rax
seg000:0000000000000044 48 89 04 25 C8 70 40 00       mov     ds:4070C8h, rax
seg000:000000000000004C EB B2                         jmp     short sub_0
seg000:000000000000004C
seg000:000000000000004E                               ; ---------------------------------------------------------------------------
seg000:000000000000004E
seg000:000000000000004E                               loc_4E:                                 ; CODE XREF: sub_0+C↑j
seg000:000000000000004E 44 B8 00 70 40 00             mov     eax, 407000h
seg000:0000000000000054 48 FF 28                      jmp     qword ptr [rax]
seg000:0000000000000054
seg000:0000000000000057                               ; ---------------------------------------------------------------------------
seg000:0000000000000057 33 C0                         xor     eax, eax
seg000:0000000000000059 89 45 BC                      mov     [rbp-44h], eax
seg000:000000000000005C 89 45 C0                      mov     [rbp-40h], eax
seg000:000000000000005F 89 45 C4                      mov     [rbp-3Ch], eax
seg000:0000000000000062 89 45 C8                      mov     [rbp-38h], eax
seg000:0000000000000065 89 45 CC                      mov     [rbp-34h], eax
seg000:0000000000000068 89 45 D0                      mov     [rbp-30h], eax
seg000:000000000000006B 89 45 D4                      mov     [rbp-2Ch], eax
seg000:000000000000006E 89 45 D8                      mov     [rbp-28h], eax
seg000:0000000000000071 88 45 DC                      mov     [rbp-24h], al
seg000:0000000000000074 C6 45 90 AA                   mov     byte ptr [rbp-70h], 0AAh
seg000:0000000000000078 C6 45 91 4F                   mov     byte ptr [rbp-6Fh], 4Fh ; &#39;O&#39;
seg000:000000000000007C C6 45 92 0F                   mov     byte ptr [rbp-6Eh], 0Fh
seg000:0000000000000080 C6 45 93 E2                   mov     byte ptr [rbp-6Dh], 0E2h
seg000:0000000000000084 C6 45 94 E4                   mov     byte ptr [rbp-6Ch], 0E4h
seg000:0000000000000088 C6 45 95 41                   mov     byte ptr [rbp-6Bh], 41h ; &#39;A&#39;
seg000:000000000000008C C6 45 96 99                   mov     byte ptr [rbp-6Ah], 99h
seg000:0000000000000090 C6 45 97 54                   mov     byte ptr [rbp-69h], 54h ; &#39;T&#39;
seg000:0000000000000094 C6 45 98 2C                   mov     byte ptr [rbp-68h], 2Ch ; &#39;,&#39;
seg000:0000000000000098 C6 45 99 2B                   mov     byte ptr [rbp-67h], 2Bh ; &#39;+&#39;
seg000:000000000000009C C6 45 9A 84                   mov     byte ptr [rbp-66h], 84h
seg000:00000000000000A0 C6 45 9B 7E                   mov     byte ptr [rbp-65h], 7Eh ; &#39;~&#39;
seg000:00000000000000A4 C6 45 9C BC                   mov     byte ptr [rbp-64h], 0BCh
seg000:00000000000000A8 C6 45 9D 8F                   mov     byte ptr [rbp-63h], 8Fh
seg000:00000000000000AC C6 45 9E 8B                   mov     byte ptr [rbp-62h], 8Bh
seg000:00000000000000B0 C6 45 9F 78                   mov     byte ptr [rbp-61h], 78h ; &#39;x&#39;
seg000:00000000000000B4 C6 45 A0 D3                   mov     byte ptr [rbp-60h], 0D3h
seg000:00000000000000B8 C6 45 A1 73                   mov     byte ptr [rbp-5Fh], 73h ; &#39;s&#39;
seg000:00000000000000BC C6 45 A2 88                   mov     byte ptr [rbp-5Eh], 88h
seg000:00000000000000C0 C6 45 A3 5E                   mov     byte ptr [rbp-5Dh], 5Eh ; &#39;^&#39;
seg000:00000000000000C4 C6 45 A4 AE                   mov     byte ptr [rbp-5Ch], 0AEh
seg000:00000000000000C8 C6 45 A5 47                   mov     byte ptr [rbp-5Bh], 47h ; &#39;G&#39;
seg000:00000000000000CC C6 45 A6 85                   mov     byte ptr [rbp-5Ah], 85h
seg000:00000000000000D0 C6 45 A7 70                   mov     byte ptr [rbp-59h], 70h ; &#39;p&#39;
seg000:00000000000000D4 C6 45 A8 31                   mov     byte ptr [rbp-58h], 31h ; &#39;1&#39;
seg000:00000000000000D8 C6 45 A9 B3                   mov     byte ptr [rbp-57h], 0B3h
seg000:00000000000000DC C6 45 AA 09                   mov     byte ptr [rbp-56h], 9
seg000:00000000000000E0 C6 45 AB CE                   mov     byte ptr [rbp-55h], 0CEh
seg000:00000000000000E4 C6 45 AC 13                   mov     byte ptr [rbp-54h], 13h
seg000:00000000000000E8 C6 45 AD F5                   mov     byte ptr [rbp-53h], 0F5h
seg000:00000000000000EC C6 45 AE 0D                   mov     byte ptr [rbp-52h], 0Dh
seg000:00000000000000F0 C6 45 AF CA                   mov     byte ptr [rbp-51h], 0CAh
seg000:00000000000000F4 33 C0                         xor     eax, eax
seg000:00000000000000F6 88 45 B0                      mov     [rbp-50h], al
seg000:00000000000000F9 6A 20                         push    20h ; &#39; &#39;
seg000:00000000000000FB 8D 45 90                      lea     eax, [rbp-70h]
seg000:00000000000000FE 50                            push    rax
seg000:00000000000000FF 68 60 70 40 00                push    407060h
seg000:0000000000000104 E8 AD 2C 00 00                call    near ptr 2DB6h
seg000:0000000000000104
seg000:0000000000000109 83 C4 0C                      add     esp, 0Ch
seg000:000000000000010C 85 C0                         test    eax, eax
seg000:000000000000010E 75 28                         jnz     short loc_138
seg000:000000000000010E
seg000:0000000000000110 8B F4                         mov     esi, esp
seg000:0000000000000112 68 78 51 40 00                push    405178h
seg000:0000000000000117 FF 15 F8 50 40 00             call    qword ptr cs:405215h
seg000:0000000000000117
seg000:000000000000011D 83 C4 04                      add     esp, 4
seg000:0000000000000120 3B F4                         cmp     esi, esp
seg000:0000000000000122 E8 9B 02 00 00                call    near ptr 3C2h
seg000:0000000000000122
seg000:0000000000000127 8B F4                         mov     esi, esp
seg000:0000000000000129 6A 00                         push    0
seg000:000000000000012B FF 15 F0 50 40 00             call    qword ptr cs:405221h
seg000:000000000000012B
seg000:0000000000000131 3B F4                         cmp     esi, esp
seg000:0000000000000133 E8 8A 02 00 00                call    near ptr 3C2h
seg000:0000000000000133
seg000:0000000000000138
seg000:0000000000000138                               loc_138:                                ; CODE XREF: sub_0+10E↑j
seg000:0000000000000138 8B F4                         mov     esi, esp
seg000:000000000000013A 68 9C 51 40 00                push    40519Ch
seg000:000000000000013F FF 15 F8 50 40 00             call    qword ptr cs:40523Dh
seg000:000000000000013F
seg000:0000000000000145 83 C4 04                      add     esp, 4
seg000:0000000000000148 3B F4                         cmp     esi, esp
seg000:000000000000014A E8 73 02 00 00                call    near ptr 3C2h
seg000:000000000000014A
seg000:000000000000014F 33 C0                         xor     eax, eax
seg000:0000000000000151 52                            push    rdx
seg000:0000000000000152 8B CD                         mov     ecx, ebp
seg000:0000000000000154 50                            push    rax
seg000:0000000000000155 8D 15 F0 15 40 00             lea     edx, cs:40174Bh
seg000:000000000000015B E8 02 02 00 00                call    near ptr 362h
seg000:000000000000015B
seg000:0000000000000160 58                            pop     rax
seg000:0000000000000161 5A                            pop     rdx
seg000:0000000000000162 5F                            pop     rdi
seg000:0000000000000163 5E                            pop     rsi
seg000:0000000000000164 5B                            pop     rbx
seg000:0000000000000165 8B 4D FC                      mov     ecx, [rbp-4]
seg000:0000000000000168 33 CD                         xor     ecx, ebp
seg000:000000000000016A E8 C3 02 00 00                call    near ptr 432h
seg000:000000000000016A
seg000:000000000000016F 81 C4 34 01 00 00             add     esp, 134h
seg000:0000000000000175 3B EC                         cmp     ebp, esp
seg000:0000000000000177 E8 46 02 00 00                call    near ptr 3C2h
seg000:0000000000000177
seg000:000000000000017C 8B E5                         mov     esp, ebp
seg000:000000000000017E 5D                            pop     rbp
seg000:000000000000017E
seg000:000000000000017E                               sub_0 endp ; sp-analysis failed
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主要操作即为  ： ^key[i%4]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再回到主函数，后面就没有天堂之门了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按顺序写一下解密函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main()
{
    DWORD key[] = { 4 ,119 ,130 ,-182 };
    DWORD delta = 0x5df966ae;
    unsigned char flag[]={0xAA, 0x4F, 0x0F, 0xE2, 0xE4, 0x41, 0x99, 0x54, 0x2C, 0x2B, 0x84, 0x7E, 0xBC, 0x8F, 0x8B, 0x78, 0xD3, 0x73, 0x88, 0x5E, 0xAE, 0x47, 0x85, 0x70, 0x31, 0xB3, 0x09, 0xCE, 0x13, 0xF5, 0x0D, 0xCA};
    DWORD* pDwordFlag = (DWORD*)flag;
    unsigned long long* pQwordFlag = (unsigned long long*)flag;
    for (int i = 0; i &amp;lt; 32; i++)
    {
        flag[i] ^= key[i % 4];
    }

    pQwordFlag = (unsigned long long*)flag;
    *(pQwordFlag + 0) = (*(pQwordFlag + 0) &amp;gt;&amp;gt; 12) | (*(pQwordFlag + 0) &amp;lt;&amp;lt; (64 - 12));
    *(pQwordFlag + 1) = (*(pQwordFlag + 1) &amp;gt;&amp;gt; 34) | (*(pQwordFlag + 1) &amp;lt;&amp;lt; (64 - 34));
    *(pQwordFlag + 2) = (*(pQwordFlag + 2) &amp;gt;&amp;gt; 56) | (*(pQwordFlag + 2) &amp;lt;&amp;lt; (64 - 56));
    *(pQwordFlag + 3) = (*(pQwordFlag + 3) &amp;gt;&amp;gt; 14) | (*(pQwordFlag + 3) &amp;lt;&amp;lt; (64 - 14));

    delta = 0x5df966ae;

    delta += 0xdeadbeef;  //0x3CA7259D

    for (int i = 0; i &amp;lt; 8; i++)
    {
        DWORD tmp = pDwordFlag[i] ^ delta;
        pDwordFlag[i] -= delta;
        delta = tmp;
    }

    printf(&amp;quot;flag:DASCTF{%s}&amp;quot;, flag);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;DASCTF{6cc1e44811647d38a15017e389b3f704}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">[ 西湖论剑2023 Quals ] Reverse WriteUp（1）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/hui-bian-zhi-ling-dui-ying-ji-qi-ma-lie-biao/"" data-c="
          &lt;h2 id=&#34;总结以下机器码列表方便做题时进行查找&#34;&gt;总结以下机器码列表，方便做题时进行查找&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;指令集依照机器操作码、汇编助记符和汇编操作数来描述指令，遵循下列约定：
l     reg8: 8位寄存器。
l     reg16: 16位寄存器。   例：ax，bx
l     mem8: 8位内存数值。
l     mem16: 16位内存数值。  例：0123H
l     immed8: 8位立即数值。
l     immed16: 16位立即数值。
l     immed32: 32位立即数值。
l     segReg: 16位段寄存器。     CS DS SS ES

立即数——用数字文本表达式
寄存器操作数——使用 CPU 内已命名的寄存器
内存操作数——引用内存位置

机器操作码
 汇编助记符和操作数
 
00
 ADD reg8/8位内存数值,reg8
 
01
 ADD reg16/16位内存数值,reg16
 
02
 ADD reg8,reg8/8位内存数值
 
03
 ADD reg16,reg16/16位内存数值
 
04
 ADD AL,8位立即数值
 
05
 ADD AX,16位立即数值
 
06
 PUSH es
 
07
 POP es
 
08
 OR reg8/8位内存数值,reg8
 
09
 OR reg16/16位内存数值,reg16
 
0A
 OR reg8,reg8/8位内存数值
 
0B
 OR reg16,reg16/16位内存数值
 
0C
 OR al,8位立即数值
 
0D
 OR ax,16位立即数值
 
0E
 PUSH cs
 
0F
 Not used
 
10
 ADC reg8/8位内存数值,reg8
 
11
 ADC reg16/16位内存数值,reg16
 
12
 ADC reg8,reg8/8位内存数值
 
13
 ADC reg16,reg16/16位内存数值
 
14
 ADC al,8位立即数值
 
15
 ADC ax,16位立即数值
 
16
 PUSH ss
 
17
 POP ss
 
18
 SBB reg8/8位内存数值,reg8
 
19
 SBB reg16/16位内存数值,reg16
 
1A
 SBB reg8,reg8/8位内存数值
 
1B
 SBB reg16,reg16/16位内存数值
 
1C
 SBB al,8位立即数值
 
1D
 SBB ax,16位立即数值
 
1E
 PUSH ds
 
1F
 POP ds
 
20
 AND reg8/8位内存数值,reg8
 
21
 AND reg16/16位内存数值,reg16
 
22
 AND reg8,reg8/8位内存数值
 
23
 AND reg16,reg16/16位内存数值
 
24
 AND al,8位立即数值
 
25
 AND ax,16位立即数值
 
26
 Segment override
 
27
 DAA
 
28
 SUB reg8/8位内存数值,reg8
 
29
 SUB reg16/16位内存数值,reg16
 
2A
 SUB reg8,reg8/8位内存数值
 
2B
 SUB reg16,reg16/16位内存数值
 
2C
 SUB al,8位立即数值
 
2D
 SUB ax,16位立即数值
 
2E
 Segment override
 
2F
 DAS
 
30
 XOR reg8/8位内存数值,reg8
 
31
 XOR reg16/16位内存数值,reg16
 
32
 XOR reg8,reg8/8位内存数值
 
33
 XOR reg16,reg16/16位内存数值
 
34
 XOR al,8位立即数值
 
35
 XOR ax,16位立即数值
 
36
 Segment override
 
37
 AAA
 
38
 CMP reg8/8位内存数值,reg8
 
39
 CMP reg16/16位内存数值,reg16
 
3A
 CMP reg8,reg8/8位内存数值
 
3B
 CMP reg16,reg16/16位内存数值
 
3C
 CMP al,8位立即数值
 
3D
 CMP ax,16位立即数值
 
3E
 Segment override
 
3F
 AAS
 
40
 INC ax
 
41
 INC cx
 
42
 INC dx
 
43
 INC bx
 
44
 INC sp
 
45
 INC bp
 
46
 INC si
 
47
 INC di
 
48
 DEC ax
 
49
 DEC cx
 
4A
 DEC dx
 
4B
 DEC bx
 
4C
 DEC sp
 
4D
 DEC bp
 
4E
 DEC si
 
4F
 DEC di
 
50
 PUSH ax
 
51
 PUSH cx
 
52
 PUSH dx
 
53
 PUSH bx
 
54
 PUSH sp
 
55
 PUSH bp
 
56
 PUSH si
 
57
 PUSH di
 
58
 POP ax
 
59
 POP cx
 
5A
 POP dx
 
5B
 POP bx
 
5C
 POP sp
 
5D
 POP bp
 
5E
 POP si
 
5F
 POP di
 
60
 PUSHA
 
61
 POPA
 
62
 BOUND reg16/16位内存数值,reg16
 
63
 Not used
 
64
 Not used
 
65
 Not used
 
66
 Not used
 
67
 Not used
 
68
 PUSH 16位立即数值
 
69
 IMUL reg16/16位内存数值,16位立即数值
 
6A
 PUSH 8位立即数值
 
6B
 IMUL reg8/8位内存数值,8位立即数值
 
6C
 INSB
 
6D
 INSW
 
6E
 OUTSB
 
6F
 OUTSW
 
70
 JO 8位立即数值
 
71
 JNO 8位立即数值
 
72
 JB 8位立即数值
 
73
 JNB 8位立即数值
 
74
 JZ 8位立即数值
 
75
 JNZ 8位立即数值
 
76
 JBE 8位立即数值
 
77
 JA 8位立即数值
 
78
 JS 8位立即数值
 
79
 JNS 8位立即数值
 
7A
 JP 8位立即数值
 
7B
 JNP 8位立即数值
 
7C
 JL 8位立即数值
 
7D
 JNL 8位立即数值
 
7E
 JLE 8位立即数值
 
7F
 JG 8位立即数值
 
80
 Table2 reg8
 
81
 Table2 reg16
 
82
 Table2 reg8
 
83
 Table2 reg8, reg16
 
84
 TEST reg8/8位内存数值,reg8
 
85
 TEST reg16/16位内存数值,reg16
 
86
 XCHG reg8,reg8
 
87
 XCHG reg16,reg16
 
88
 MOV reg8/8位内存数值,reg8
 
89
 MOV reg16/16位内存数值,reg16
 
8A
 MOV reg8,reg8/8位内存数值
 
8B
 MOV reg16,reg16/16位内存数值
 
8C
 MOV reg16/16位内存数值,16位段寄存器
 
8D
 LEA reg16,reg16/16位内存数值
 
8E
 MOV 16位段寄存器,reg16/16位内存数值
 
8F
 POP reg16/16位内存数值
 
90
 NOP
 
91
 XCHG ax,cx
 
92
 XCHG ax,dx
 
93
 XCHG ax,bx
 
94
 XCHG ax,sp
 
95
 XCHG ax,bp
 
96
 XCHG ax,si
 
97
 XCHG ax,di
 
98
 CBW 99CWD
 
9A
 CALL 32位立即数值
 
9B
 WAIT
 
9C
 PUSHF
 
9D
 POPF
 
9E
 SAHF
 
9F
 LAHF
 
A0
 MOV al,[8位内存数值]
 
A1
 MOV ax,[16位内存数值]
 
A2
 MOV [8位内存数值],al
 
A3
 MOV [16位内存数值],ax
 
A4
 MOVSB
 
A5
 MOVSW
 
A6
 CMPSB
 
A7
 CMPSW
 
A8
 TEST al,[8位内存数值]
 
A9
 TEST ax,[16位内存数值]
 
AA
 STOSB
 
AB
 STOSW
 
AC
 LODSB
 
AD
 LODSW
 
AE
 SCASB
 
AF
 SCASW
 
B0
 MOV al,8位立即数值
 
B1
 MOV cl,8位立即数值
 
B2
 MOV dl,8位立即数值
 
B3
 MOV bl,8位立即数值
 
B4
 MOV ah,8位立即数值
 
B5
 MOV ch,8位立即数值
 
B6
 MOV dh,8位立即数值
 
B7
 MOV bh,8位立即数值
 
B8
 MOV ax,16位立即数值
 
B9
 MOV cx,16位立即数值
 
BA
 MOV dx,16位立即数值
 
BB
 MOV bx,16位立即数值
 
BC
 MOV sp,16位立即数值
 
BD
 MOV bp,16位立即数值
 
BE
 MOV si,16位立即数值
 
BF
 MOV di,16位立即数值
 
C0
 Table1 reg8
 
C1
 Table1 reg8, reg16
 
C2
 RET 16位立即数值
 
C3
 RET
 
C4
 LES reg16/16位内存数值,16位内存数值
 
C5
 LDS reg16/16位内存数值,16位内存数值
 
C6
 MOV reg8/8位内存数值,8位立即数值
 
C7
 MOV reg16/16位内存数值,16位立即数值
 
C8
 ENTER 16位立即数值, 8位立即数值
 
C9
 LEAVE
 
CA
 RET 16位立即数值
 
CB
 RET
 
CC
 INT 3
 
CD
 INT 8位立即数值
 
CE
 INTO
 
CF
 IRET
 
D0
 Table1 reg8
 
D1
 Table1 reg16
 
D2
 Table1 reg8
 
D3
 Table1 reg16
 
D4
 AAM
 
D5
 AAD
 
D6
 Not used
 
D7
 XLAT [bx]
 
D8
 ESC 8位立即数值
 
D9
 ESC 8位立即数值
 
DA
 ESC 8位立即数值
 
DB
 ESC 8位立即数值
 
DC
 ESC 8位立即数值
 
DD
 ESC 8位立即数值
 
DE
 ESC 8位立即数值
 
DF
 ESC 8位立即数值
 
E0
 LOOPNE 8位立即数值
 
E1
 LOOPE 8位立即数值
 
E2
 LOOP 8位立即数值
 
E3
 JCXZ 8位立即数值
 
E4
 IN al,8位立即数值
 
E5
 IN ax,16位立即数值
 
E6
 OUT al,8位立即数值
 
E7
 OUT ax,16位立即数值
 
E8
 CALL 16位立即数值
 
E9
 JMP 16位立即数值
 
EA
 JMP 32位立即数值
 
EB
 JMP 8位立即数值
 
EC
 IN al,dx
 
ED
 IN ax,dx
 
EE
 OUT al,dx
 
EF
 OUT ax,dx
 
F0
 LOCK
 
F1
 Not used
 
F2
 REPNE
 
F3
 REP
 
F4
 HLT
 
F5
 CMC
 
F6
 Table3 reg8
 
F7
 Table3 reg16
 
F8
 CLC
 
F9
 STC
 
FA
 CLI
 
FB
 STI
 
FC
 CLD
 
FD
 STD
 
FE
 Table4 reg8
 
FF
 Table4 reg16        其中一种   jmp ax    FF E0
                               jmp bx    FF E3

&lt;/code&gt;&lt;/pre&gt;
">汇编指令对应机器码列表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/di-liu-jie-an-xun-bei-reverse-writeup/"" data-c="
          &lt;h2 id=&#34;一-你见过蓝色的小鲸鱼&#34;&gt;一. 你见过蓝色的小鲸鱼&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;找到关键加密函数：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;CHAR *__cdecl sub_4577E0(HWND hDlg)
{
  CHAR *result; // eax
  CHAR *v2; // [esp+10h] [ebp-154h]
  void *v3; // [esp+24h] [ebp-140h]
  CHAR *v4; // [esp+114h] [ebp-50h]
  CHAR *lpString; // [esp+120h] [ebp-44h]
  HWND DlgItem; // [esp+12Ch] [ebp-38h]
  HWND hWnd; // [esp+138h] [ebp-2Ch]
  int v8; // [esp+144h] [ebp-20h]
  int WindowTextLengthA; // [esp+150h] [ebp-14h]

  __CheckForDebuggerJustMyCode(&amp;amp;unk_52105E);
  hWnd = GetDlgItem(hDlg, 1003);
  DlgItem = GetDlgItem(hDlg, 1004);
  WindowTextLengthA = GetWindowTextLengthA(hWnd);
  v8 = GetWindowTextLengthA(DlgItem);
  lpString = (CHAR *)j__malloc(__CFADD__(WindowTextLengthA, 16) ? -1 : WindowTextLengthA + 16);
  result = (CHAR *)j__malloc(__CFADD__(v8, 16) ? -1 : v8 + 16);
  v4 = result;
  if ( lpString &amp;amp;&amp;amp; result )
  {
    GetWindowTextA(hWnd, lpString, WindowTextLengthA + 16);
    GetWindowTextA(DlgItem, v4, v8 + 16);
    v3 = operator new(0x10u);
    if ( v3 )
    {
      sub_451B43(0x10u);
      v2 = (CHAR *)sub_450CE3(v3);
    }
    else
    {
      v2 = 0;
    }
    sub_44FC2B(&amp;amp;unk_51D38C, 0x10u);
    sub_45126F(lpString, WindowTextLengthA, (int)v4, v8);
    sub_450199(v2);
    j__free(lpString);
    j__free(v4);
    result = v2;
    if ( v2 )
      return (CHAR *)sub_44F77B(1);
  }
  return result;
}


int __thiscall sub_4571A0(int this, void *Src, size_t a3, void *a4, size_t a5)
{
  const void *v5; // eax
  int result; // eax
  size_t v7; // [esp-4h] [ebp-12Ch]
  int v8; // [esp+10h] [ebp-118h]

  __CheckForDebuggerJustMyCode(&amp;amp;unk_52102F);
  if ( operator new(0x2Cu) )
  {
    sub_451A4E(0x2Cu);
    v8 = sub_450CBB(Src, a3);
  }
  else
  {
    v8 = 0;
  }
  sub_4521B5(&amp;amp;unk_51C048, &amp;amp;unk_51C000);
  sub_451F08(a4, a5);
  *(_DWORD *)(this + 12) = sub_44FEF6(v8);
  *(_DWORD *)(this + 4) = j_unknown_libname_47(*(_DWORD *)(this + 12));
  v7 = *(_DWORD *)(this + 12);
  v5 = (const void *)sub_4505A4(v8);
  j__memmove(*(void **)(this + 4), v5, v7);
  result = v8;
  if ( v8 )
    return sub_44FF0A(1);
  return result;
}


sub_4521B5(&amp;amp;unk_51C048, &amp;amp;unk_51C000);//两个都是blowfish的表
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现为blowfish加密，密钥就是题目用户名（blowfish密钥不定长）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在线网站解密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QHRoZWJsdWVmMXNo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;也可以脚本解密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from Crypto.Cipher import Blowfish
key=b&#39;UzBtZTBuZV9EMGcz&#39;
bf=Blowfish.new(key,Blowfish.MODE_ECB)
enc=b&amp;quot;\x11\xA5\x1F\x04\x95\x50\xE2\x50\x8F\x17\xE1\x6C\xF1\x63\x2B\x47&amp;quot;
print(bf.decrypt(enc))
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;则有：&lt;em&gt;&lt;strong&gt;D0g3{UzBtZTBuZV9EMGczQHRoZWJsdWVmMXNo}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-感觉有点点简单&#34;&gt;二. 感觉有点点简单&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简单题，RC4魔改加base64魔改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;__int64 sub_1400016F0()
{
  __int64 v1; // [rsp+20h] [rbp-78h] BYREF
  PVOID NumberOfBytes_4; // [rsp+28h] [rbp-70h]
  PVOID P; // [rsp+30h] [rbp-68h]
  __int64 v4; // [rsp+38h] [rbp-60h]
  __int64 v5; // [rsp+40h] [rbp-58h]
  __int64 v6; // [rsp+48h] [rbp-50h] BYREF
  const char *v7; // [rsp+50h] [rbp-48h]
  const char *v8; // [rsp+58h] [rbp-40h]
  struct _UNICODE_STRING DestinationString; // [rsp+60h] [rbp-38h] BYREF
  char v10[40]; // [rsp+70h] [rbp-28h] BYREF

  HIDWORD(v1) = 4096;
  memset(&amp;amp;v6, 0, sizeof(v6));
  RtlInitUnicodeString(&amp;amp;DestinationString, L&amp;quot;\\??\\C:\\Users\\Public\\flag.txt&amp;quot;);
  NumberOfBytes_4 = ExAllocatePool(NonPagedPool, 0x1000ui64);
  P = ExAllocatePool(NonPagedPool, 0x1000ui64);
  if ( NumberOfBytes_4 &amp;amp;&amp;amp; P )
  {
    v4 = HIDWORD(v1);
    memset(P, 0, HIDWORD(v1));
    v5 = HIDWORD(v1);
    memset(NumberOfBytes_4, 0, HIDWORD(v1));
    qmemcpy(v10, &amp;amp;DestinationString, 0x10ui64);
    LOBYTE(v1) = sub_140001040(v10, v6, NumberOfBytes_4, (char *)&amp;amp;v1 + 4);
    if ( (_BYTE)v1 )
    {
      if ( HIDWORD(v1) &amp;lt;= 0xC00 )
      {
        sub_1400011F0(NumberOfBytes_4, HIDWORD(v1), &amp;quot;the_key_&amp;quot;, 8i64, v1);
        sub_140001360((__int64)P, (__int64)NumberOfBytes_4, SHIDWORD(v1));
        LOBYTE(v1) = sub_140001560((__int64)P, 56);
        v8 = &amp;quot;tips: YES, RIGHT FLAG.   you got it!&amp;quot;;
        v7 = &amp;quot;tips: NO , WRONG ANSWER. try again !&amp;quot;;
        if ( (_BYTE)v1 )
          DbgPrint(&amp;quot;tips: %s\n&amp;quot;, v8);
        else
          DbgPrint(&amp;quot;tips: %s\n&amp;quot;, v7);
      }
      else
      {
        DbgPrint(&amp;quot;tips: file to long \n&amp;quot;);
      }
    }
    else
    {
      DbgPrint(&amp;quot;tips: can not read|open file\n&amp;quot;);
    }
  }
  else
  {
    DbgPrint(&amp;quot;tips: can not malloc\n&amp;quot;);
  }
  if ( NumberOfBytes_4 )
  {
    ExFreePoolWithTag(NumberOfBytes_4, 0);
    NumberOfBytes_4 = 0i64;
  }
  if ( P )
  {
    ExFreePoolWithTag(P, 0);
    P = 0i64;
  }
  return 0i64;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RC4魔改：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall sub_1400011F0(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4)
{
  __int64 result; // rax
  unsigned __int8 v5; // [rsp+20h] [rbp-18h]
  unsigned __int8 v6; // [rsp+21h] [rbp-17h]
  unsigned int i; // [rsp+24h] [rbp-14h]

  v5 = 0;
  v6 = 0;
  sub_1400015B0(a3, a4);
  for ( i = 0; ; ++i )
  {
    result = a2;
    if ( i &amp;gt;= a2 )
      break;
    v5 = (v5 + 1) % 64;
    v6 = (byte_140003010[v5] + v6) % 64;
    sub_1400018E0(&amp;amp;byte_140003010[v5], &amp;amp;byte_140003010[v6]);
    *(_BYTE *)(a1 + i) ^= (v6 ^ v5) &amp;amp; byte_140003010[(unsigned __int8)(((v6 ^ v5)
                                                                      + byte_140003010[v6]
                                                                      + byte_140003010[v5])
                                                                     % 64)];
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;base64魔改：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall sub_140001360(__int64 a1, __int64 a2, int a3)
{
  int v4; // [rsp+0h] [rbp-88h]
  int v5; // [rsp+4h] [rbp-84h]
  char v6[80]; // [rsp+10h] [rbp-78h] BYREF

  strcpy(v6, &amp;quot;4KBbSzwWClkZ2gsr1qA+Qu0FtxOm6/iVcJHPY9GNp7EaRoDf8UvIjnL5MydTX3eh&amp;quot;);
  v4 = 0;
  v5 = 0;
  while ( v4 &amp;lt; a3 )
  {
    *(_BYTE *)(a1 + v5) = v6[*(_BYTE *)(a2 + v4) &amp;amp; 0x3F];
    *(_BYTE *)(a1 + v5 + 1) = v6[(4 * (*(_BYTE *)(a2 + v4 + 1) &amp;amp; 0xF)) | ((*(_BYTE *)(a2 + v4) &amp;amp; 0xC0) &amp;gt;&amp;gt; 6)];
    *(_BYTE *)(a1 + v5 + 2) = v6[(16 * (*(_BYTE *)(a2 + v4 + 2) &amp;amp; 3)) | ((*(_BYTE *)(a2 + v4 + 1) &amp;amp; 0xF0) &amp;gt;&amp;gt; 4)];
    *(_BYTE *)(a1 + v5 + 3) = v6[(*(_BYTE *)(a2 + v4 + 2) &amp;amp; 0xFC) &amp;gt;&amp;gt; 2];
    v4 += 3;
    v5 += 4;
  }
  if ( a3 % 3 == 1 )
  {
    *(_BYTE *)(a1 + v5 - 2) = 61;
    *(_BYTE *)(a1 + v5 - 1) = 61;
  }
  else if ( a3 % 3 == 2 )
  {
    *(_BYTE *)(a1 + v5 - 1) = 61;
  }
  return 0i64;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检验：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool __fastcall sub_140001560(__int64 a1, int a2)
{
  return a2 == 56 &amp;amp;&amp;amp; !(unsigned int)sub_1400019F0(a1, &amp;quot;6zviISn2McHsa4b108v29tbKMtQQXQHA+2+sTYLlg9v2Q2Pq8SP24Uw=&amp;quot;, 56i64);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写脚本：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def KSA(key):
    key_length = len(key)
    S = list(range(64))
    j = 0
    for i in range(64):
        j = (j + S[i] + key[i % key_length]) % 64
        S[i], S[j] = S[j], S[i]
    return S


def PRGA(S):
    i = 0
    j = 0
    while True:
        i = (i + 1) % 64
        j = (j + S[i]) % 64
        S[i], S[j] = S[j], S[i]
        K = (i^j) &amp;amp; S[(((i^j)+S[i] + S[j]) % 64)]
        yield K


def RC4(key):
    S = KSA(key)
    keystream = PRGA(S)
    return keystream


if __name__ == &#39;__main__&#39;:
    key = &#39;the_key_&#39;
    c = &#39;6zviISn2McHsa4b108v29tbKMtQQXQHA+2+sTYLlg9v2Q2Pq8SP24Uw4&#39;
    table = &#39;4KBbSzwWClkZ2gsr1qA+Qu0FtxOm6/iVcJHPY9GNp7EaRoplaintextf8UvIjnL5MyplaintextTX3eh&#39;

    # c = c.replace(&#39;=&#39;, table[0])
    plaintext = []
    for i in range(0, len(c), 4):
        x = [table.inplaintextex(j) for j in c[i: i + 4]]
        plaintext.append(x[0] | ((x[1] &amp;amp; 3) &amp;lt;&amp;lt; 6))
        plaintext.append((x[1] &amp;gt;&amp;gt; 2) | ((x[2] &amp;amp; 0xf) &amp;lt;&amp;lt; 4))
        plaintext.append((x[2] &amp;gt;&amp;gt; 4) | (x[3] &amp;lt;&amp;lt; 2))
    print(plaintext)
    key = key.encode()
    keystream = RC4(key)
    ciphertext = []
    for b in plaintext:
        ciphertext.append(chr(b ^ next(keystream)))
    print(&amp;quot;&amp;quot;.join(ciphertext))
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;D0g3{608292C4-15400BA4-B3299A5C-704C292D}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意：可以把原密文最后的等号直接替换成table[0]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-牢大想你了&#34;&gt;三. 牢大想你了&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接反编译**&amp;quot;\GalgamePro_BackUpThisFolder_ButDontShipItWithYourGame\Managed\Assembly-CSharp.dll&amp;quot;**&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;	public void OnValueChanged(string ABBAAAABBBBAAABABBBABAAABAABAABBABBBBABAABAABAB)
	{
		uint[] str = new uint[]
		{
			286331153U,
			286331153U,
			286331153U,
			286331153U
		};
		byte[] strBytes = Encoding.UTF8.GetBytes(ABBAAAABBBBAAABABBBABAAABAABAABBABBBBABAABAABAB);
		int paddingCount = 8 - strBytes.Length % 8;
		byte[] paddedArray = new byte[strBytes.Length + paddingCount];
		Array.Copy(strBytes, paddedArray, strBytes.Length);
		uint[] uintArray = new uint[paddedArray.Length / 4];
		Buffer.BlockCopy(paddedArray, 0, uintArray, 0, paddedArray.Length);
		uint[] encryptedData = new uint[0];
		AAABAAABABABAAABBABBABAAAABBAABBAABABBBBBABAAAB str2 = new AAABAAABABABAAABBABBABAAAABBAABBAABABBBBBABAAAB(str);
		for (int i = 0; i &amp;lt; uintArray.Length; i += 2)
		{
			encryptedData = encryptedData.Concat(str2.BABBBBBBAAAAAABABBBAAAABBABBBAABABAAABABBAAABBA(uintArray[i], uintArray[i + 1])).ToArray&amp;lt;uint&amp;gt;();
		}
		uint[] array = new uint[]
		{
			3363017039U,
			1247970816U,
			549943836U,
			445086378U,
			3606751618U,
			1624361316U,
			3112717362U,
			705210466U,
			3343515702U,
			2402214294U,
			4010321577U,
			2743404694U
		};
		MonoBehaviour.print(array);
		if (array.SequenceEqual(encryptedData))
		{
			this.BBBAAAAABABABABBABAAAAABBABBAABBABABABABBBABAAB = 5;
			this.ABAABAAABABABABABBBBBAAABBAABBBBBAABAAAABBABABB(&amp;quot;port&amp;quot;);
			this.BAABAABBABABABABBBABBBBABBBBBBBABABBAABBABABABB(&amp;quot;牢大&amp;quot;);
			this.AAAABBABAAAABBAABAABAABAABBBAAABBBABBBBBAABABBA(&amp;quot;哈哈，我没有变成耐摔王&amp;quot;);
			return;
		}
		this.BBBAAAAABABABABBABAAAAABBABBAABBABABABABBBABAAB = 5;
		this.ABAABAAABABABABABBBBBAAABBAABBBBBAABAAAABBABABB(&amp;quot;耐摔王&amp;quot;);
		this.BAABAABBABABABABBBABBBBABBBBBBBABABBAABBABABABB(&amp;quot;狂暴牢大&amp;quot;);
		this.AAAABBABAAAABBAABAABAABAABBBAAABBBABBBBBAABABBA(&amp;quot;获得成就“耐摔王”&amp;quot;);
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到关键加密函数：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;	// Token: 0x060000AA RID: 170 RVA: 0x000058FC File Offset: 0x00003AFC
	public uint[] BABBBBBBAAAAAABABBBAAAABBABBBAABABAAABABBAAABBA(uint ABBAABAAAAAABAAAABBBBBBABAABAAAABBBABBBAABBABBA, uint BAABBAAAAABABBAABBABBAABABABABABABAAABABBBABABA)
	{
		uint v0 = ABBAABAAAAAABAAAABBBBBBABAABAAAABBBABBBAABBABBA;
		uint v = BAABBAAAAABABBAABBABBAABABABABABABAAABABBBABABA;
		uint sum = 0U;
		uint delta = 2654435769U;
		uint[] str2 = this.BBABABBBABBABABAAABBBAABBAAAAAAABBBBBAABBAAAAAA;
		for (int i = 0; i &amp;lt; 32; i++)
		{
			sum += delta;
			v0 += ((v &amp;lt;&amp;lt; 4) + str2[0] ^ v + sum ^ (v &amp;gt;&amp;gt; 5) + str2[1]);
			v += ((v0 &amp;lt;&amp;lt; 4) + str2[2] ^ v0 + sum ^ (v0 &amp;gt;&amp;gt; 5) + str2[3]);
		}
		return new uint[]
		{
			v0,
			v
		};
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些混淆不去也罢，也能看懂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tea，直接套脚本解密：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ctypes import *

def decrypt(v, k):
    v0 = c_uint32(v[0])
    v1 = c_uint32(v[1])
    delta = 2654435769
    sum1 = c_uint32(delta*32)
    for i in range(32):
        v1.value -= ((v0.value &amp;lt;&amp;lt; 4) + k[2]) ^ (v0.value + sum1.value) ^ ((v0.value &amp;gt;&amp;gt; 5) + k[3])
        v0.value -= ((v1.value &amp;lt;&amp;lt; 4) + k[0]) ^ (v1.value + sum1.value) ^ ((v1.value &amp;gt;&amp;gt; 5) + k[1])
        sum1.value -= delta
    return v0.value.to_bytes(4,&#39;little&#39;)+v1.value.to_bytes(4,&#39;little&#39;)


if __name__ == &#39;__main__&#39;:
    a=[3363017039,1247970816]
    a1=[549943836,445086378]
    a2=[3606751618,1624361316]
    a3=[3112717362,705210466]
    a4=[3343515702,2402214294]
    a5=[4010321577,2743404694]
    k=[286331153, 286331153, 286331153, 286331153]
    res= decrypt(a, k)+decrypt(a1,k)+decrypt(a2,k)+decrypt(a3,k)+decrypt(a4,k)+decrypt(a5,k)
    print(&amp;quot;解密后数据:&amp;quot;, res)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;D0g3{it_is_been_a_long_day_without_you_my_friend}&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四-mobilego&#34;&gt;四. mobilego&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MainActivity如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.example.mobilego;

import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;
import androidx.appcompat.app.AppCompatActivity;
import game.Game;

/* loaded from: classes3.dex */
public class MainActivity extends AppCompatActivity {
    private Button button;
    private EditText editText;

    /* JADX INFO: Access modifiers changed from: protected */
    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        this.editText = (EditText) findViewById(R.id.editText);
        Button button = (Button) findViewById(R.id.button);
        this.button = button;
        button.setOnClickListener(new View.OnClickListener() { // from class: com.example.mobilego.MainActivity$$ExternalSyntheticLambda0
            @Override // android.view.View.OnClickListener
            public final void onClick(View view) {
                MainActivity.this.m44lambda$onCreate$0$comexamplemobilegoMainActivity(view);
            }
        });
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* renamed from: lambda$onCreate$0$com-example-mobilego-MainActivity  reason: not valid java name */
    public /* synthetic */ void m44lambda$onCreate$0$comexamplemobilegoMainActivity(View v) {
        if (Game.checkflag(this.editText.getText().toString()).equals(getResources().getString(R.string.cmp))) {
            Toast.makeText(this, &amp;quot;yes your flag is right&amp;quot;, 0).show();
        } else {
            Toast.makeText(this, &amp;quot;No No No&amp;quot;, 0).show();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意checkflag函数为native函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;frida简单调试一下，发现是一个替换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;cmp=&#39;49021}5f919038b440139g74b7Dc88330e5d{6&#39;
tmp=&#39;vIlDoLjtEpkCmyzfqbshucxwiAagKFBdGHJner&#39;
table=&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKL&#39;
flag=&#39;&#39;
for i in table:
    for j in tmp:
        if ord(i)==ord(j):
            flag+=cmp[tmp.index(j)]
        else:
            continue
print(flag)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;D0g3{4c3b5903d11461f94478b7302980e958}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;五-你好pe&#34;&gt;五. 你好PE&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl main_0(int argc, const char **argv, const char **envp)
{
  int v4; // [esp+4Ch] [ebp-10h] BYREF
  int v5; // [esp+50h] [ebp-Ch]
  LPVOID lpAddress; // [esp+54h] [ebp-8h]

  __CheckForDebuggerJustMyCode(&amp;amp;unk_51E018);
  v5 = 0;
  v4 = 0;
  lpAddress = (LPVOID)sub_450DF0();             // 获取资源文件
  if ( lpAddress )
  {
    v5 = sub_44E753(0, lpAddress, 1, &amp;amp;v4);      // 资源文件进行加密
    VirtualFree(lpAddress, 0, 0x8000u);
    return v4;
  }
  else
  {
    sub_44EA73(&amp;quot;find res failed\n&amp;quot;);
    return 0;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现对资源文件的加密操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跟进找资源文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl sub_455DB0(int a1, int a2, int a3, int a4)
{
  __CheckForDebuggerJustMyCode(&amp;amp;unk_51E02A);
  switch ( a1 )
  {
    case 0:
      return sub_4513F9(a2, a3 != 0, a4);
    case 1:
      sub_44F89C(a2);
      break;
    case 2:
      return sub_44F2A7(a2, a3);
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;_DWORD *__cdecl sub_455750(int a1, int a2, _DWORD *a3)
{
  void (__stdcall *v4)(_DWORD *); // [esp+4Ch] [ebp-10h]
  _DWORD *v5; // [esp+50h] [ebp-Ch]
  int v6; // [esp+58h] [ebp-4h]

  __CheckForDebuggerJustMyCode(&amp;amp;unk_51E02A);
  v6 = sub_450FAD();
  if ( v6 )
  {
    v5 = (_DWORD *)(*(int (__stdcall **)(int, int))(v6 + 24))(64, 28);
    if ( v5 )
    {
      v5[3] = v6;
      v5[4] = a2;
      v5[5] = 0;
      v5[6] = 0;
      if ( sub_44FCC5(v5, a1, a2) )
      {
        if ( a3 )
          *a3 = 0;
        return v5;
      }
      else
      {
        if ( a3 )
          *a3 = v5[6];
        v4 = *(void (__stdcall **)(_DWORD *))(v6 + 28);
        v4(v5);
        v4((_DWORD *)v6);
        return 0;
      }
    }
    else
    {
      if ( a3 )
        *a3 = 255;
      return 0;
    }
  }
  else
  {
    if ( a3 )
      *a3 = 255;
    return 0;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意到此处的a1就是资源文件起始地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跟进&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl sub_455870(_DWORD *a1, int a2, int a3)
{
  __CheckForDebuggerJustMyCode(&amp;amp;unk_51E02A);
  if ( !a1 || !a1[3] || !a2 )
    return 0;
  a1[6] = 0;
  if ( !sub_44FED7(a1, a2) )
    return 0;
  if ( !sub_44EB77(a1, a2) )
    return 0;
  if ( !sub_44F478(a1) )
    goto LABEL_17;
  if ( !sub_451057(a1) )
    goto LABEL_17;
  a1[2] = sub_450D69(0, *a1, a1[1]);
  if ( !sub_45016B(a1) )
    goto LABEL_17;
  if ( !sub_4509DB(a1) )
    return 0;
  if ( !a3 || sub_44ED5C(a1, 1) )
    return 1;
LABEL_17:
  sub_44EFD2(a1);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调试发现直到sub_44ED5C函数才出现输入flag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跟进&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl sub_3A4B40(_DWORD *a1, int a2)
{
  void (__cdecl *v3)(_DWORD, int, _DWORD); // [esp+4Ch] [ebp-8h]
  int v4; // [esp+50h] [ebp-4h]

  if ( !a1 || !*a1 )
    return 0;
  v4 = *(_DWORD *)(*a1 + 60) + *a1;
  if ( !*(_DWORD *)(v4 + 40) )
    return 0;
  v3 = (void (__cdecl *)(_DWORD, int, _DWORD))(*(_DWORD *)(v4 + 40) + *a1);
  if ( v3 )
  {
    v3(*a1, a2, 0);
    return 1;
  }
  else
  {
    a1[6] = 6;
    return 0;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实际上是v3对资源文件进行了改动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跟进找到加密函数：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int sub_1005F820()
{
  _DWORD *v1; // [esp+D0h] [ebp-8h]

  sub_1005B16F(&amp;amp;unk_1014000F);
  kernel32_VirtualAlloc(0, 65548, 12288, 4);
  v1 = (_DWORD *)sub_1005A260();
  if ( !v1 )
    return -1;
  v1[1] = 0x10000;
  *v1 = 0;
  v1[2] = v1 + 3;
  sub_10059572(v1[2], 0, v1[1]);
  ((void (__cdecl *)(const char *))unk_10058BC7)(&amp;quot;[out]: PLZ Input FLag \n&amp;quot;);
  ((void (__cdecl *)(const char *))unk_10058BC7)(&amp;quot;[in ]: &amp;quot;);
  ((void (__cdecl *)(void *, _DWORD))unk_100581A4)(&amp;amp;unk_10114B68, v1[2]);
  *v1 = sub_1005B5BB(v1[2]);
  if ( *v1 == 41 )
  {
    *v1 = 48;
    ((void (__cdecl *)(_DWORD *))unk_1005A242)(v1);
    if ( ((int (__cdecl *)(_DWORD, void *, int))unk_10058AA0)(v1[2], &amp;amp;unk_1013C008, 48) )
      ((void (__cdecl *)(const char *))unk_10058BC7)(&amp;quot;[out]: WRONG FLAG\n&amp;quot;);
    else
      ((void (__cdecl *)(const char *))unk_10058BC7)(&amp;quot;[out]: RIGHT FLAG\n&amp;quot;);
    kernel32_VirtualFree(v1, 0, 49152);
    sub_1005A260();
    return 0;
  }
  else
  {
    ((void (__cdecl *)(const char *))unk_10058BC7)(&amp;quot;[out]: len error\n&amp;quot;);
    kernel32_VirtualFree(v1, 0, 49152);
    sub_1005A260();
    return -1;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把数据p完找到加密函数：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;_DWORD *__cdecl sub_1005F6F0(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ecx
  int j; // [esp+D0h] [ebp-30h]
  unsigned int i; // [esp+DCh] [ebp-24h]
  __int64 v5; // [esp+E8h] [ebp-18h]
  int *v6; // [esp+F8h] [ebp-8h]

  sub_1005B16F(&amp;amp;unk_1014000F);
  for ( i = 0; ; ++i )
  {
    result = a1;
    if ( i &amp;gt;= *a1 &amp;gt;&amp;gt; 3 )
      break;
    v6 = (int *)(a1[2] + 8 * i);
    v2 = *v6;
    v5 = *(_QWORD *)v6;
    for ( j = 0; j &amp;lt; 64; ++j )
    {
      LOBYTE(v2) = 1;
      if ( v5 &amp;lt; 0 )
        v5 = qword_1013C000 ^ sub_10059F9F(v2, HIDWORD(v5));
      else
        v5 = sub_10059F9F(v2, HIDWORD(v5));
    }
    *(_QWORD *)v6 = v5;
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意如下汇编代码:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;debug034:1005F738 mov     eax, [ebp+arg_0]
debug034:1005F73B mov     ecx, [eax+8]
debug034:1005F73E mov     edx, [ebp+var_24]
debug034:1005F741 lea     eax, [ecx+edx*8]
debug034:1005F744 mov     [ebp+var_8], eax
debug034:1005F747 mov     eax, [ebp+var_8]
debug034:1005F74A mov     ecx, [eax]
debug034:1005F74C mov     edx, [eax+4]
debug034:1005F74F mov     dword ptr [ebp+var_18], ecx
debug034:1005F752 mov     dword ptr [ebp+var_18+4], edx
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与伪代码有点区别&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt; LODWORD(v5) = *(_DWORD *)v6;    
 HIDWORD(v5) = v2;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;根据这个再去编写脚本（真的是坑www&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;Windows.h&amp;gt;
#include &amp;lt;windef.h&amp;gt;

int main()
{
    __int64 key = 0x54aa4a9;
    BYTE c[] = {
            0x4D,0xB8,0x76,0x29,0xF5,0xA9,0x9E,0x59,
            0x55,0x56,0xB1,0xC4,0x2F,0x21,0x2C,0x30,
            0xB3,0x79,0x78,0x17,0xA8,0xED,0xF7,0xDB,
            0xE1,0x53,0xF0,0xDB,0xE9,0x03,0x51,0x5E,
            0x09,0xC1,0x00,0xDF,0xF0,0x96,0xFC,0xC1,
            0xB5,0xE6,0x62,0x95,0x01,0x00,0x00,0x00,
    };
    __int64 v5;
    int j, i;
    for (i = 0; i &amp;lt; 6; i++)
    {
        v5 = *((__int64*)&amp;amp;c[i * 8]);
        for (j = 0; j &amp;lt; 64; j++)
        {
            if (v5 &amp;amp; 1)
            {
                v5 = ((unsigned __int64)v5 ^ key) &amp;gt;&amp;gt; 1;
                v5 |= 0x8000000000000000;

            }
            else
            {
                v5 = (unsigned __int64)v5 &amp;gt;&amp;gt; 1;
            }
        }
        *((__int64*)&amp;amp;c[i * 8]) = v5;
    }
    for (i = 0; i &amp;lt; 48; i++)
        printf(&amp;quot;%c&amp;quot;, c[i]);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还要补全符号位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;D0g3{60E1E72A-576A8BF0-7701CBB9-B02415EC}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意程序实现及脚本编写的细节！！！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
">第六届安洵杯 Reverse WriteUp</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/2019ciscn-chu-sai-strange-int/"" data-c="
          &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用 &lt;code&gt;file Image.bin&lt;/code&gt;查看文件类型，发现是DOS/MBR boot sector&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面简单记录一下&lt;em&gt;&lt;strong&gt;DOS分区体系的主引导记录扇区－MBR&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 DOS 分区体系时，磁盘的第一个扇区――也就是 0 号扇区被称为主引导记录扇区，也称为 MBR( 主引导记录， Master Boot Recorder －－ MBR) 。当计算机启动并完成自检后，首先会寻找磁盘的 MBR 扇区并读取其中的引导记录，然后将系统控制权交给它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MBR 由 446 个字节的引导代码、 64 个字节的主分区表及 2 个字节的签名值“ 55AA ”组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;***引导代码：***MBR 接管系统的控制权后，引导代码负责对其他代码信息进行检查（比如查看是否有“ 55AA ”有效标记）并进一步引导系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;分区表&lt;/strong&gt;&lt;/em&gt;：分区表负责描述磁盘内的分区情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;“ 55AA ”有效标志。&lt;/strong&gt;&lt;/em&gt;“ 55AA ”标志做为有效标志以通知系统该 MBR 扇区是否有效，如果该标志丢失或损坏，磁盘将会显示为“未初始化”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;放入010中找到此签名，那么前面的就是主引导扇区的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IDA将0-0x200的数据转换成汇编代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;seg000:0000 EA 05 00 C0 07                jmp     far ptr 7C0h:5
seg000:0000
seg000:0005                               ; ---------------------------------------------------------------------------
seg000:0005 8C C8                         mov     ax, cs
seg000:0007 8E D8                         mov     ds, ax
seg000:0009 8E D0                         mov     ss, ax
seg000:000B BC 00 04                      mov     sp, 400h
seg000:000E FC                            cld
seg000:000F B8 03 00                      mov     ax, 3
seg000:0012 CD 10                         int     10h                             ; - VIDEO - SET VIDEO MODE
seg000:0012                                                                       ; AL = mode
seg000:0012
seg000:0014 BA 00 00                      mov     dx, 0
seg000:0017 B9 02 00                      mov     cx, 2
seg000:001A B8 00 10                      mov     ax, 1000h
seg000:001D 8E C0                         mov     es, ax
seg000:001F                               assume es:nothing
seg000:001F 31 DB                         xor     bx, bx
seg000:0021 B8 28 02                      mov     ax, 228h
seg000:0024 CD 13                         int     13h                             ; DISK - READ SECTORS INTO MEMORY
seg000:0024                                                                       ; AL = number of sectors to read, CH = track, CL = sector
seg000:0024                                                                       ; DH = head, DL = drive, ES:BX -&amp;gt; buffer to fill
seg000:0024                                                                       ; Return: CF set on error, AH = status, AL = number of sectors read
seg000:0024
seg000:0026 73 02                         jnb     short loc_2A
seg000:0026
seg000:0028
seg000:0028                               loc_28:                                 ; CODE XREF: seg000:loc_28↓j
seg000:0028 EB FE                         jmp     short loc_28
seg000:0028
seg000:002A                               ; ---------------------------------------------------------------------------
seg000:002A
seg000:002A                               loc_2A:                                 ; CODE XREF: seg000:0026↑j
seg000:002A FA                            cli
seg000:002B B8 00 10                      mov     ax, 1000h
seg000:002E 8E D8                         mov     ds, ax
seg000:0030                               assume ds:nothing
seg000:0030 31 C0                         xor     ax, ax
seg000:0032 8E C0                         mov     es, ax
seg000:0034                               assume es:nothing
seg000:0034 B9 00 20                      mov     cx, 2000h
seg000:0037 29 F6                         sub     si, si
seg000:0039 29 FF                         sub     di, di
seg000:003B F3 A4                         rep movsb
seg000:003D B8 C0 07                      mov     ax, 7C0h
seg000:003D
seg000:0040
seg000:0040                               loc_40:                                 ; DATA XREF: seg000:0012↑r
seg000:0040 8E D8                         mov     ds, ax
seg000:0042                               assume ds:nothing
seg000:0042 0F 01 1E 6F 00                lidt    fword ptr ds:6Fh
seg000:0047 0F 01 16 75 00                lgdt    fword ptr ds:75h
seg000:0047
seg000:004C
seg000:004C                               loc_4C:                                 ; DATA XREF: seg000:0024↑r
seg000:004C B8 01 00                      mov     ax, 1
seg000:004F 0F 01 F0                      lmsw    ax
seg000:0052 EA 00 00 08 00                jmp     far ptr byte_80
seg000:0052
seg000:0052                               ; ---------------------------------------------------------------------------
seg000:0057 00 00 00 00 00 00 00 00 FF 07+db 8 dup(0), 0FFh, 7, 3 dup(0), 9Ah, 0C0h, 0, 0FFh, 7, 3 dup(0), 92h, 0C0h, 7 dup(0), 0FFh, 7, 57h, 7Ch
seg000:0057 00 00 00 9A C0 00 FF 07 00 00+db 7 dup(0)
seg000:0080 00 00 00 00 00 00 00 00 00 00+byte_80 db 17Eh dup(0), 55h, 0AAh       ; CODE XREF: seg000:0052↑J
seg000:0080 00 00 00 00 00 00 00 00 00 00+seg000 ends
seg000:0080 00 00 00 00 00 00 00 00 00 00+
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面分析上述汇编：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先主引导扇区的地址被加载到0x7c00，跳转到0x7c05&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后初始化段寄存器和栈指针，然后用int 10h 是bios中断设置显示模式，字符和字符串输出等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int 13h就是直接磁盘服务，下面是一些用法：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;1、功能 00H

功能描述：磁盘系统复位
入口参数：AH＝00H
DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘
出口参数：CF＝0——操作成功，AH＝00H，否则，AH＝状态代码，参见功能号01H中的说明

2、功能 01H

功能描述：读取磁盘系统状态
入口参数：AH＝01H
DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘
出口参数：AH＝00H，AL＝状态代码，其定义如下：
00H — 无错 01H — 非法命令
02H — 地址目标未发现 03H — 磁盘写保护(软盘)
04H — 扇区未发现 05H — 复位失败(硬盘)
06H — 软盘取出(软盘) 07H — 错误的参数表(硬盘)
08H — DMA越界(软盘) 09H — DMA超过64K界限
0AH — 错误的扇区标志(硬盘) 0BH — 错误的磁道标志(硬盘)
0CH — 介质类型未发现(软盘) 0DH — 格式化时非法扇区号(硬盘)
0EH — 控制数据地址目标被发现(硬盘) 0FH — DMA仲裁越界(硬盘)
10H — 不正确的CRC或ECC编码 11H — ECC校正数据错(硬盘)
　CRC:Cyclic Redundancy Check code
　ECC:Error Checking &amp;amp; Correcting code
20H — 控制器失败 40H — 查找失败
80H — 磁盘超时(未响应) AAH — 驱动器未准备好(硬盘)
BBH — 未定义的错误(硬盘) CCH — 写错误(硬盘)
E0H — 状态寄存器错(硬盘) FFH — 检测操作失败(硬盘)

3、功能 02H

功能描述：读扇区
入口参数：AH＝02H
AL＝扇区数
CH＝柱面
CL＝扇区
DH＝磁头
DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘
ES:BX＝缓冲区的地址
出口参数：CF＝0——操作成功，AH＝00H，AL＝传输的扇区数，否则，AH＝状态代码，参见功能号01H中的说明

4、功能 03H

功能描述：写扇区
入口参数：AH＝03H
AL＝扇区数
CH＝柱面
CL＝扇区
DH＝磁头
DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘
ES:BX＝缓冲区的地址
出口参数：CF＝0——操作成功，AH＝00H，AL＝传输的扇区数，否则，AH＝状态代码，参见功能号01H中的说明

5、功能 04H

功能描述：检验扇区
入口参数：AH＝04H
AL＝扇区数
CH＝柱面
CL＝扇区
DH＝磁头
DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘
ES:BX＝缓冲区的地址
出口参数：CF＝0——操作成功，AH＝00H，AL＝被检验的扇区数，否则，AH＝状态代码，参见功能号01H中的说明。

6、功能 05H

功能描述：格式化磁道
入口参数：AH＝05H
AL＝交替(Interleave)
CH＝柱面
DH＝磁头
DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘
ES:BX＝地址域列表的地址
出口参数：CF＝0——操作成功，AH＝00H，否则，AH＝状态代码，参见功能号01H中的说明。

7、功能 06H

功能描述：格式化坏磁道
入口参数：AH＝06H
AL＝交替
CH＝柱面
DH＝磁头
DL＝80H~0FFH：硬盘
ES:BX＝地址域列表的地址
出口参数：CF＝0——操作成功，AH＝00H，否则，AH＝状态代码，参见功能号01H中的说明

8、功能 07H

功能描述：格式化驱动器
入口参数：AH＝07H
AL＝交替
CH＝柱面
DL＝80H~0FFH：硬盘
出口参数：CF＝0——操作成功，AH＝00H，否则，AH＝状态代码，参见功能号01H中的说明

9、功能 08H

功能描述：读取驱动器参数
入口参数：AH＝08H
DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘
出口参数：CF＝1——操作失败，AH＝状态代码，参见功能号01H中的说明，否则，
BL＝
01H — 360K
＝02H — 1.2M
＝03H — 720K
＝04H — 1.44M
CH＝柱面数的低8位
CL的位7-6＝柱面数的该2位
CL的位5-0＝扇区数
DH＝磁头数
DL＝驱动器数
ES:DI＝磁盘驱动器参数表地址

10、功能 09H

功能描述：初始化硬盘参数
入口参数：AH＝09H
DL＝80H~0FFH：硬盘(还有有关参数表问题，在此从略)
出口参数：CF＝0——操作成功，AH＝00H，否则，AH＝状态代码，参见功能号01H中的说明

11、功能 0AH

功能描述：读长扇区，每个扇区随带四个字节的ECC编码
入口参数：AH＝0AH
AL＝扇区数
CH＝柱面
CL＝扇区
DH＝磁头
DL＝80H~0FFH：硬盘
ES:BX＝缓冲区的地址
出口参数：CF＝0——操作成功，AH＝00H，AL＝传输的扇区数，否则，AH＝状态代码，参见功能号01H中的说明

12、功能 0BH

功能描述：写长扇区，每个扇区随带四个字节的ECC编码
入口参数：AH＝0BH
AL＝扇区数
CH＝柱面
CL＝扇区
DH＝磁头
DL＝80H~0FFH：硬盘
ES:BX＝缓冲区的地址
出口参数：CF＝0——操作成功，AH＝00H，AL＝传输的扇区数，否则，AH＝状态代码，参见功能号01H中的说明

13、功能 0CH

功能描述：查寻
入口参数：AH＝0CH
CH＝柱面的低8位
CL(7-6位)＝柱面的高2位
DH＝磁头
DL＝80H~0FFH：硬盘
出口参数：CF＝0——操作成功，AH＝00H，否则，AH＝状态代码，参见功能号01H中的说明

14、功能 0DH

功能描述：硬盘系统复位
入口参数：AH＝0DH
DL＝80H~0FFH：硬盘
出口参数：CF＝0——操作成功，AH＝00H，否则，AH＝状态代码，参见功能号01H中的说明

15、功能 0EH

功能描述：读扇区缓冲区
入口参数：AH＝0EH
ES:BX＝缓冲区的地址
出口参数：CF＝0——操作成功，否则，AH＝状态代码，参见功能号01H中的说明

16、功能 0FH

功能描述：写扇区缓冲区
入口参数：AH＝0FH
ES:BX＝缓冲区的地址
出口参数：CF＝0——操作成功，否则，AH＝状态代码，参见功能号01H中的说明

17、功能 10H

功能描述：读取驱动器状态
入口参数：AH＝10H
DL＝80H~0FFH：硬盘
出口参数：CF＝0——操作成功，AH＝00H，否则，AH＝状态代码，参见功能号01H中的说明

18、功能 11H

功能描述：校准驱动器
入口参数：AH＝11H
DL＝80H~0FFH：硬盘
出口参数：CF＝0——操作成功，AH＝00H，否则，AH＝状态代码，参见功能号01H中的说明

19、功能 12H

功能描述：控制器RAM诊断
入口参数：AH＝12H
出口参数：CF＝0——操作成功，否则，AH＝状态代码，参见功能号01H中的说明

20、功能 13H

功能描述：控制器驱动诊断
入口参数：AH＝13H
出口参数：CF＝0——操作成功，否则，AH＝状态代码，参见功能号01H中的说明

21、功能 14H

功能描述：控制器内部诊断
入口参数：AH＝14H
出口参数：CF＝0——操作成功，否则，AH＝状态代码，参见功能号01H中的说明

22、功能 15H

功能描述：读取磁盘类型
入口参数：AH＝15H
DL＝驱动器，00H~7FH：软盘；80H~0FFH：硬盘
出口参数：CF＝1——操作失败，AH＝状态代码，参见功能号01H中的说明， 否则，AH＝00H — 未安装驱动器
＝01H — 无改变线支持的软盘驱动器
＝02H — 带有改变线支持的软盘驱动器
＝03H — 硬盘，CX:DX＝512字节的扇区数

23、功能 16H

功能描述：读取磁盘变化状态
入口参数：AH＝16H
DL＝00H~7FH：软盘
出口参数：CF＝0——磁盘未改变，AH＝00H，否则，AH＝06H，参见功能号01H中的说明

24、功能 17H

功能描述：设置磁盘类型
入口参数：AH＝17H
DL＝00H~7FH：软盘 AL＝00H — 未用
＝01H — 360K在360K驱动器中
＝02H — 360K在1.2M驱动器中
＝03H — 1.2M在1.2M驱动器中
＝04H — 720K在720K驱动器中
出口参数：CF＝0——操作成功，AH＝00H，否则，AH＝状态编码，参见功能号01H中的说明

25、功能 18H

功能描述：设置格式化媒体类型
入口参数：AH＝18H
CH＝柱面数
CL＝每磁道的扇区数
DL＝00H~7FH：软盘
出口参数：CF＝0——操作成功，AH＝00H，ES:DI＝介质类型参数表地址，否则，AH＝状态编码，参见功能号01H中的说明

26、功能 19H

功能描述：磁头保护，仅在PS/2中有效，在此从略

27、功能 1AH

功能描述：格式化ESDI驱动器，仅在PS/2中有效，在此从略

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到汇编代码中AH的值为02h，对应用法：软盘(DL=0H) 上的0磁道（DH=0H）0柱面（CH=0H）2扇区（CL=2H）开始的28个扇区（AL=28H）读取（AH=02H）到内存的1000：0000h处（ES:BX=1000:0），然后跳到loc_2A处，这部分代码再将刚才读入的扇区数据移动到内存的0x00000000处&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化IDT和GDT（lidt,lgdt）之后开启保护模式（Imsw）并且跳转至32位代码段 从0x200开始&lt;br&gt;
继续转换成汇编代码，关于IDT与GDT：&lt;a href=&#34;https://blog.csdn.net/ice__snow/article/details/50654629&#34;&gt;操作系统之GDT和IDT（三）_gdt idt-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里切到保护，跳到32位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接着分析汇编：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;seg000:00000200                               sub_200 proc near
seg000:00000200 B8 10 00 00 00                mov     eax, 10h
seg000:00000205 8E D8                         mov     ds, eax
seg000:00000207                               assume ds:nothing
seg000:00000207 0F B2 25 5C 0B 00 00          lss     esp, fword ptr ds:byte_C5C
seg000:0000020E E8 78 00 00 00                call    sub_28B
seg000:0000020E
seg000:00000213
seg000:00000213                               loc_213:                                ; DATA XREF: sub_2BA+A↓r
seg000:00000213                                                                       ; sub_2BA:loc_2E0↓w
seg000:00000213 E8 6B 00 00 00                call    sub_283
seg000:00000213
seg000:00000218
seg000:00000218                               loc_218:                                ; DATA XREF: sub_28B+27↓r
seg000:00000218 B8 10 00 00 00                mov     eax, 10h
seg000:0000021D 8E D8                         mov     ds, eax
seg000:0000021F 8E C0                         mov     es, eax
seg000:00000221                               assume es:nothing
seg000:00000221
seg000:00000221                               loc_221:                                ; DATA XREF: sub_283↓r
seg000:00000221 8E E0                         mov     fs, eax
seg000:00000223                               assume fs:nothing
seg000:00000223 8E E8                         mov     gs, eax
seg000:00000225                               assume gs:nothing
seg000:00000225
seg000:00000225                               loc_225:                                ; DATA XREF: sub_28B+11↓o
seg000:00000225 0F B2 25 5C 0B 00 00          lss     esp, fword ptr ds:byte_C5C
seg000:0000022C 31 DB                         xor     ebx, ebx
seg000:0000022C
seg000:0000022E
seg000:0000022E                               loc_22E:                                ; CODE XREF: sub_200+5D↓j
seg000:0000022E 90                            nop
seg000:0000022F 83 FB 10                      cmp     ebx, 10h
seg000:00000232 7D 2B                         jge     short loc_25F
seg000:00000232
seg000:00000234 B8 00 00 08 00                mov     eax, 80000h
seg000:00000239 8D 14 9D 08 0D 00 00          lea     edx, ds:0D08h[ebx*4]
seg000:00000240 8B 12                         mov     edx, [edx]
seg000:00000242 66 89 D0                      mov     ax, dx
seg000:00000245 66 BA 00 8E                   mov     dx, 8E00h
seg000:00000249 B9 21 00 00 00                mov     ecx, 21h ; &#39;!&#39;
seg000:0000024E 01 D9                         add     ecx, ebx
seg000:00000250 8D 34 CD 28 01 00 00          lea     esi, ds:128h[ecx*8]
seg000:00000257 89 06                         mov     [esi], eax
seg000:00000259 89 56 04                      mov     [esi+4], edx
seg000:0000025C 43                            inc     ebx
seg000:0000025D EB CF                         jmp     short loc_22E
seg000:0000025D
seg000:0000025F                               ; ---------------------------------------------------------------------------
seg000:0000025F
seg000:0000025F                               loc_25F:                                ; CODE XREF: sub_200+32↑j
seg000:0000025F                                                                       ; sub_200+66↓j
seg000:0000025F E8 04 00 00 00                call    sub_268
seg000:0000025F
seg000:00000264 CD 21                         int     21h                             ; DOS -
seg000:00000264
seg000:00000266 EB F7                         jmp     short loc_25F
seg000:00000266
seg000:00000266                               sub_200 endp
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挨个分析：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;seg000:0000028B                               sub_28B proc near                       ; CODE XREF: sub_200+E↑p
seg000:0000028B BA FC 00 00 00                mov     edx, 0FCh
seg000:00000290 B8 00 00 08 00                mov     eax, 80000h
seg000:00000295 66 89 D0                      mov     ax, dx
seg000:00000298 66 BA 00 8E                   mov     dx, 8E00h
seg000:0000029C 8D 3D 28 01 00 00             lea     edi, loc_225+3 - (dword_74+8Ch)//地址是128h
seg000:000002A2 B9 00 01 00 00                mov     ecx, 100h
seg000:000002A2
seg000:000002A7
seg000:000002A7                               loc_2A7:                                ; CODE XREF: sub_28B+25↓j
seg000:000002A7 89 07                         mov     [edi], eax
seg000:000002A9 89 57 04                      mov     [edi+4], edx
seg000:000002AC 83 C7 08                      add     edi, 8
seg000:000002AF 49                            dec     ecx
seg000:000002B0 75 F5                         jnz     short loc_2A7
seg000:000002B0
seg000:000002B2 0F 01 1D 1C 01 00 00          lidt    fword ptr ds:loc_218+4
seg000:000002B9 C3                            retn
seg000:000002B9
seg000:000002B9                               sub_28B endp
seg000:000002B9
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;seg000:00000283                               sub_283 proc near                       ; CODE XREF: sub_200:loc_213↑p
seg000:00000283 0F 01 15 22 01 00 00          lgdt    fword ptr ds:loc_221+1
seg000:0000028A C3                            retn
seg000:0000028A
seg000:0000028A                               sub_283 endp
seg000:0000028A
seg000:0000028B
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上面两个就是将IDT和GDT的入口地址装入IDTR（GDTR)寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再往下看：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给ds,es,fs,gs赋值，循环16次，loc_22E是将ds:0xD08开始的数据填充到ds:0x128，0x128是IDT表基地址，执行后中断21h到30h的的入口地址全部改变&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sub_268：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;seg000:00000268                               sub_268 proc near                       ; CODE XREF: sub_200:loc_25F↑p
seg000:00000268 8B 3D 78 0B 00 00             mov     edi, dword ptr ds:unk_C78
seg000:0000026E 8D 3C BD 48 0D 00 00          lea     edi, ds:0D48h[edi*4]
seg000:00000275 8B 07                         mov     eax, [edi]
seg000:00000277 A2 65 00 00 00                mov     byte ptr ds:unk_165, al
seg000:0000027C 8B 4F 04                      mov     ecx, [edi+4]
seg000:0000027F 8B 47 08                      mov     eax, [edi+8]
seg000:00000282 C3                            retn
seg000:00000282
seg000:00000282                               sub_268 endp
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里的&lt;strong&gt;ds:unk_165&lt;/strong&gt;就是 000264处的 int 21h&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该段代码就是存储了虚拟机的指令，每条指令的长度为12字节，前四个字节为opcode，后面八个字节就是两个操作数，作为两个参数传入中断，中断作用相当于call，调用子程序就是handler&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中断指令 的21h会一直改变，每次调用完子程序都会跳到EF8处，0B78处的值加3，从而执行0d48[edi*4]处的下一个中断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注：中断调用子程序地址按中断编号线性排列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;seg000:00000EF8 8D 0D 78 0B 00 00             lea     ecx, unk_B78
seg000:00000EFE 8B 01                         mov     eax, [ecx]
seg000:00000F00 83 C0 03                      add     eax, 3
seg000:00000F03 89 01                         mov     [ecx], eax
seg000:00000F05 CF                            iret
seg000:00000F05
seg000:00000F05                               ; -----------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面逐个分析16个中断的意义：设0B64数组为buf，eax为a，ecx为c，0D48为code数组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;seg000:00000D7C 8D 0C 8D 64 0B 00 00          lea     ecx, ds:0B64h[ecx*4]
seg000:00000D83 89 01                         mov     [ecx], eax
seg000:00000D85 E9 6E 01 00 00                jmp     loc_EF8   ; buf[c]=a;
seg000:00000D85
seg000:00000D8A                               ; ---------------------------------------------------------------------------
seg000:00000D8A 8D 04 85 64 0B 00 00          lea     eax, ds:0B64h[eax*4]
seg000:00000D91 8B 00                         mov     eax, [eax]
seg000:00000D93 8D 0C 8D 64 0B 00 00          lea     ecx, ds:0B64h[ecx*4]
seg000:00000D9A 89 01                         mov     [ecx], eax
seg000:00000D9C E9 57 01 00 00                jmp     loc_EF8  ;buf[c]=buf[a]
seg000:00000D9C
seg000:00000DA1                               ; ---------------------------------------------------------------------------
seg000:00000DA1 8D 04 85 64 0B 00 00          lea     eax, ds:0B64h[eax*4]
seg000:00000DA8 8B 00                         mov     eax, [eax]
seg000:00000DAA 8D 0C 8D 64 0B 00 00          lea     ecx, ds:0B64h[ecx*4]
seg000:00000DB1 8D 04 85 48 0D 00 00          lea     eax, ds:0D48h[eax*4]
seg000:00000DB8 8B 00                         mov     eax, [eax]
seg000:00000DBA 89 01                         mov     [ecx], eax;buf[c]=code[buf[a]]
seg000:00000DBC E9 37 01 00 00                jmp     loc_EF8
seg000:00000DBC
seg000:00000DC1                               ; ---------------------------------------------------------------------------
seg000:00000DC1 8D 04 85 64 0B 00 00          lea     eax, ds:0B64h[eax*4]
seg000:00000DC8 8B 00                         mov     eax, [eax]
seg000:00000DCA 8D 0C 8D 64 0B 00 00          lea     ecx, ds:0B64h[ecx*4]
seg000:00000DD1 8B 09                         mov     ecx, [ecx]
seg000:00000DD3 8D 0C 8D 48 0D 00 00          lea     ecx, ds:0D48h[ecx*4]
seg000:00000DDA 89 01                         mov     [ecx], eax
seg000:00000DDC E9 17 01 00 00                jmp     loc_EF8;code[buf[c]]=buf[a];
seg000:00000DDC
seg000:00000DE1                               ; ---------------------------------------------------------------------------
seg000:00000DE1 8D 04 85 64 0B 00 00          lea     eax, ds:0B64h[eax*4]
seg000:00000DE8 8B 10                         mov     edx, [eax]
seg000:00000DEA 8D 0C 8D 64 0B 00 00          lea     ecx, ds:0B64h[ecx*4]
seg000:00000DF1 8B 01                         mov     eax, [ecx]
seg000:00000DF3 01 D0                         add     eax, edx
seg000:00000DF5 89 01                         mov     [ecx], eax
seg000:00000DF7 E9 FC 00 00 00                jmp     loc_EF8;code[buf[c]]=buf[a];
seg000:00000DF7
seg000:00000DFC                               ; ---------------------------------------------------------------------------
seg000:00000DFC 8D 04 85 64 0B 00 00          lea     eax, ds:0B64h[eax*4]
seg000:00000E03 8B 10                         mov     edx, [eax]
seg000:00000E05 8D 0C 8D 64 0B 00 00          lea     ecx, ds:0B64h[ecx*4]
seg000:00000E0C 8B 01                         mov     eax, [ecx]
seg000:00000E0E 29 D0                         sub     eax, edx
seg000:00000E10 89 01                         mov     [ecx], eax
seg000:00000E12 E9 E1 00 00 00                jmp     loc_EF8
seg000:00000E12;buf[c]=buf[c]-buf[a];
seg000:00000E17                               ; ---------------------------------------------------------------------------
seg000:00000E17 8D 04 85 64 0B 00 00          lea     eax, ds:0B64h[eax*4]
seg000:00000E1E 8B 10                         mov     edx, [eax]
seg000:00000E20 8D 0C 8D 64 0B 00 00          lea     ecx, ds:0B64h[ecx*4]
seg000:00000E27 8B 01                         mov     eax, [ecx]
seg000:00000E29 31 D0                         xor     eax, edx
seg000:00000E2B 89 01                         mov     [ecx], eax
seg000:00000E2D E9 C6 00 00 00                jmp     loc_EF8
seg000:00000E2D;buf[c]=buf[c]^buf[a];
seg000:00000E32                               ; ---------------------------------------------------------------------------
seg000:00000E32 8D 04 85 64 0B 00 00          lea     eax, ds:0B64h[eax*4]
seg000:00000E39 8B 00                         mov     eax, [eax]
seg000:00000E3B 8D 14 8D 64 0B 00 00          lea     edx, ds:0B64h[ecx*4]
seg000:00000E42 88 C1                         mov     cl, al
seg000:00000E44 8B 02                         mov     eax, [edx]
seg000:00000E46 D3 E0                         shl     eax, cl
seg000:00000E48
seg000:00000E48                               loc_E48:
seg000:00000E48 89 02                         mov     [edx], eax
seg000:00000E4A E9 A9 00 00 00                jmp     loc_EF8
seg000:00000E4A;buf[c]=buf[c]&amp;lt;&amp;lt;(buf[a]&amp;amp;0xFF);
seg000:00000E4F                               ; ---------------------------------------------------------------------------
seg000:00000E4F
seg000:00000E4F                               loc_E4F:
seg000:00000E4F 8D 04 85 64 0B 00 00          lea     eax, ds:0B64h[eax*4]
seg000:00000E56 8B 00                         mov     eax, [eax]
seg000:00000E58 8D 14 8D 64 0B 00 00          lea     edx, ds:0B64h[ecx*4]
seg000:00000E5F 88 C1                         mov     cl, al
seg000:00000E61 8B 02                         mov     eax, [edx]
seg000:00000E63 D3 E8                         shr     eax, cl
seg000:00000E65 89 02                         mov     [edx], eax
seg000:00000E67 E9 8C 00 00 00                jmp     loc_EF8
seg000:00000E67;buf[c]=buf[c]&amp;gt;&amp;gt;(buf[a]&amp;amp;0xFF);
seg000:00000E6C                               ; ---------------------------------------------------------------------------
seg000:00000E6C 8D 04 85 64 0B 00 00          lea     eax, ds:0B64h[eax*4]
seg000:00000E73 8B 00                         mov     eax, [eax]
seg000:00000E75 8D 0C 8D 64 0B 00 00          lea     ecx, ds:0B64h[ecx*4]
seg000:00000E7C 8B 11                         mov     edx, [ecx]
seg000:00000E7E 21 D0                         and     eax, edx
seg000:00000E80 89 01                         mov     [ecx], eax
seg000:00000E82 EB 74                         jmp     short loc_EF8
seg000:00000E82;buf[c]=buf[c]&amp;gt;&amp;gt;(buf[a]&amp;amp;0xFF);
seg000:00000E84                               ; ---------------------------------------------------------------------------
seg000:00000E84 8D 04 8D 64 0B 00 00          lea     eax, ds:0B64h[ecx*4]
seg000:00000E8B 8B 00                         mov     eax, [eax]
seg000:00000E8D 8D 0D 78 0B 00 00             lea     ecx, unk_B78
seg000:00000E93 89 01                         mov     [ecx], eax
seg000:00000E95 CF                            iret
seg000:00000E95;ds:0x0b78=buf[c];
seg000:00000E96                               ; ---------------------------------------------------------------------------
seg000:00000E96 8D 04 85 64 0B 00 00          lea     eax, ds:0B64h[eax*4]
seg000:00000E9D 8B 00                         mov     eax, [eax]
seg000:00000E9F 85 C0                         test    eax, eax
seg000:00000EA1 75 55                         jnz     short loc_EF8
seg000:00000EA1
seg000:00000EA3 8D 04 8D 64 0B 00 00          lea     eax, ds:0B64h[ecx*4]
seg000:00000EAA 8B 00                         mov     eax, [eax]
seg000:00000EAC 8D 0D 78 0B 00 00             lea     ecx, unk_B78
seg000:00000EB2 89 01                         mov     [ecx], eax
seg000:00000EB4 CF                            iret
seg000:00000EB4;if {buf[a]==0} ds:0x0b78=buf[c];
seg000:00000EB5                               ; ---------------------------------------------------------------------------
seg000:00000EB5 8D 04 85 64 0B 00 00          lea     eax, ds:0B64h[eax*4]
seg000:00000EBC 8B 00                         mov     eax, [eax]
seg000:00000EBE 85 C0                         test    eax, eax
seg000:00000EC0 74 36                         jz      short loc_EF8
seg000:00000EC0
seg000:00000EC2 8D 04 8D 64 0B 00 00          lea     eax, ds:0B64h[ecx*4]
seg000:00000EC9 8B 00                         mov     eax, [eax]
seg000:00000ECB 8D 0D 78 0B 00 00             lea     ecx, unk_B78
seg000:00000ED1 89 01                         mov     [ecx], eax
seg000:00000ED3 CF                            iret
seg000:00000ED3;if{buf[a]!=0} ds:0x0b78=buf[c];
seg000:00000ED4                               ; ---------------------------------------------------------------------------
seg000:00000ED4 8D 05 94 0F 00 00             lea     eax, unk_F94
seg000:00000EDA E8 0B F4 FF FF                call    sub_2EA
seg000:00000EDA
seg000:00000EDF F4                            hlt;暂停;
seg000:00000EE0 8D 05 A0 0F 00 00             lea     eax, unk_FA0
seg000:00000EE6 E8 FF F3 FF FF                call    sub_2EA;正确
seg000:00000EE6
seg000:00000EEB 8D 05 AE 0F 00 00             lea     eax, word_FAE
seg000:00000EF1 E8 F4 F3 FF FF                call    sub_2EA;错误
seg000:00000EF1
seg000:00000EF6 F4                            hlt
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后面把数据dump出来(注意是DWORD类型数组）写脚本模拟虚拟机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data = [
        0x00000021, 0x00000000, 0x00000081, 0x00000027, 0x00000001, 0x00000001, 0x00000024, 0x00000001, 0x00000001,
        0x00000023, 0x00000002, 0x00000000, 0x00000022, 0x00000003, 0x00000002, 0x00000021, 0x00000004, 0x00000008,
        0x00000028, 0x00000003, 0x00000004, 0x00000027, 0x00000002, 0x00000003, 0x00000028, 0x00000003, 0x00000004,
        0x00000027, 0x00000002, 0x00000003,  0x00000028, 0x00000003, 0x00000004, 0x00000027, 0x00000002, 0x00000003,
        0x00000027, 0x00000003, 0x00000003, 0x00000023, 0x00000004, 0x00000003, 0x00000024, 0x00000003, 0x00000002,
        0x00000027, 0x00000002, 0x00000004, 0x00000024, 0x00000000, 0x00000002, 0x00000021, 0x00000001, 0x00000001,
        0x00000025, 0x00000000, 0x00000001, 0x00000022, 0x00000001, 0x00000000, 0x00000021, 0x00000002, 0x00000081,
        0x00000026, 0x00000001, 0x00000002, 0x00000021, 0x00000002, 0x00000009, 0x00000026, 0x00000001, 0x00000002,
        0x00000021, 0x00000002, 0x00000009, 0x0000002D, 0x00000002, 0x00000001, 0x00000021, 0x00000000, 0x00000081,
        0x00000022, 0x00000001, 0x00000000, 0x00000021, 0x00000002, 0x00000009, 0x00000025, 0x00000001, 0x00000002,
        0x00000023, 0x00000003, 0x00000000, 0x00000023, 0x00000004, 0x00000001, 0x00000026, 0x00000003, 0x00000004,
        0x00000021, 0x00000004, 0x0000007E, 0x0000002D, 0x00000004, 0x00000003, 0x00000021, 0x00000003, 0x00000001,
        0x00000025, 0x00000000, 0x00000003, 0x00000025, 0x00000001, 0x00000003, 0x00000026, 0x00000002, 0x00000003,
        0x00000021, 0x00000004, 0x0000005A, 0x0000002D, 0x00000004, 0x00000002, 0x0000002F, 0x00000000, 0x00000000,
        0x00000030, 0x00000000, 0x00000000
      ]
i = 0
while (i&amp;lt;=126):
    if data[i] == 0x21:
        print (&amp;quot;buf[%d]=%d&amp;quot; % (data[i+1], data[i+2]))
    if data[i] == 0x22:
        print (&amp;quot;buf[%d]=buf[%d]&amp;quot; % (data[i+1], data[i+2]))
    if data[i] == 0x23:
        print (&amp;quot;buf[%d]=code[buf[%d]]&amp;quot; % (data[i+1], data[i+2]))
    if data[i] == 0x24:
        print (&amp;quot;code[buf[%d]]=buf[%d]&amp;quot; % (data[i+1], data[i+2]))
    if data[i] == 0x25:
        print (&amp;quot;buf[%d]+=buf[%d]&amp;quot; % (data[i+1], data[i+2]))
    if data[i] == 0x26:
        print (&amp;quot;buf[%d]-=buf[%d]&amp;quot; % (data[i+1], data[i+2]))
    if data[i] == 0x27:
        print (&amp;quot;buf[%d]^=buf[%d]&amp;quot; % (data[i+1], data[i+2]))
    if data[i] == 0x28:
        print (&amp;quot;buf[%d]&amp;lt;&amp;lt;=buf[%d]&amp;quot; % (data[i+1], data[i+2]))
    if data[i] == 0x29:
        print (&amp;quot;buf[%d]&amp;gt;&amp;gt;=buf[%d]&amp;quot; % (data[i+1], data[i+2]))
    if data[i] == 0x2A:
        print (&amp;quot;buf[%d]&amp;amp;=buf[%d]&amp;quot; % (data[i+1], data[i+2]))
    if data[i] == 0x2B:
        print (&amp;quot;i =buf[%d]&amp;quot; % (data[i+1]))
    if data[i] == 0x2c:
        print (&amp;quot;if buf[%d]==0  i=buf[%d]&amp;quot; % (data[i+2], data[i+1]))
    if data[i] == 0x2d:
        print (&amp;quot;if buf[%d]!=0 i=buf[%d]&amp;quot; % (data[i+2], data[i+1]))
    if data[i] == 0x2e:
        print (&amp;quot;pause&amp;quot;)
    if data[i] == 0x2f:
        print (&amp;quot;correct&amp;quot;)
    if data[i] == 0x30:
        print (&amp;quot;wrong&amp;quot;)
    i+=3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;buf[0]=129
buf[1]^=buf[1]
code[buf[1]]=buf[1]
buf[2]=code[buf[0]]
buf[3]=buf[2]
buf[4]=8
buf[3]&amp;lt;&amp;lt;=buf[4]
buf[2]^=buf[3]
buf[3]&amp;lt;&amp;lt;=buf[4]
buf[2]^=buf[3]
buf[3]&amp;lt;&amp;lt;=buf[4]
buf[2]^=buf[3]
buf[3]^=buf[3]
buf[4]=code[buf[3]]
code[buf[3]]=buf[2]
buf[2]^=buf[4]
code[buf[0]]=buf[2]
buf[1]=1
buf[0]+=buf[1]
buf[1]=buf[0]
buf[2]=129
buf[1]-=buf[2]
buf[2]=9
buf[1]-=buf[2]
buf[2]=9
if buf[1]!=0 i=buf[2]
buf[0]=129
buf[1]=buf[0]
buf[2]=9
buf[1]+=buf[2]
buf[3]=code[buf[0]]
buf[4]=code[buf[1]]
buf[3]-=buf[4]
buf[4]=126
if buf[3]!=0 i=buf[4]
buf[3]=1
buf[0]+=buf[3]
buf[1]+=buf[3]
buf[2]-=buf[3]
buf[4]=90
if buf[2]!=0 i=buf[4]
correct
wrong
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码一共循环9次执行指令code[i]=code[i] ^（code[i]&amp;lt;&amp;lt;8） ^ (code[i]&amp;lt;&amp;lt;16) ^(code[i]&amp;lt;&amp;lt;24) ^ code[i-1]；之后再执行9次比较；buf[i]与buf[i+9]进行9次比较。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=[0x57635565, 0x06530401, 0x1F494949, 0x5157071F, 0x575F4357, 0x57435E57, 0x4357020A, 0x575E035E,0x0f590000,0x0]
for x in range (0,9):

    m4=a[x]&amp;amp;0xff
    m3=(a[x]&amp;amp;0xff00)&amp;gt;&amp;gt;8
    m2=(a[x]&amp;amp;0xff0000)&amp;gt;&amp;gt;16
    m1=(a[x]&amp;amp;0xff000000)&amp;gt;&amp;gt;24

    p1=m4
    p2=p1^m3
    p3=p1^m2^p2
    p4=p1^p2^p3^m1

    flag=p1+(p2&amp;lt;&amp;lt;8)+(p3&amp;lt;&amp;lt;16)+(p4&amp;lt;&amp;lt;24)
    print(long_to_bytes(flag))
    a[x+1]=a[x]^a[x+1]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我直接用longtobytes了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;b&#39;460e&#39;
b&#39;aa5d&#39;
b&#39;7a5-&#39;
b&#39;11-2&#39;
b&#39;9-9e&#39;
b&#39;-002&#39;
b&#39;9e88&#39;
b&#39;08ef&#39;
b&#39;faef&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调整顺序，这就是flag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后来发现：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;0x61646238, 0x36353465, 0x6361352D, 0x31312D38, 0x612D3965, 0x2D316331, 0x39653838, 0x30386566, 0x66616566, 0x57635565, 0x06530401, 0x1F494949, 0x5157071F, 0x575F4357, 0x57435E57, 0x4357020A, 0x575E035E, 0x0F590000,
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flag就是数据段中已经有的，算非预期嘛？（不过也还是要找到这个循环比较&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总结：软盘分析，中断向量表，vm混淆&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">[2019Ciscn初赛] Strange int</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/qiang-wang-bei-2022gamemaster-writeup/"" data-c="
          &lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;还是想刷一些题，在此简单记录一下&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.net逆向，用dnspy打开&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;private static void Main(string[] args)
{
	ConfigurationManager.AppSettings.Set(&amp;quot;microsoft:WorkflowComponentModel:DisableActivitySurrogateSelectorTypeCheck&amp;quot;, &amp;quot;true&amp;quot;);
	FileStream fileStream = File.OpenRead(&amp;quot;gamemessage&amp;quot;);
	int num = (int)fileStream.Length;
	Program.memory = new byte[num];
	fileStream.Position = 0L;
	fileStream.Read(Program.memory, 0, num);
	Console.Title = &amp;quot;♠ Blackjack Game&amp;quot; + new string(&#39; &#39;, 11) + &amp;quot;...Based on Konstantin Tarkus&#39; code&amp;quot;;
	Console.BufferWidth = (Console.WindowWidth = 70);
	Console.BufferHeight = (Console.WindowHeight = 26);
	Console.CursorVisible = false;
	ArrayList arrayList = new ArrayList();
	Game game = new Game();
	game.Player.BalanceChanged += Program.OnBalanceChanged;
	game.LastStateChanged += Program.OnLastStateChanged;
	game.AllowedActionsChanged += Program.OnAllowedActionsChanged;
	game.Dealer.Hand.Changed += Program.OnHandChanged;
	game.Player.Hand.Changed += Program.OnHandChanged;
	game.Play(20m, 5m);
	for (;;)
	{
		ConsoleKey key = Console.ReadKey(true).Key;
		ConsoleKey consoleKey = key;
		if (consoleKey &amp;lt;= ConsoleKey.Add)
		{
			switch (consoleKey)
			{
			case ConsoleKey.Enter:
			{
				bool flag = (game.AllowedActions &amp;amp; GameAction.Deal) == GameAction.Deal;
				if (flag)
				{
					game.Deal();
				}
				else
				{
					game.Stand();
				}
				continue;
			}
			case (ConsoleKey)14:
			case (ConsoleKey)15:
			case (ConsoleKey)16:
			case (ConsoleKey)17:
			case (ConsoleKey)18:
			case ConsoleKey.Pause:
			case (ConsoleKey)20:
			case (ConsoleKey)21:
			case (ConsoleKey)22:
			case (ConsoleKey)23:
			case (ConsoleKey)24:
			case (ConsoleKey)25:
			case (ConsoleKey)26:
			case (ConsoleKey)28:
			case (ConsoleKey)29:
			case (ConsoleKey)30:
			case (ConsoleKey)31:
			case ConsoleKey.PageUp:
			case ConsoleKey.PageDown:
			case ConsoleKey.End:
			case ConsoleKey.Home:
			case ConsoleKey.LeftArrow:
			case ConsoleKey.RightArrow:
			case ConsoleKey.Select:
			case ConsoleKey.Print:
			case ConsoleKey.Execute:
			case ConsoleKey.PrintScreen:
			case ConsoleKey.Insert:
			case ConsoleKey.Delete:
			case ConsoleKey.Help:
			case (ConsoleKey)58:
			case (ConsoleKey)59:
			case (ConsoleKey)60:
			case (ConsoleKey)61:
			case (ConsoleKey)62:
			case (ConsoleKey)63:
			case (ConsoleKey)64:
				continue;
			case ConsoleKey.Escape:
				Program.verifyCode(arrayList, game);
				continue;
			case ConsoleKey.Spacebar:
			{
				bool flag2 = (game.AllowedActions &amp;amp; GameAction.Deal) == GameAction.Deal;
				if (flag2)
				{
					game.Deal();
				}
				else
				{
					game.Hit();
				}
				continue;
			}
			case ConsoleKey.UpArrow:
				break;
			case ConsoleKey.DownArrow:
				goto IL_5A0;
			case ConsoleKey.D0:
				arrayList.Add(&#39;0&#39;);
				continue;
			case ConsoleKey.D1:
				arrayList.Add(&#39;1&#39;);
				continue;
			case ConsoleKey.D2:
				arrayList.Add(&#39;2&#39;);
				continue;
			case ConsoleKey.D3:
				arrayList.Add(&#39;3&#39;);
				continue;
			case ConsoleKey.D4:
				arrayList.Add(&#39;4&#39;);
				continue;
			case ConsoleKey.D5:
				arrayList.Add(&#39;5&#39;);
				continue;
			case ConsoleKey.D6:
				arrayList.Add(&#39;6&#39;);
				continue;
			case ConsoleKey.D7:
				arrayList.Add(&#39;7&#39;);
				continue;
			case ConsoleKey.D8:
				arrayList.Add(&#39;8&#39;);
				continue;
			case ConsoleKey.D9:
				arrayList.Add(&#39;9&#39;);
				continue;
			case ConsoleKey.A:
				arrayList.Add(&#39;A&#39;);
				continue;
			case ConsoleKey.B:
				arrayList.Add(&#39;B&#39;);
				continue;
			case ConsoleKey.C:
				arrayList.Add(&#39;C&#39;);
				continue;
			case ConsoleKey.D:
				arrayList.Add(&#39;D&#39;);
				continue;
			case ConsoleKey.E:
				arrayList.Add(&#39;E&#39;);
				continue;
			case ConsoleKey.F:
				arrayList.Add(&#39;F&#39;);
				continue;
			case ConsoleKey.G:
				arrayList.Add(&#39;G&#39;);
				continue;
			case ConsoleKey.H:
				arrayList.Add(&#39;H&#39;);
				continue;
			case ConsoleKey.I:
				arrayList.Add(&#39;I&#39;);
				continue;
			case ConsoleKey.J:
				arrayList.Add(&#39;J&#39;);
				continue;
			case ConsoleKey.K:
				arrayList.Add(&#39;K&#39;);
				continue;
			case ConsoleKey.L:
				arrayList.Add(&#39;L&#39;);
				continue;
			case ConsoleKey.M:
				arrayList.Add(&#39;M&#39;);
				continue;
			case ConsoleKey.N:
				arrayList.Add(&#39;N&#39;);
				continue;
			case ConsoleKey.O:
				arrayList.Add(&#39;O&#39;);
				continue;
			case ConsoleKey.P:
				arrayList.Add(&#39;P&#39;);
				continue;
			case ConsoleKey.Q:
				arrayList.Add(&#39;Q&#39;);
				continue;
			case ConsoleKey.R:
				arrayList.Add(&#39;R&#39;);
				continue;
			case ConsoleKey.S:
				arrayList.Add(&#39;S&#39;);
				continue;
			case ConsoleKey.T:
				arrayList.Add(&#39;T&#39;);
				continue;
			case ConsoleKey.U:
				arrayList.Add(&#39;U&#39;);
				continue;
			case ConsoleKey.V:
				arrayList.Add(&#39;V&#39;);
				continue;
			case ConsoleKey.W:
				arrayList.Add(&#39;W&#39;);
				continue;
			case ConsoleKey.X:
				arrayList.Add(&#39;X&#39;);
				continue;
			case ConsoleKey.Y:
				arrayList.Add(&#39;Y&#39;);
				continue;
			case ConsoleKey.Z:
				arrayList.Add(&#39;Z&#39;);
				continue;
			default:
				if (consoleKey != ConsoleKey.Add)
				{
					continue;
				}
				break;
			}
			game.Player.Bet += 1m;
		}
		else
		{
			if (consoleKey == ConsoleKey.Subtract)
			{
				goto IL_5A0;
			}
			if (consoleKey == ConsoleKey.Oem1)
			{
				arrayList.Add(&amp;quot;:&amp;quot;);
			}
		}
		continue;
		IL_5A0:
		game.Player.Bet -= 1m;
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;往内存里加载了个文件，先观察一下对这个文件如何加密的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到如下函数：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;private static void verifyCode(ArrayList arrayList, Game game)
		{
			string str = &amp;quot;&amp;quot;;
			for (int i = 0; i &amp;lt; arrayList.Count; i++)
			{
				str += arrayList[i].ToString()[0].ToString();
			}
			Program.goldFunc(arrayList, game);
			arrayList.Clear();
		}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跟进：private static void &lt;em&gt;&lt;strong&gt;goldFunc&lt;/strong&gt;&lt;/em&gt;(ArrayList &lt;strong&gt;input&lt;/strong&gt;, Game &lt;strong&gt;game&lt;/strong&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到几处关键加密：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;else
									{
										bool flag23 = Program.memcmp1(input, &amp;quot;MF3K&amp;quot;, 4);
										if (flag23)
										{
											try
											{
												game.Player.Bet -= 22m;
												for (int i = 0; i &amp;lt; Program.memory.Length; i++)
												{
													byte[] array = Program.memory;
													int num = i;
													array[num] ^= 34;
												}
												Environment.SetEnvironmentVariable(&amp;quot;AchivePoint1&amp;quot;, game.Player.Balance.ToString());
											}
											catch
											{
											}
										}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单异或&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;else
												{
													bool flag41 = Program.memcmp1(input, &amp;quot;EEPW&amp;quot;, 4);
													if (flag41)
													{
														try
														{
															game.Player.Balance += 175m;
															byte[] key = new byte[]
															{
																66,
																114,
																97,
																105,
																110,
																115,
																116,
																111,
																114,
																109,
																105,
																110,
																103,
																33,
																33,
																33
															};
															ICryptoTransform cryptoTransform = new RijndaelManaged
															{
																Key = key,
																Mode = CipherMode.ECB,
																Padding = PaddingMode.Zeros
															}.CreateDecryptor();
															Program.m = cryptoTransform.TransformFinalBlock(Program.memory, 0, Program.memory.Length);
															Environment.SetEnvironmentVariable(&amp;quot;AchivePoint2&amp;quot;, game.Player.Balance.ToString());
														}
														catch
														{
														}
													}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AES-ECB加密，有key可解密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将gamemessage文件拖进cyberchef进行解密，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到MZ头，dump下来用dnspy分析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键函数如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c#&#34;&gt;using System;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace T1Class
{
	// Token: 0x02000002 RID: 2
	public class T1
	{
		// Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250
		private static void Check1(ulong x, ulong y, ulong z, byte[] KeyStream)
		{
			int num = -1;
			for (int i = 0; i &amp;lt; 320; i++)
			{
				x = (((x &amp;gt;&amp;gt; 29 ^ x &amp;gt;&amp;gt; 28 ^ x &amp;gt;&amp;gt; 25 ^ x &amp;gt;&amp;gt; 23) &amp;amp; 1UL) | x &amp;lt;&amp;lt; 1);
				y = (((y &amp;gt;&amp;gt; 30 ^ y &amp;gt;&amp;gt; 27) &amp;amp; 1UL) | y &amp;lt;&amp;lt; 1);
				z = (((z &amp;gt;&amp;gt; 31 ^ z &amp;gt;&amp;gt; 30 ^ z &amp;gt;&amp;gt; 29 ^ z &amp;gt;&amp;gt; 28 ^ z &amp;gt;&amp;gt; 26 ^ z &amp;gt;&amp;gt; 24) &amp;amp; 1UL) | z &amp;lt;&amp;lt; 1);
				bool flag = i % 8 == 0;
				if (flag)
				{
					num++;
				}
				KeyStream[num] = (byte)((long)((long)KeyStream[num] &amp;lt;&amp;lt; 1) | (long)((ulong)((uint)((z &amp;gt;&amp;gt; 32 &amp;amp; 1UL &amp;amp; (x &amp;gt;&amp;gt; 30 &amp;amp; 1UL)) ^ (((z &amp;gt;&amp;gt; 32 &amp;amp; 1UL) ^ 1UL) &amp;amp; (y &amp;gt;&amp;gt; 31 &amp;amp; 1UL))))));
			}
		}

		// Token: 0x06000002 RID: 2 RVA: 0x00002110 File Offset: 0x00000310
		private static void ParseKey(ulong[] L, byte[] Key)
		{
			for (int i = 0; i &amp;lt; 3; i++)
			{
				for (int j = 0; j &amp;lt; 4; j++)
				{
					Key[i * 4 + j] = (byte)(L[i] &amp;gt;&amp;gt; j * 8 &amp;amp; 255UL);
				}
			}
		}

		// Token: 0x06000003 RID: 3 RVA: 0x0000215C File Offset: 0x0000035C
		public T1()
		{
			try
			{
				string environmentVariable = Environment.GetEnvironmentVariable(&amp;quot;AchivePoint1&amp;quot;);
				string environmentVariable2 = Environment.GetEnvironmentVariable(&amp;quot;AchivePoint2&amp;quot;);
				string environmentVariable3 = Environment.GetEnvironmentVariable(&amp;quot;AchivePoint3&amp;quot;);
				bool flag = environmentVariable == null || environmentVariable2 == null || environmentVariable3 == null;
				if (!flag)
				{
					ulong num = ulong.Parse(environmentVariable);
					ulong num2 = ulong.Parse(environmentVariable2);
					ulong num3 = ulong.Parse(environmentVariable3);
					ulong[] array = new ulong[3];
					byte[] array2 = new byte[40];
					byte[] array3 = new byte[40];
					byte[] array4 = new byte[12];
					byte[] first = new byte[]
					{
						101,
						5,
						80,
						213,
						163,
						26,
						59,
						38,
						19,
						6,
						173,
						189,
						198,
						166,
						140,
						183,
						42,
						247,
						223,
						24,
						106,
						20,
						145,
						37,
						24,
						7,
						22,
						191,
						110,
						179,
						227,
						5,
						62,
						9,
						13,
						17,
						65,
						22,
						37,
						5
					};
					byte[] array5 = new byte[]
					{
						60,
						100,
						36,
						86,
						51,
						251,
						167,
						108,
						116,
						245,
						207,
						223,
						40,
						103,
						34,
						62,
						22,
						251,
						227
					};
					array[0] = num;
					array[1] = num2;
					array[2] = num3;
					T1.Check1(array[0], array[1], array[2], array2);
					bool flag2 = first.SequenceEqual(array2);
					if (flag2)
					{
						T1.ParseKey(array, array4);
						for (int i = 0; i &amp;lt; array5.Length; i++)
						{
							array5[i] ^= array4[i % array4.Length];
						}
						MessageBox.Show(&amp;quot;flag{&amp;quot; + Encoding.Default.GetString(array5) + &amp;quot;}&amp;quot;, &amp;quot;Congratulations!&amp;quot;, MessageBoxButtons.OK);
					}
				}
			}
			catch (Exception)
			{
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑很简单，我们首先用z3解一下array[0], array[1], array[2]这三个数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如下照抄dnspy即可写出脚本：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from z3 import *

x,y,z=BitVecs(&#39;x y z&#39;,64)
s=Solver()
KeyStream=[0]*40
array2 = [101, 5, 80, 213, 163, 26, 59, 38, 19, 6, 173, 189, 198, 166, 140, 183, 42, 247, 223, 24, 106,20, 145, 37, 24, 7, 22, 191, 110, 179, 227, 5, 62, 9, 13, 17, 65, 22, 37, 5]
num=-1
for i in range(320):
    x = (((x &amp;gt;&amp;gt; 29 ^ x &amp;gt;&amp;gt; 28 ^ x &amp;gt;&amp;gt; 25 ^ x &amp;gt;&amp;gt; 23) &amp;amp; 1) | x &amp;lt;&amp;lt; 1)
    y = (((y &amp;gt;&amp;gt; 30 ^ y &amp;gt;&amp;gt; 27) &amp;amp; 1) | y &amp;lt;&amp;lt; 1)
    z = (((z &amp;gt;&amp;gt; 31 ^ z &amp;gt;&amp;gt; 30 ^ z &amp;gt;&amp;gt; 29 ^ z &amp;gt;&amp;gt; 28 ^ z &amp;gt;&amp;gt; 26 ^ z &amp;gt;&amp;gt; 24) &amp;amp; 1) | z &amp;lt;&amp;lt; 1)
    if i%8==0:
        if i!=0:
            s.add(KeyStream[num]==array2[num])
        num += 1
    KeyStream[num] = (KeyStream[num] &amp;lt;&amp;lt; 1) | (((z &amp;gt;&amp;gt; 32 &amp;amp; 1 &amp;amp; (x &amp;gt;&amp;gt; 30 &amp;amp; 1)) ^ (((z &amp;gt;&amp;gt; 32 &amp;amp; 1) ^ 1) &amp;amp; (y &amp;gt;&amp;gt; 31 &amp;amp; 1))))
print(s.check())
print(s.model())
[y = 868387187, x = 156324965, z = 3131229747]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接着照抄dnspy：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def ParseKey(array,key):
    for i in range(3):
        for j in range(4):
            key[i * 4 + j] = ((array[i] &amp;gt;&amp;gt; j * 8) &amp;amp; 255)
    return key
array=[156324965,868387187,3131229747]
array4=[0]*12
array4=ParseKey(array,array4)
array5 =                [60,
						100,
						36,
						86,
						51,
						251,
						167,
						108,
						116,
						245,
						207,
						223,
						40,
						103,
						34,
						62,
						22,
						251,
						227]
c=&#39;&#39;
for i in range(len(array5)):
    c+=chr(array5[i]^array4[i%12])
print(&#39;flag{&#39;+c+&#39;}&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;成功得到：&lt;em&gt;&lt;strong&gt;flag{Y0u_@re_G3meM3s7er!}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该题主要考察文件加密，C#语言，以及算法“照抄”能力。。。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">[强网杯 2022]GameMaster  Writeup</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/peng-cheng-bei-2023-reverse-writeup/"" data-c="
          &lt;h1 id=&#34;鹏城杯2023初赛-re-wp&#34;&gt;鹏城杯2023初赛  re  WP&lt;/h1&gt;
&lt;h2 id=&#34;一-安全编程&#34;&gt;一. 安全编程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;rust逆向，直接动调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定位关键函数sub_7FD043E88C70&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下断点跟进&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;观察控制台&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;guess number&lt;br&gt;
plz input 1-10 number&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这时我们随便输入一个数，往下跟进&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.text:00007F14B3684E9B
.text:00007F14B3684E9B loc_7F14B3684E9B:
.text:00007F14B3684E9B cmp     [rsp+0D8h+var_88], eax
.text:00007F14B3684E9F jnz     loc_7F14B3684F63
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将输入的数与程序随机生成的数进行比较，从而跳转&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.text:00007F14B3684EA5 inc     [rsp+0D8h+var_84]
.text:00007F14B3684EA9 lea     rax, [rsp+0D8h+var_84]
.text:00007F14B3684EAE mov     [rsp+0D8h+var_A0], rax
.text:00007F14B3684EB3 lea     rax, sub_7F14B36D13F0
.text:00007F14B3684EBA mov     [rsp+0D8h+var_98], rax
.text:00007F14B3684EBF lea     rax, unk_7F14B36E6F08
.text:00007F14B3684EC6 mov     [rsp+0D8h+var_C0], rax
.text:00007F14B3684ECB mov     [rsp+0D8h+var_B8], 2
.text:00007F14B3684ED4 mov     [rsp+0D8h+var_D0], 0
.text:00007F14B3684EDD lea     rax, [rsp+0D8h+var_A0]
.text:00007F14B3684EE2 mov     [rsp+0D8h+var_B0], rax
.text:00007F14B3684EE7 mov     [rsp+0D8h+var_A8], 1
.text:00007F14B3684EF0 mov     rdi, r14
.text:00007F14B3684EF3 call    r13 ; sub_7F14B369D660
.text:00007F14B3684EF6 cmp     [rsp+0D8h+var_84], 64h ; &#39;d&#39;
.text:00007F14B3684EFB jz      loc_7F14B368500E
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果比较结果相同就跳到上述分支，注意到inc这一关键计数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再看&lt;code&gt;cmp     [rsp+0D8h+var_84], 64h ; &#39;d&#39;&lt;/code&gt;，这一比较再次决定跳转&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shift+E查看数据发现关键字符串：恭喜你获得flag，就在下面这段中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;.text:00007F14B368500E
.text:00007F14B368500E loc_7F14B368500E:
.text:00007F14B368500E lea     rax, unk_7F14B36E6F28
.text:00007F14B3685015 mov     [rsp+0D8h+var_C0], rax
.text:00007F14B368501A mov     [rsp+0D8h+var_B8], 1
.text:00007F14B3685023 mov     [rsp+0D8h+var_D0], 0
.text:00007F14B368502C mov     [rsp+0D8h+var_B0], rbx
.text:00007F14B3685031 mov     [rsp+0D8h+var_A8], 0
.text:00007F14B368503A lea     rdi, [rsp+0D8h+var_D0]
.text:00007F14B368503F call    cs:qword_7F14B36E9FA8
.text:00007F14B3685045 lea     rdi, [rsp+0D8h+var_D0]
.text:00007F14B368504A call    cs:qword_7F14B36E9C18
.text:00007F14B3685050 lea     rdi, [rsp+0D8h+var_D0]
.text:00007F14B3685055 mov     esi, 1
.text:00007F14B368505A call    cs:qword_7F14B36E9E80
.text:00007F14B3685060 lea     rdx, unk_7F14B36D2080
.text:00007F14B3685067 lea     rdi, [rsp+0D8h+var_A0]
.text:00007F14B368506C mov     ecx, 0Dh
.text:00007F14B3685071 mov     rsi, rax
.text:00007F14B3685074 call    cs:qword_7F14B36E9D50
.text:00007F14B368507A cmp     dword ptr [rsp+0D8h+var_A0], 0
.text:00007F14B368507F jnz     loc_7F14B3685275
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那我们就明白了，直接将64hpatch为01h，这样只需要一次正确即可找到flag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接着动调结束，让程序执行完，就会发现程序生成一个img.png，即为flag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;flag{d846b8394630f42e02fef698a4e3df1b}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-bad_pe&#34;&gt;二. bad_pe&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DIE查壳，没啥问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拖进IDA看看&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 start()
{
  unsigned __int64 v0; // rax
  HMODULE ModuleHandleA; // rax
  char *v2; // rdx
  int v3; // ecx
  char *v4; // r10
  __int64 v5; // r11
  char *v6; // r8
  char *v7; // rdx
  char i; // r9
  char *v9; // rcx
  void (*v10)(void); // r9
  unsigned __int64 v11; // rax
  char v13[14]; // [rsp+2Ah] [rbp-Eh] BYREF

  v0 = __rdtsc();
  dword_418004 = HIDWORD(v0);
  ModuleHandleA = GetModuleHandleA(0i64);
  strcpy(v13, &amp;quot;.ATOM&amp;quot;);
  v2 = (char *)ModuleHandleA + *((int *)ModuleHandleA + 15);
  v3 = *((unsigned __int16 *)v2 + 3);
  if ( (_WORD)v3 )
  {
    v4 = v2 + 264;
    v5 = (__int64)&amp;amp;v2[40 * (v3 - 1) + 304];
    while ( *v4 != 46 )
    {
LABEL_18:
      v4 += 40;
      if ( v4 == (char *)v5 )
        return 0i64;
    }
    v6 = v13;
    v7 = v4;
    for ( i = 65; ; i = v6[1] )
    {
      ++v7;
      ++v6;
      if ( *v7 != i )
        break;
      if ( !i )
        goto LABEL_10;
    }
    if ( *v7 || i )
      goto LABEL_18;
LABEL_10:
    v9 = (char *)ModuleHandleA + *((unsigned int *)v4 + 3);
    if ( *((_DWORD *)v4 + 2) )//0xdd12
    {
      v7 = 0i64;
      do
        (v7++)[(_QWORD)v9] ^= 0x23u;
      while ( *((_DWORD *)v4 + 2) &amp;gt; (unsigned int)v7 );
    }
    else if ( !v9 )
    {
      return 0i64;
    }
    v10 = (void (*)(void))sub_414140(v9, v7, v6);
    v11 = __rdtsc();
    dword_418000 = HIDWORD(v11);
    if ( (unsigned int)(HIDWORD(v11) - dword_418004) &amp;lt;= 1 )
      v10();
  }
  return 0i64;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;想动调解密，但发现PE文件格式魔改掉了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;放进010看看，发现一堆0x23&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写脚本去除：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;arr = 0x23
with open(&#39;C:\\Users\\lenovo\\Desktop\\bad_pe.exe&#39;, &#39;rb&#39;) as f:
    b = f.read()
b = bytearray(b)
for i in range(len(b)):
    b[i]^=0x23
with open(&#39;C:\\Users\\lenovo\\Desktop\\COD_de1&#39;, &#39;wb&#39;) as f:
    f.write(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现在2e00处开始是一个新的PE文件，dump出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data = open(&#39;C:\\Users\\lenovo\\Desktop\\COD_de1&#39;, &#39;rb&#39;).read()[0x2e00: 0x2e00 + 0xdd12]
data = bytes(i for i in data)
open(&#39;C:\\Users\\lenovo\\Desktop\\COD_de2&#39;, &#39;wb&#39;).write(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将新文件拖入IDA，成功找到main函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int128 *v3; // rdi
  int v4; // edx
  unsigned int v5; // eax
  signed __int64 v6; // rdi
  void *v7; // rsp
  void *v8; // rsp
  char *v9; // rax
  char *v10; // rdx
  char v11; // r8
  char v13[8]; // [rsp+30h] [rbp-B0h] BYREF
  __int64 v14; // [rsp+38h] [rbp-A8h] BYREF
  __int128 v15[2]; // [rsp+40h] [rbp-A0h] BYREF
  __int16 v16[8]; // [rsp+60h] [rbp-80h] BYREF
  char v17[112]; // [rsp+70h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  v3 = v15;
  v15[0] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_405130);
  v14 = 0x2179336B336874i64;
  v15[1] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_405140);
  qmemcpy(v16, &amp;quot;.~c&amp;quot;, 3);
  do
  {
    v4 = *(_DWORD *)v3;
    v3 = (__int128 *)((char *)v3 + 4);
    v5 = ~v4 &amp;amp; (v4 - 16843009) &amp;amp; 0x80808080;
  }
  while ( !v5 );
  if ( (~v4 &amp;amp; (v4 - 16843009) &amp;amp; 0x8080) == 0 )
    v5 &amp;gt;&amp;gt;= 16;
  if ( (~v4 &amp;amp; (v4 - 16843009) &amp;amp; 0x8080) == 0 )
    v3 = (__int128 *)((char *)v3 + 2);
  v6 = (char *)v3 - __CFADD__((_BYTE)v5, (_BYTE)v5) - 3 - (char *)v15;
  v7 = alloca(v6);
  v8 = alloca(v6);
  printf(&amp;quot;please input your flag:&amp;quot;);
  putchar(10);
  scanf(&amp;quot;%s&amp;quot;, v17);
  rc4_crypt((unsigned int)v17, v6, (unsigned int)&amp;amp;v14, 7, (__int64)v13);
  if ( v6 )
  {
    if ( v13[0] != -67 )
    {
LABEL_14:
      printf(&amp;quot;wrong!&amp;quot;);
      return 0;
    }
    v9 = v13;
    v10 = (char *)v15 + 1;
    while ( &amp;amp;v13[(unsigned int)(v6 - 1)] != v9 )
    {
      v11 = v9[1];
      ++v10;
      ++v9;
      if ( v11 != *(v10 - 1) )
        goto LABEL_14;
    }
  }
  printf(&amp;quot;successful!!&amp;quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意到RC4加密函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char *__fastcall rc4_crypt(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  __int64 v5; // r12
  int v6; // r10d
  __int128 *v7; // r11
  int v8; // eax
  char v9; // bl
  char *result; // rax
  __int64 v11; // rbx
  __int64 v12; // r11
  __int64 v13; // rdi
  char v14; // al
  char v15; // r10
  __int128 v16[18]; // [rsp+0h] [rbp-128h] BYREF

  LOBYTE(v5) = 0;
  v6 = 0;
  v16[0] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_405030);
  v7 = v16;
  v16[1] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_405040);
  v16[2] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_405050);
  v16[3] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_405060);
  v16[4] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_405070);
  v16[5] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_405080);
  v16[6] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_405090);
  v16[7] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_4050A0);
  v16[8] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_4050B0);
  v16[9] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_4050C0);
  v16[10] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_4050D0);
  v16[11] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_4050E0);
  v16[12] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_4050F0);
  v16[13] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_405100);
  v16[14] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_405110);
  v16[15] = (__int128)_mm_load_si128((const __m128i *)&amp;amp;xmmword_405120);
  do
  {
    v8 = v6;
    v9 = *(_BYTE *)v7;
    ++v6;
    v7 = (__int128 *)((char *)v7 + 1);
    v5 = (unsigned __int8)(v5 + v9 + *(_BYTE *)(a3 + v8 % a4));
    result = (char *)v16 + v5;
    *((_BYTE *)v7 - 1) = *((_BYTE *)v16 + v5);
    *((_BYTE *)v16 + v5) = v9;
  }
  while ( v6 != 256 );
  if ( (int)a2 &amp;gt; 0 )
  {
    v11 = (unsigned int)(a2 - 1);
    v12 = 0i64;
    LOBYTE(v13) = 0;
    LOBYTE(a2) = 0;
    while ( 1 )
    {
      v14 = *((_BYTE *)v16 + (unsigned __int8)(a2 + 1));
      a2 = (unsigned __int8)(a2 + 1);
      v15 = *((_BYTE *)v16 + (unsigned __int8)(v14 + v13));
      v13 = (unsigned __int8)(v14 + v13);
      *((_BYTE *)v16 + a2) = v15;
      *((_BYTE *)v16 + v13) = v14;
      *(_BYTE *)(a5 + v12) = *(_BYTE *)(a1 + v12) ^ *((_BYTE *)v16 + (unsigned __int8)(*((_BYTE *)v16 + a2) + v14));
      result = (char *)(v12 + 1);
      if ( v12 == v11 )
        break;
      ++v12;
    }
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到key&lt;code&gt;v14 = &#39;!y3k3ht&#39;;&lt;/code&gt;，再动调找密文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;0xBD, 0xF0, 0x4C, 0xD9, 0xD0, 0x29, 0xF2, 0x46, 0x08, 0xCC, 
0xC8, 0x9F, 0xBE, 0x4B, 0xEF, 0x67, 0x46, 0x04, 0xE6, 0x32, 
0xF3, 0xF6, 0xAA, 0xF0, 0xD1, 0xD8, 0xEC, 0x75, 0x49, 0x2F, 
0xCC, 0x26, 0x2E, 0x7E, 0x63
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套脚本解密即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def KSA(key):
    key_length = len(key)
    S = list(range(256))
    j = 0
    for i in range(256):
        j = (j + S[i] + key[i % key_length]) % 256
        S[i], S[j] = S[j], S[i]
    return S

def PRGA(S):
    i = 0
    j = 0
    while True:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        K = S[(S[i] + S[j]) % 256]
        yield K
        
def RC4(key):
    S = KSA(key)
    keystream = PRGA(S)
    return keystream


if __name__ == &#39;__main__&#39;:
    key = &#39;th3k3y!&#39;
    plaintext = [
        0xBD, 0xF0, 0x4C, 0xD9, 0xD0, 0x29, 0xF2, 0x46,
        0x08, 0xCC, 0xC8, 0x9F, 0xBE, 0x4B, 0xEF, 0x67, 
        0x46, 0x04, 0xE6, 0x32, 0xF3, 0xF6, 0xAA, 0xF0, 
        0xD1, 0xD8, 0xEC, 0x75, 0x49, 0x2F, 0xCC, 0x26, 
        0x2E, 0x7E, 0x63
    ]
    key = key.encode()
    keystream = RC4(key)

    ciphertext = []
    for b in plaintext:
        ciphertext.append(chr(b ^ next(keystream)))
    print(&amp;quot;&amp;quot;.join(ciphertext))
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;flag{th3_p3fi15_1s_v3ry_nicccccc!}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-babyre&#34;&gt;三. babyre&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定位关键函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 sub_140011F90()
{
  size_t v1; // [rsp+28h] [rbp+8h]
  int i; // [rsp+44h] [rbp+24h]

  sub_14001138E(&amp;amp;unk_140022066);
  sub_1400111A4(&amp;quot;plz input flag:\n&amp;quot;);
  sub_14001120D(&amp;amp;unk_14001ADD0, Buf1, 49i64);
  v1 = j_strlen(Buf1);
  if ( v1 == 48 )
  {
    for ( i = 0; i &amp;lt; v1 / 4; i += 3 )
      sub_14001107D(&amp;amp;Buf1[4 * i], v1 % 4);
    if ( !j_memcmp(Buf1, &amp;amp;unk_14001D000, 0x30ui64) )
      sub_1400111A4(&amp;quot;success&amp;quot;);
    else
      sub_1400111A4(&amp;quot;fail&amp;quot;);
    return 0i64;
  }
  else
  {
    sub_1400111A4(&amp;quot;fail&amp;quot;);
    return 0i64;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;看着逻辑很简单，就只有一个加密函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall sub_140011870(int *a1)
{
  char *v1; // rdi
  __int64 i; // rcx
  char v4[32]; // [rsp+0h] [rbp-20h] BYREF
  char v5; // [rsp+20h] [rbp+0h] BYREF
  unsigned int v6; // [rsp+24h] [rbp+4h]
  unsigned int v7; // [rsp+44h] [rbp+24h]
  unsigned int v8; // [rsp+64h] [rbp+44h]
  int j; // [rsp+84h] [rbp+64h]
  int v10; // [rsp+A8h] [rbp+88h]
  int v11; // [rsp+ACh] [rbp+8Ch]
  int v12; // [rsp+B0h] [rbp+90h]
  int v13; // [rsp+B4h] [rbp+94h]
  int v14; // [rsp+D8h] [rbp+B8h]
  int v15; // [rsp+DCh] [rbp+BCh]
  int v16; // [rsp+E0h] [rbp+C0h]
  int v17; // [rsp+E4h] [rbp+C4h]
  int v18; // [rsp+108h] [rbp+E8h]
  int v19; // [rsp+10Ch] [rbp+ECh]
  int v20; // [rsp+110h] [rbp+F0h]
  int v21; // [rsp+114h] [rbp+F4h]
  int k; // [rsp+134h] [rbp+114h]
  unsigned int v23; // [rsp+204h] [rbp+1E4h]
  unsigned int v24; // [rsp+208h] [rbp+1E8h]
  unsigned int v25; // [rsp+20Ch] [rbp+1ECh]

  v1 = &amp;amp;v5;
  for ( i = 78i64; i; --i )
  {
    *(_DWORD *)v1 = -858993460;
    v1 += 4;
  }
  sub_14001138E(&amp;amp;unk_140022066);
  v6 = *a1;
  v7 = a1[1];
  v8 = a1[2];
  srand(0xDEADC0DE);
  for ( j = 0; j &amp;lt; 32; ++j )
  {
    v10 = (unsigned __int8)v6;
    v11 = BYTE1(v6);
    v12 = BYTE2(v6);
    v13 = HIBYTE(v6);
    v14 = (unsigned __int8)v7;
    v15 = BYTE1(v7);
    v16 = BYTE2(v7);
    v17 = HIBYTE(v7);
    v18 = (unsigned __int8)v8;
    v19 = BYTE1(v8);
    v20 = BYTE2(v8);
    v21 = HIBYTE(v8);
    for ( k = 0; k &amp;lt; 4; ++k )
    {//相当于23*x+66
      *(&amp;amp;v10 + k) = (unsigned __int8)(23 * *((_BYTE *)&amp;amp;v10 + 4 * k) + 66);
      *(&amp;amp;v14 + k) = (unsigned __int8)(23 * *((_BYTE *)&amp;amp;v14 + 4 * k) + 66);
      *(&amp;amp;v18 + k) = (unsigned __int8)(23 * *((_BYTE *)&amp;amp;v18 + 4 * k) + 66);
    }//对应汇编代码：.text:00007FF6825219F6 movsxd  rax, [rbp+200h+var_EC]
//.text:00007FF6825219FD imul    eax, [rbp+rax*4+200h+var_178], 17h
//.text:00007FF682521A05 add     eax, 42h ; &#39;B&#39;
//.text:00007FF682521A08 and     eax, 0FFh
//.text:00007FF682521A0D movsxd  rcx, [rbp+200h+var_EC]
//.text:00007FF682521A14 mov     [rbp+rcx*4+200h+var_178], eax
    v6 = (v13 &amp;lt;&amp;lt; 24) | (v12 &amp;lt;&amp;lt; 16) | (v11 &amp;lt;&amp;lt; 8) | v10;//合并
    v7 = (v17 &amp;lt;&amp;lt; 24) | (v16 &amp;lt;&amp;lt; 16) | (v15 &amp;lt;&amp;lt; 8) | v14;
    v8 = (v21 &amp;lt;&amp;lt; 24) | (v20 &amp;lt;&amp;lt; 16) | (v19 &amp;lt;&amp;lt; 8) | v18;
    v23 = v7 &amp;gt;&amp;gt; 7;//类似于tea
    v24 = rand() + v23;
    v25 = (v7 &amp;gt;&amp;gt; 15) ^ (v7 &amp;lt;&amp;lt; 10) | 3;
    v6 += v24 + (rand() ^ v25);
    v23 = v8 &amp;gt;&amp;gt; 7;
    v24 = rand() + v23;
    v25 = (v8 &amp;gt;&amp;gt; 15) ^ (v8 &amp;lt;&amp;lt; 10) | 3;
    v7 += v24 + (rand() ^ v25);
    v23 = v6 &amp;gt;&amp;gt; 7;
    v24 = rand() + v23;
    v25 = (v6 &amp;gt;&amp;gt; 15) ^ (v6 &amp;lt;&amp;lt; 10) | 3;
    v8 += v24 + (rand() ^ v25);
  }
  *a1 = v6;
  a1[1] = v7;
  a1[2] = v8;
  return sub_14001132A(v4, &amp;amp;unk_14001ACC8);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键是将这个算法逆了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中有很多rand,&lt;strong&gt;seed种子是固定的0xDEADC0DE所以每次rand生成的值我们都知道&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//注：一些定义
typedef unsigned char   uint8;
#define _BYTE  uint8
#define _WORD  uint16
#define LOBYTE(w)           ((BYTE)(((DWORD_PTR)(w)) &amp;amp; 0xff))
#define HIBYTE(w)           ((BYTE)((((DWORD_PTR)(w)) &amp;gt;&amp;gt; 8) &amp;amp; 0xff))
#define BYTEn(x, n)   (*((_BYTE*)&amp;amp;(x)+n))
#define WORDn(x, n)   (*((_WORD*)&amp;amp;(x)+n))
#define BYTE0(x)   BYTEn(x,  0)         // byte 0 (counting from 0)  添加此宏定义
#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)
#define BYTE2(x)   BYTEn(x,  2)
#define BYTE3(x)   BYTEn(x,  3)
#define BYTE4(x)   BYTEn(x,  4)
typedef unsigned long DWORD_PTR;

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意：逆的时候记得求一下逆元：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(inverse(23,256))  #167
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先把加密函数模拟出来，然后就更方便的编写解密函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意unsigned，和IDA提取保持一只即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
unsigned int my_rand[32][6]={0};
void encrypt(char* data,int* data2)
{
    int my_rand[6]={0};
    srand(0xDEADC0DE);
    for(int i=0;i&amp;lt;32;i++)
    {
        for(int j=0;j&amp;lt;12;j++)
        {
            data[j]=data[j]*23+66;
        }
        for(int z=0;z&amp;lt;3;z++)
        {
            data2[z]=(data[4*z+3]&amp;lt;&amp;lt;24)|(data[4*z+2]&amp;lt;&amp;lt;16)|(data[4*z+1]&amp;lt;&amp;lt;8)|data[4*z];
        }
        for(int k=0;k&amp;lt;6;k++)
        {
            my_rand[k]=rand();
        }
    int v23=data2[1]&amp;gt;&amp;gt;7;
    int v24=my_rand[0]+v23;
    int v25=(data2[1]&amp;gt;&amp;gt;15)^(data2[1]&amp;lt;&amp;lt;10)|3;
    data2[0]+=v24+(my_rand[1]^v25);

    v23=data2[2]&amp;gt;&amp;gt;7;
    v24=my_rand[2]+v23;
    v25=(data2[2]&amp;gt;&amp;gt;15)^(data2[2]&amp;lt;&amp;lt;10)|3;
    data2[1]+=v24+(my_rand[3]^v25);

    v23=data2[0]&amp;gt;&amp;gt;7;
    v24=my_rand[4]+v23;
    v25=(data2[0]&amp;gt;&amp;gt;15)^(data2[0]&amp;lt;&amp;lt;10)|3;
    data2[2]+=v24+(my_rand[5]^v25);
    }
    for(int z=0;z&amp;lt;3;z++)
    {
        data[4*z]=(char)(data2[z]&amp;amp;0xff);
        data[4*z+1]=(char)((data2[z]&amp;gt;&amp;gt;8)&amp;amp;0xff);
        data[4*z+2]=(char)((data2[z]&amp;gt;&amp;gt;16)&amp;amp;0xff);
        data[4*z+3]=(char)((data2[z]&amp;gt;&amp;gt;24)&amp;amp;0xff);
    }
}
void decrypt(unsigned char* data,unsigned int* data2)
{
    srand(0xDEADC0DE);
    for(int i=0;i&amp;lt;32;i++)
    {
        for(int j=0;j&amp;lt;6;j++)
        {
            my_rand[i][j]=rand();
        }
    }
    for(int i=31;i&amp;gt;=0;i--)
    {
        unsigned int v23=data2[0]&amp;gt;&amp;gt;7;
        unsigned int v24=my_rand[i][4]+v23;
        unsigned int v25=(data2[0]&amp;gt;&amp;gt;15)^(data2[0]&amp;lt;&amp;lt;10)|3;
        data2[2]-=v24+(my_rand[i][5]^v25);

        v23=data2[2]&amp;gt;&amp;gt;7;
        v24=my_rand[i][2]+v23;
        v25=(data2[2]&amp;gt;&amp;gt;15)^(data2[2]&amp;lt;&amp;lt;10)|3;
        data2[1]-=v24+(my_rand[i][3]^v25);

        v23=data2[1]&amp;gt;&amp;gt;7;
        v24=my_rand[i][0]+v23;
        v25=(data2[1]&amp;gt;&amp;gt;15)^(data2[1]&amp;lt;&amp;lt;10)|3;
        data2[0]-=v24+(my_rand[i][1]^v25);
        for(int z=0;z&amp;lt;3;z++)
        {
            data[4*z]=(unsigned char)(data2[z]&amp;amp;0xff);
            data[4*z+1]=(unsigned char)((data2[z]&amp;gt;&amp;gt;8)&amp;amp;0xff);
            data[4*z+2]=(unsigned char)((data2[z]&amp;gt;&amp;gt;16)&amp;amp;0xff);
            data[4*z+3]=(unsigned char)((data2[z]&amp;gt;&amp;gt;24)&amp;amp;0xff);
        }
        for(int j=0;j&amp;lt;12;j++)
        {
            data[j]=167*(data[j]-66 &amp;amp; 0xff);
        }
        for(int z=0;z&amp;lt;3;z++)
        {
            data2[z]=(data[4*z+3]&amp;lt;&amp;lt;24)|(data[4*z+2]&amp;lt;&amp;lt;16)|(data[4*z+1]&amp;lt;&amp;lt;8)|data[4*z];
        }
    }
}

int main() {
    unsigned char data[] =
    {
        0x48, 0x4D, 0x3B, 0xA0, 0x27, 0x31, 0x28, 0x54,
        0x6D, 0xF1, 0x21, 0x35, 0x18, 0x73, 0x6A, 0x4C,
        0x71, 0x3B, 0xBD, 0x98, 0xB6, 0x5A, 0x77, 0x2D,
        0x0B, 0x2B, 0xCB, 0x9B, 0xE4, 0x8A, 0x4C, 0xA9,
        0x5C, 0x4F, 0x1B, 0xF1, 0x98, 0x3D, 0x30, 0x59,
        0x3F, 0x14, 0xFC, 0x7A, 0xF4, 0x64, 0x02, 0x2B
    };
    unsigned int data2[]={0xA03B4D48, 0x54283127, 0x3521F16D, 0x4C6A7318, 0x98BD3B71, 0x2D775AB6, 0x9BCB2B0B, 0xA94C8AE4, 0xF11B4F5C, 0x59303D98, 0x7AFC143F, 0x2B0264F4};
    decrypt((unsigned char*)data,(unsigned int*)data2);
    decrypt((unsigned char*)data+12,(unsigned int*)data2+3);
    decrypt((unsigned char*)data+24,(unsigned int*)data2+6);
    decrypt((unsigned char*)data+36,(unsigned int*)data2+9);
    puts(data);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里脚本我用了两个数组，好像一个就可以hhh&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行得到：&lt;em&gt;&lt;strong&gt;flag{1CpOVOIeB1d2FcYUvnN1k5PbfMzMNzUzUgV6mB7hXF}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评价：个人脚本能力依托答辩www&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四-statemachine&#34;&gt;四. StateMachine&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;看到init函数里面的src和四个看着像密钥的东西，其实可以先猜一下是tea，但是没有delta（十分逆向七分猜（bushi））&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall main(int a1, char **a2, char **a3)
{
  puts(&amp;quot;Welcome! Drill Down.&amp;quot;);
  sub_21D8(&amp;quot;Welcome! Drill Down.&amp;quot;, a2);
  sub_2407();
  putchar(10);
  return 0LL;
}


unsigned __int64 sub_21D8()  //init
{
  int i; // [rsp+4h] [rbp-43Ch]
  __int64 src[4]; // [rsp+10h] [rbp-430h] BYREF
  char v3[1024]; // [rsp+30h] [rbp-410h] BYREF
  unsigned __int64 v4; // [rsp+438h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  for ( i = 0; i &amp;lt;= 9; ++i )
    byte_5104[8 * i] = 1;
  byte_5154 = 1;
  byte_5558 = 1;
  byte_5621 = 1;
  qmemcpy(v3, &amp;amp;unk_3020, 0x157uLL);
  memset(&amp;amp;v3[343], 0, 681);
  qmemcpy(&amp;amp;unk_5158, v3, 0x400uLL);
  memset(&amp;amp;byte_5559[40], 0, 0x2CuLL);
  byte_5559[40] = 119;
  byte_5559[41] = 105;
  byte_5559[42] = 110;
  byte_5559[43] = 33;
  byte_5559[44] = 102;
  byte_5559[45] = 97;
  byte_5559[46] = 105;
  byte_5559[47] = 108;  //win!fail
  byte_5559[24] = 17;
  byte_5559[28] = 34;
  byte_5559[32] = -120;
  byte_5559[36] = -1;
  src[0] = 0x3A84F4140FB6B1B8LL;
  src[1] = 0xB485900290CE01CBLL;
  src[2] = 0x2D7458B7EA807F7CLL;
  src[3] = 0LL;
  memcpy(&amp;amp;byte_5559[88], src, 0x18uLL);
  return v4 - __readfsqword(0x28u);
}

int sub_2407()
{
  int i; // [rsp+8h] [rbp-8h]
  int j; // [rsp+Ch] [rbp-4h]

  for ( i = 0; i &amp;lt;= 9; ++i )
    pthread_create(&amp;amp;qword_5080[i], 0LL, start_routine, (char *)&amp;amp;unk_5020 + 4 * i);//根据地址，确定thread[0-9]
  pthread_create(&amp;amp;th, 0LL, sub_1C41, 0LL);//th=thread[10]
  pthread_create(&amp;amp;qword_50D8, 0LL, sub_1EFF, 0LL);//50D8=thread[11]
  pthread_create(&amp;amp;qword_50E0, 0LL, sub_1F91, 0LL);//50E0=thread[12]
  for ( j = 0; j &amp;lt;= 9; ++j )
    pthread_join(qword_5080[j], 0LL);
  pthread_join(th, 0LL);
  pthread_join(qword_50D8, 0LL);
  return pthread_join(qword_50E0, 0LL);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void __fastcall __noreturn start_routine(int *a1)
{
  int v1; // eax
  int i; // [rsp+18h] [rbp-18h]
  int v3; // [rsp+1Ch] [rbp-14h]
  int v4; // [rsp+20h] [rbp-10h]
  int v5; // [rsp+24h] [rbp-Ch]
  int v6; // [rsp+28h] [rbp-8h]
  int v7; // [rsp+2Ch] [rbp-4h]

  v3 = *a1;
  for ( i = 1; i &amp;lt;= (int)&amp;amp;unk_F423F; ++i )
  {
    *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3) = *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3 - 329);
    while ( !byte_5154[1316 * i - 1316] )
      ;
    while ( !byte_5558[1316 * i - 1316] )
      ;
    v4 = sub_1249((unsigned int)(i - 1), *((unsigned int *)&amp;amp;unk_5150 + 329 * i - 329));
    if ( v4 != 29 || v3 )
    {
      if ( v4 == 31 )
        break;
      if ( v3 == (unsigned int)sub_1321(
                                 (unsigned int)(i - 1),
                                 (unsigned int)(*((_DWORD *)&amp;amp;unk_5150 + 329 * i - 329) + 5)) )
      {
        if ( (v4 &amp;amp; 0x18) != 0 )
        {
          if ( (v4 &amp;amp; 0x18) == 8 )
          {
            v6 = sub_13F9((unsigned int)(i - 1), (unsigned int)(*((_DWORD *)&amp;amp;unk_5150 + 329 * i - 329) + 9));
            switch ( v4 &amp;amp; 7 )
            {
              case 0:
                *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3) = v6 + *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3 - 329);
                break;
              case 1:
                *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3) = *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3 - 329) - v6;
                break;
              case 2:
                *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3) = v6;
                break;
              case 3:
                *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3) = *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3 - 329) &amp;lt;&amp;lt; v6;
                break;
              case 4:
                *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3) = *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3 - 329) &amp;gt;&amp;gt; v6;
                break;
              default:
                break;
            }
          }
          else if ( v4 == 16 )
          {
            v5 = sub_1321((unsigned int)(i - 1), (unsigned int)(*((_DWORD *)&amp;amp;unk_5150 + 329 * i - 329) + 9));
            do
            {
              while ( !byte_5104[1316 * i - 1316 + 8 * v5] )
                ;
            }
            while ( !byte_5621[1316 * i - 1316] );
            *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3) = (unsigned __int8)byte_5559[1316 * i
                                                                                 - 1316
                                                                                 + *((unsigned int *)&amp;amp;unk_5100
                                                                                   + 329 * i
                                                                                   + 2 * v5
                                                                                   - 329)];
          }
        }
        else
        {
          v7 = sub_1321((unsigned int)(i - 1), (unsigned int)(*((_DWORD *)&amp;amp;unk_5150 + 329 * i - 329) + 9));
          while ( !byte_5104[1316 * i - 1316 + 8 * v7] )
            ;
          v1 = v4 &amp;amp; 7;
          if ( v1 == 3 )
          {
            *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3) = *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v7 - 329) ^ *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3 - 329);
          }
          else if ( (v4 &amp;amp; 7u) &amp;lt;= 3 )
          {
            if ( v1 == 2 )
            {
              *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3) = *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v7 - 329);
            }
            else if ( (v4 &amp;amp; 7) != 0 )
            {
              *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3) = *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3 - 329)
                                                        - *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v7 - 329);
            }
            else
            {
              *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3) = *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v3 - 329)
                                                        + *((_DWORD *)&amp;amp;unk_5100 + 329 * i + 2 * v7 - 329);
            }
          }
        }
      }
    }
    else
    {
      *((_DWORD *)&amp;amp;unk_5100 + 329 * i) = getchar();
    }
    byte_5104[1316 * i + 8 * v3] = 1;
  }
  pthread_exit(0LL);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void __fastcall __noreturn sub_1C41(void *a1)
{
  int i; // [rsp+4h] [rbp-Ch]
  int v2; // [rsp+8h] [rbp-8h]
  int v3; // [rsp+Ch] [rbp-4h]

  for ( i = 1; i &amp;lt;= &amp;amp;unk_1869F; ++i )
  {
    *(&amp;amp;unk_5150 + 329 * i) = *(&amp;amp;unk_5150 + 329 * i - 329);
    while ( !byte_5558[1316 * i - 1316] )
      ;
    v2 = sub_1249((i - 1), *(&amp;amp;unk_5150 + 329 * i - 329));
    if ( (v2 &amp;amp; 0x18) != 0 &amp;amp;&amp;amp; (v2 &amp;amp; 0x18) != 16 )
    {
      if ( (v2 &amp;amp; 0x18) == 24 )
      {
        *(&amp;amp;unk_5150 + 329 * i) = *(&amp;amp;unk_5150 + 329 * i - 329) + 5;
        if ( v2 == 28 )
        {
          while ( !*(&amp;amp;byte_5104 + 1316 * i - 1316) )
            ;
          putchar(*(&amp;amp;unk_5100 + 329 * i - 329));
        }
        if ( v2 == 31 )
          break;
      }
      else if ( (v2 &amp;amp; 0x18) == 8 )
      {
        *(&amp;amp;unk_5150 + 329 * i) = *(&amp;amp;unk_5150 + 329 * i - 329) + 25;
        if ( v2 == 15 )
        {
          v3 = sub_1321((i - 1), (*(&amp;amp;unk_5150 + 329 * i - 329) + 5));
          while ( !*(&amp;amp;byte_5104 + 1316 * i + 8 * v3 - 1316) )
            ;
          if ( *(&amp;amp;unk_5100 + 329 * i + 2 * v3 - 329) )
            *(&amp;amp;unk_5150 + 329 * i) = sub_13F9((i - 1), (*(&amp;amp;unk_5150 + 329 * i - 329) + 9));
        }
      }
    }
    else
    {
      *(&amp;amp;unk_5150 + 329 * i) = *(&amp;amp;unk_5150 + 329 * i - 329) + 13;
    }
    byte_5154[1316 * i] = 1;
  }
  pthread_exit(0LL);
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void __fastcall __noreturn sub_1EFF(void *a1)
{
  int i; // [rsp+Ch] [rbp-4h]

  for ( i = 1; i &amp;lt;= &amp;amp;unk_1869F; ++i )
  {
    memcpy(&amp;amp;unk_5100 + 1316 * i + 88, &amp;amp;unk_5100 + 1316 * i - 1228, 0x400uLL);
    byte_5558[1316 * i] = 1;
  }
  pthread_exit(0LL);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void __fastcall __noreturn sub_1F91(void *a1)
{
  int i; // [rsp+0h] [rbp-10h]
  int v2; // [rsp+4h] [rbp-Ch]
  int v3; // [rsp+8h] [rbp-8h]
  int v4; // [rsp+Ch] [rbp-4h]

  for ( i = 1; i &amp;lt;= &amp;amp;unk_1869F; ++i )
  {
    memcpy(&amp;amp;unk_5100 + 1316 * i + 1113, &amp;amp;unk_5100 + 1316 * i - 203, 0xC8uLL);
    while ( !byte_5154[1316 * i - 1316] )
      ;
    while ( !byte_5558[1316 * i - 1316] )
      ;
    v2 = sub_1249(i - 1, *(&amp;amp;unk_5150 + 329 * i - 329));
    if ( v2 == 17 )
    {
      v3 = sub_1321((i - 1), (*(&amp;amp;unk_5150 + 329 * i - 329) + 5));
      v4 = sub_1321((i - 1), (*(&amp;amp;unk_5150 + 329 * i - 329) + 9));
      do
      {
        while ( !byte_5104[1316 * i - 1316 + 8 * v3] )
          ;
      }
      while ( !byte_5104[1316 * i - 1316 + 8 * v4] );
      byte_5559[1316 * i + *(&amp;amp;unk_5100 + 329 * i + 2 * v4 - 329)] = *(&amp;amp;unk_5100 + 329 * i + 2 * v3 - 329);
    }
    else if ( v2 == 31 )
    {
      break;
    }
    byte_5621[1316 * i] = 1;
  }
  pthread_exit(0LL);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall sub_1249(int a1, unsigned int a2)
{
  unsigned int v3; // [rsp+Ch] [rbp-Ch]
  unsigned int v4; // [rsp+10h] [rbp-8h]

  v3 = a2 &amp;gt;&amp;gt; 3;
  v4 = a2 &amp;amp; 7;
  if ( v4 &amp;gt; 3 )
    return (*(&amp;amp;unk_5158 + 1316 * a1 + v3) &amp;gt;&amp;gt; v4) | ((((1 &amp;lt;&amp;lt; ((a2 &amp;amp; 7) - 3)) - 1) &amp;amp; *(&amp;amp;unk_5158 + 1316 * a1 + v3 + 1)) &amp;lt;&amp;lt; (8 - v4));
  else
    return (*(&amp;amp;unk_5158 + 1316 * a1 + v3) &amp;gt;&amp;gt; v4) &amp;amp; 0x1F;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall sub_1321(int a1, unsigned int a2)
{
  unsigned int v3; // [rsp+Ch] [rbp-Ch]
  unsigned int v4; // [rsp+10h] [rbp-8h]

  v3 = a2 &amp;gt;&amp;gt; 3;
  v4 = a2 &amp;amp; 7;
  if ( v4 &amp;gt; 4 )
    return (*(&amp;amp;unk_5158 + 1316 * a1 + v3) &amp;gt;&amp;gt; v4) | ((((1 &amp;lt;&amp;lt; ((a2 &amp;amp; 7) - 4)) - 1) &amp;amp; *(&amp;amp;unk_5158 + 1316 * a1 + v3 + 1)) &amp;lt;&amp;lt; (8 - v4));
  else
    return (*(&amp;amp;unk_5158 + 1316 * a1 + v3) &amp;gt;&amp;gt; v4) &amp;amp; 0xF;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall sub_13F9(int a1, unsigned int a2)
{
  unsigned int v3; // [rsp+Ch] [rbp-Ch]

  v3 = a2 &amp;gt;&amp;gt; 3;
  if ( (a2 &amp;amp; 7) != 0 )
    return (*(&amp;amp;unk_5158 + 1316 * a1 + v3) &amp;gt;&amp;gt; (a2 &amp;amp; 7)) | (*(&amp;amp;unk_5158 + 1316 * a1 + v3 + 1) &amp;lt;&amp;lt; (8 - (a2 &amp;amp; 7))) | ((((1 &amp;lt;&amp;lt; (a2 &amp;amp; 7)) - 1) &amp;amp; *(&amp;amp;unk_5158 + 1316 * a1 + v3 + 2)) &amp;lt;&amp;lt; (16 - (a2 &amp;amp; 7)));
  else
    return *(&amp;amp;unk_5158 + 1316 * a1 + v3) | (*(&amp;amp;unk_5158 + 1316 * a1 + v3 + 1) &amp;lt;&amp;lt; 8);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;翻译一下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl main(int argc, const char **argv, const char **envp)
{
  puts(&amp;quot;Welcome! Drill Down.&amp;quot;);
  init_vm();
  run_vm();
  putchar(10);
  return 0;
}

void __fastcall init_vm()
{
  int i; // [rsp+4h] [rbp-43Ch]
  __int64 src[4]; // [rsp+10h] [rbp-430h] BYREF
  char v2[1024]; // [rsp+30h] [rbp-410h] BYREF
  unsigned __int64 v3; // [rsp+438h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  for ( i = 0; i &amp;lt;= 9; ++i )
    vm_ins[0].reg[i].ready = 1;
  vm_ins[0].pc_ready = 1;
  vm_ins[0].code_ready = 1;
  vm_ins[0].memory_ready = 1;
  qmemcpy(v2, byte_3020, 343uLL);
  v2[343] = 0;
  memset(&amp;amp;v2[344], 0, 680uLL);
  qmemcpy(vm_ins[0].code, v2, sizeof(vm_ins[0].code));
  memset(&amp;amp;vm_ins[0].memory[40], 0, 44uLL);
  qmemcpy(&amp;amp;vm_ins[0].memory[40], &amp;quot;win!fail&amp;quot;, 8);
  vm_ins[0].memory[24] = 0x11;
  vm_ins[0].memory[28] = 0x22;
  vm_ins[0].memory[32] = 0x88;
  vm_ins[0].memory[36] = 0xFF;
  src[0] = 0x3A84F4140FB6B1B8LL;
  src[1] = 0xB485900290CE01CBLL;
  src[2] = 0x2D7458B7EA807F7CLL;
  src[3] = 0LL;
  memcpy(&amp;amp;vm_ins[0].memory[88], src, 0x18uLL);
}

void __fastcall run_vm()
{
  int i; // [rsp+8h] [rbp-8h]
  int j; // [rsp+Ch] [rbp-4h]

  for ( i = 0; i &amp;lt;= 9; ++i )
    pthread_create(&amp;amp;threads[i], 0LL, (void *(*)(void *))start_routine, &amp;amp;dword_5020[i]);
  pthread_create(&amp;amp;threads[10], 0LL, (void *(*)(void *))prepare_pc, 0LL);
  pthread_create(&amp;amp;threads[11], 0LL, (void *(*)(void *))prepare_code, 0LL);
  pthread_create(&amp;amp;threads[12], 0LL, (void *(*)(void *))prepare_memory, 0LL);
  for ( j = 0; j &amp;lt;= 9; ++j )
    pthread_join(threads[j], 0LL);
  pthread_join(threads[10], 0LL);
  pthread_join(threads[11], 0LL);
  pthread_join(threads[12], 0LL);
}

void __fastcall start_routine(unsigned int *arg)
{
  int v1; // eax
  int i; // [rsp+18h] [rbp-18h]
  unsigned int reg_index; // [rsp+1Ch] [rbp-14h]
  unsigned int opcode; // [rsp+20h] [rbp-10h]
  unsigned int v5; // [rsp+24h] [rbp-Ch]
  unsigned int imm; // [rsp+28h] [rbp-8h]
  unsigned int v7; // [rsp+2Ch] [rbp-4h]

  reg_index = *arg;
  for ( i = 1; i &amp;lt;= 999999; ++i )
  {
    vm_ins[i].reg[reg_index].value = vm_ins[i - 1].reg[reg_index].value;
    while ( !vm_ins[i - 1].pc_ready )
      ;
    while ( !vm_ins[i - 1].code_ready )
      ;
    opcode = fetch_opcode(i - 1, vm_ins[i - 1].pc);
    if ( opcode != 29 || reg_index )
    {
      if ( opcode == 31 )
        break;
      if ( reg_index == fetch_reg_index(i - 1, vm_ins[i - 1].pc + 5) )
      {
        if ( (opcode &amp;amp; 0x18) != 0 )
        {
          if ( (opcode &amp;amp; 0x18) == 8 )
          {
            imm = fetch_imm16(i - 1, vm_ins[i - 1].pc + 9);
            switch ( opcode &amp;amp; 7 )
            {
              case 0u:
                vm_ins[i].reg[reg_index].value = imm + vm_ins[i - 1].reg[reg_index].value;
                break;
              case 1u:
                vm_ins[i].reg[reg_index].value = vm_ins[i - 1].reg[reg_index].value - imm;
                break;
              case 2u:
                vm_ins[i].reg[reg_index].value = imm;
                break;
              case 3u:
                vm_ins[i].reg[reg_index].value = vm_ins[i - 1].reg[reg_index].value &amp;lt;&amp;lt; imm;
                break;
              case 4u:
                vm_ins[i].reg[reg_index].value = vm_ins[i - 1].reg[reg_index].value &amp;gt;&amp;gt; imm;
                break;
              default:
                break;
            }
          }
          else if ( opcode == 16 )
          {
            v5 = fetch_reg_index(i - 1, vm_ins[i - 1].pc + 9);
            do
            {
              while ( !vm_ins[i - 1].reg[v5].ready )
                ;
            }
            while ( !vm_ins[i - 1].memory_ready );
            vm_ins[i].reg[reg_index].value = (unsigned __int8)vm_ins[i - 1].memory[vm_ins[i - 1].reg[v5].value];
          }
        }
        else
        {
          v7 = fetch_reg_index(i - 1, vm_ins[i - 1].pc + 9);
          while ( !vm_ins[i - 1].reg[v7].ready )
            ;
          v1 = opcode &amp;amp; 7;
          if ( v1 == 3 )
          {
            vm_ins[i].reg[reg_index].value = vm_ins[i - 1].reg[v7].value ^ vm_ins[i - 1].reg[reg_index].value;
          }
          else if ( (opcode &amp;amp; 7) &amp;lt;= 3 )
          {
            if ( v1 == 2 )
            {
              vm_ins[i].reg[reg_index].value = vm_ins[i - 1].reg[v7].value;
            }
            else if ( (opcode &amp;amp; 7) != 0 )
            {
              vm_ins[i].reg[reg_index].value = vm_ins[i - 1].reg[reg_index].value - vm_ins[i - 1].reg[v7].value;
            }
            else
            {
              vm_ins[i].reg[reg_index].value = vm_ins[i - 1].reg[reg_index].value + vm_ins[i - 1].reg[v7].value;
            }
          }
        }
      }
    }
    else
    {
      vm_ins[i].reg[0].value = getchar();
    }
    vm_ins[i].reg[reg_index].ready = 1;
  }
  pthread_exit(0LL);
}

void __fastcall __noreturn prepare_pc(void *arg)
{
  int i; // [rsp+4h] [rbp-Ch]
  unsigned int v2; // [rsp+8h] [rbp-8h]
  unsigned int v3; // [rsp+Ch] [rbp-4h]

  for ( i = 1; i &amp;lt;= 99999; ++i )
  {
    vm_ins[i].pc = vm_ins[i - 1].pc;
    while ( !vm_ins[i - 1].code_ready )
      ;
    v2 = fetch_opcode(i - 1, vm_ins[i - 1].pc);
    if ( (v2 &amp;amp; 0x18) != 0 &amp;amp;&amp;amp; (v2 &amp;amp; 0x18) != 0x10 )
    {
      if ( (v2 &amp;amp; 0x18) == 0x18 )
      {
        vm_ins[i].pc = vm_ins[i - 1].pc + 5;
        if ( v2 == 28 )
        {
          while ( !vm_ins[i - 1].reg[0].ready )
            ;
          putchar((char)vm_ins[i - 1].reg[0].value);
        }
        if ( v2 == 31 )
          break;
      }
      else if ( (v2 &amp;amp; 0x18) == 8 )
      {
        vm_ins[i].pc = vm_ins[i - 1].pc + 25;
        if ( v2 == 15 )
        {
          v3 = fetch_reg_index(i - 1, vm_ins[i - 1].pc + 5);
          while ( !vm_ins[i - 1].reg[v3].ready )
            ;
          if ( vm_ins[i - 1].reg[v3].value )
            vm_ins[i].pc = fetch_imm16(i - 1, vm_ins[i - 1].pc + 9);
        }
      }
    }
    else
    {
      vm_ins[i].pc = vm_ins[i - 1].pc + 13;
    }
    vm_ins[i].pc_ready = 1;
  }
  pthread_exit(0LL);
}

void __fastcall __noreturn prepare_code(void *arg)
{
  int i; // [rsp+Ch] [rbp-4h]

  for ( i = 1; i &amp;lt;= 99999; ++i )
  {
    memcpy(vm_ins[i].code, vm_ins[i - 1].code, sizeof(vm_ins[i].code));
    vm_ins[i].code_ready = 1;
  }
  pthread_exit(0LL);
}

void __fastcall __noreturn prepare_memory(void *arg)
{
  int i; // [rsp+0h] [rbp-10h]
  unsigned int v2; // [rsp+4h] [rbp-Ch]
  unsigned int v3; // [rsp+8h] [rbp-8h]
  unsigned int v4; // [rsp+Ch] [rbp-4h]

  for ( i = 1; i &amp;lt;= 99999; ++i )
  {
    memcpy(vm_ins[i].memory, vm_ins[i - 1].memory, sizeof(vm_ins[i].memory));
    while ( !vm_ins[i - 1].pc_ready )
      ;
    while ( !vm_ins[i - 1].code_ready )
      ;
    v2 = fetch_opcode(i - 1, vm_ins[i - 1].pc);
    if ( v2 == 17 )
    {
      v3 = fetch_reg_index(i - 1, vm_ins[i - 1].pc + 5);
      v4 = fetch_reg_index(i - 1, vm_ins[i - 1].pc + 9);
      do
      {
        while ( !vm_ins[i - 1].reg[v3].ready )
          ;
      }
      while ( !vm_ins[i - 1].reg[v4].ready );
      vm_ins[i].memory[vm_ins[i - 1].reg[v4].value] = vm_ins[i - 1].reg[v3].value;
    }
    else if ( v2 == 31 )
    {
      break;
    }
    vm_ins[i].memory_ready = 1;
  }
  pthread_exit(0LL);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开了很多并行独立程序，实现了一个类似于实际 CPU 执行的 vm，在计算机使用者的角度不用考虑 CPU 的具体设计，只要知道指令是顺序执行的就行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面进行提取执行的指令：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;codes = open(&#39;./vm&#39;, &#39;rb&#39;).read()[0x3020: 0x3020 + 0x157]
codes = &#39;&#39;.join(bin(i)[2: ].rjust(8, &#39;0&#39;)[:: -1] for i in codes)

def fetch_imm(codes, pc, size):
    assert pc + size &amp;lt;= len(codes)
    value = int(codes[pc: pc + size][:: -1], 2)
    return value, pc + size

def fetch_opcode(codes, pc):
    return fetch_imm(codes, pc, 5)

def fetch_reg_index(codes, pc):
    return fetch_imm(codes, pc, 4)

def fetch_imm16(codes, pc):
    return fetch_imm(codes, pc, 16)

regs = [&#39;rax&#39;, &#39;rbp&#39;, &#39;r8&#39;, &#39;r9&#39;, &#39;r10&#39;, &#39;r11&#39;, &#39;r12&#39;, &#39;r13&#39;, &#39;r14&#39;, &#39;r15&#39;]

print(&#39;.intel_syntax noprefix&#39;)
pc = 0
while pc &amp;lt; len(codes):
    print(&#39;_0x%04x: &#39; % pc, end=&#39;&#39;)
    opcode, pc = fetch_opcode(codes, pc)
    if opcode == 15:
        dreg, pc = fetch_reg_index(codes, pc)
        imm, pc = fetch_imm16(codes, pc)
        print(&#39;cmp %s, 0\n  jnz _0x%04x&#39; % (regs[dreg], imm))
    elif opcode == 17:
        dreg, pc = fetch_reg_index(codes, pc)
        sreg, pc = fetch_reg_index(codes, pc)
        print(&#39;mov [%s + 0x2000], %s&#39; % (regs[sreg], regs[dreg]))
    elif opcode == 28:
        print(&#39;call m_putchar&#39;)
    elif opcode == 29:
        print(&#39;call m_getchar&#39;)
    elif opcode == 31:
        print(&#39;ret&#39;)
    elif opcode == 16:
        dreg, pc = fetch_reg_index(codes, pc)
        sreg, pc = fetch_reg_index(codes, pc)
        print(&#39;mov %s, [%s + 0x2000]&#39; % (regs[dreg], regs[sreg]))
    elif opcode &amp;amp; 0x18 == 8:
        dreg, pc = fetch_reg_index(codes, pc)
        imm, pc = fetch_imm16(codes, pc)
        op = [&#39;add&#39;, &#39;sub&#39;, &#39;mov&#39;, &#39;shl&#39;, &#39;shr&#39;][opcode &amp;amp; 7]
        print(&#39;%s %s, 0x%x&#39; % (op, regs[dreg], imm))
    elif opcode &amp;amp; 0x18 == 0:
        dreg, pc = fetch_reg_index(codes, pc)
        sreg, pc = fetch_reg_index(codes, pc)
        op = [&#39;add&#39;, &#39;sub&#39;, &#39;mov&#39;, &#39;xor&#39;][opcode &amp;amp; 7]
        print(&#39;%s %s, %s&#39; % (op, regs[dreg], regs[sreg]))
    else:
        assert False, hex(opcode)

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行，得到指令存在main.s中，gcc -c ./main.s -o main.o，编译好用IDA分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall 0x0000(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // r8
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // r8
  __int64 v7; // rbp
  unsigned __int64 v8; // r10
  __int64 v9; // r8
  unsigned __int64 v10; // r11
  __int64 v11; // rbp
  __int64 v12; // rax
  __int64 v13; // r13
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // r14
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // r13
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // r14
  __int64 v23; // rax
  __int64 v24; // rbp
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // rdx
  __int64 v28; // rcx
  __int64 v29; // r8
  __int64 v30; // r9
  __int64 v31; // rdx
  __int64 v32; // rcx
  __int64 v33; // r8
  __int64 v34; // r9
  __int64 v35; // rdx
  __int64 v36; // rcx
  __int64 v37; // r8
  __int64 v38; // r9

  v2 = 24i64;
  v3 = 0i64;
  do
  {
    v4 = m_getchar(a1, a2, v3);
    *(_QWORD *)(v5 + 0x2000) = v4;
    --v2;
    v3 = v5 + 1;
  }
  while ( v2 );
  do
  {
    v6 = 4i64;
    v7 = 8i64 * MEMORY[0x2030];
    v8 = 0i64;
    do
    {
      v8 = *(_QWORD *)(v7 + 0x2000) ^ (v8 &amp;lt;&amp;lt; 8);
      ++v7;
      --v6;
    }
    while ( v6 );
    v9 = 4i64;
    v10 = 0i64;
    do
    {
      v10 = *(_QWORD *)(v7 + 0x2000) ^ (v10 &amp;lt;&amp;lt; 8);
      ++v7;
      --v9;
    }
    while ( v9 );
    v11 = 32i64;
    do
    {
      v9 += 1126266966i64;
      v12 = 4i64;
      v13 = 0i64;
      do
      {
        v14 = v12 + 23;
        v13 = *(_QWORD *)(v14 + 0x2000) ^ (v13 &amp;lt;&amp;lt; 8);
        v12 = v14 - 24;
      }
      while ( v12 );
      v15 = 4i64;
      v16 = 0i64;
      do
      {
        v17 = v15 + 27;
        v16 = *(_QWORD *)(v17 + 0x2000) ^ (v16 &amp;lt;&amp;lt; 8);
        v15 = v17 - 28;
      }
      while ( v15 );
      v8 += (v16 + (v10 &amp;gt;&amp;gt; 5)) ^ (v10 + v9) ^ (v13 + 16 * v10);
      v18 = 4i64;
      v19 = 0i64;
      do
      {
        v20 = v18 + 31;
        v19 = *(_QWORD *)(v20 + 0x2000) ^ (v19 &amp;lt;&amp;lt; 8);
        v18 = v20 - 32;
      }
      while ( v18 );
      v21 = 4i64;
      v22 = 0i64;
      do
      {
        v23 = v21 + 35;
        v22 = *(_QWORD *)(v23 + 0x2000) ^ (v22 &amp;lt;&amp;lt; 8);
        v21 = v23 - 36;
      }
      while ( v21 );
      v10 += (v22 + (v8 &amp;gt;&amp;gt; 5)) ^ (v8 + v9) ^ (v19 + 16 * v8);
      --v11;
    }
    while ( v11 );
    v24 = 8i64 * MEMORY[0x2030] + 64;
    v25 = 8i64 * MEMORY[0x2030] + 68;
    v26 = 4i64;
    do
    {
      --v26;
      *(_QWORD *)(v24 + 0x2000) = v8;
      *(_QWORD *)(v25 + 0x2000) = v10;
      ++v24;
      ++v25;
      v8 &amp;gt;&amp;gt;= 8;
      v10 &amp;gt;&amp;gt;= 8;
    }
    while ( v26 );
    ++MEMORY[0x2030];
  }
  while ( MEMORY[0x2030] != 3i64 );
  if ( MEMORY[0x2058] != MEMORY[0x2040] )
    m_putchar(a1, a2, 88i64, 24i64);
  else
    m_putchar(a1, a2, 89i64, 23i64);
  m_putchar(v28, v27, v29, v30);
  m_putchar(v32, v31, v33, v34);
  return m_putchar(v36, v35, v37, v38);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;就是tea加密，套脚本解密即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from ctypes import *


def encrypt(v, k):
    v0 = c_uint32(v[0])
    v1 = c_uint32(v[1])
    sum1 = c_uint32(0)
    delta = 0x43217856
    for i in range(32):
        sum1.value += delta
        v0.value += ((v1.value &amp;lt;&amp;lt; 4) + k[0]) ^ (v1.value + sum1.value) ^ ((v1.value &amp;gt;&amp;gt; 5) + k[1])
        v1.value += ((v0.value &amp;lt;&amp;lt; 4) + k[2]) ^ (v0.value + sum1.value) ^ ((v0.value &amp;gt;&amp;gt; 5) + k[3])
    return v0.value, v1.value


def decrypt(v, k):
    v0 = c_uint32(v[0])
    v1 = c_uint32(v[1])
    delta = 0x43217856
    sum1 = c_uint32(delta*32)
    for i in range(32):
        v1.value -= ((v0.value &amp;lt;&amp;lt; 4) + k[2]) ^ (v0.value + sum1.value) ^ ((v0.value &amp;gt;&amp;gt; 5) + k[3])
        v0.value -= ((v1.value &amp;lt;&amp;lt; 4) + k[0]) ^ (v1.value + sum1.value) ^ ((v1.value &amp;gt;&amp;gt; 5) + k[1])
        sum1.value -= delta
    return long_to_bytes(v0.value)+long_to_bytes(v1.value)


if __name__ == &#39;__main__&#39;:
    a=[0x0FB6B1B8, 0x3A84F414]
    a1=[0x90CE01CB,0xB4859002]
    a2=[0xEA807F7C,0x2D7458B7]
    k=[17,34,0x88,0xFF]
    res= decrypt(a, k)+decrypt(a1,k)+decrypt(a2,k)
    print(&amp;quot;解密后数据:&amp;quot;, res)


&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;得到flag：&lt;em&gt;&lt;strong&gt;flag{FSM_A_M4j0r_In_CO!}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">鹏城杯2023 Reverse Writeup</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/shen-ru-jie-xi-jie-gou-hua-yi-chang-chu-li-seh/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本文仅对原文的翻译进行记录，用于个人学习。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;原文链接：&lt;a href=&#34;https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh.htm&#34;&gt;A Crash Course on theDepths of Win32 Structured Exception Handling, MSJ January 1997 (bytepointer.com)&lt;/a&gt;&lt;br&gt;
​		在Win32操作系统提供的所有功能中，使用最广泛而又没有公开的恐怕要数结构化异常处理（Structured Exception Handling，SEH） 了。当你考虑Win32结构化异常处理时，也许会想到__try、__finally和__except等术语。可能你在任何一本讲解Win32的好书上都能找到关于SEH较为详细的描述，甚至Win32 SDK文档也对使用__try、__finally和__except进行结构化异常处理进行了相当完整的描述。&lt;br&gt;
　　既然已经有了这些文档，那为什么我还说SEH并未公开呢？本质上来说，Win32结构化异常处理是操作系统提供的服务。你可能找到的所有关于SEH方面的文档都只是描述了某个特别的编译器的运行时库对操作系统实现的封装。关键字__try、__finally或者__except并没有什么神奇的。Microsoft的操作系统和编译器开发小组定义了这些关键字和它们的作用。其它C++编译器厂商完全按照它们的语义来就可以了。当编译器的SEH支持层把原始的操作系统SEH的复杂性封装起来的时候，它同时也把原始的操作系统SEH的细节隐藏了起来。&lt;br&gt;
　　我曾经接到大量来自想自己实现编译器层面SEH的人发来的电子邮件，他们苦于找不到关于操作系统SEH实现方面的任何文档。按说，我应该能够告诉他们 Visual C++或Borland C++的运行时库源代码就是他们想要的。但是不知出于什么原因，编译器层面的SEH看起来好像是个大秘密。无论是Microsoft还是Borland都没有提供他们的SEH支持层最底层的源代码。（现在Microsoft仍然没有提供这些源代码，它提供的是编译过的目标文件，而Borland则提供了相应的源代码。）&lt;br&gt;
　　在本文中，我会剥掉结构化异常处理外面的包装直至其最基本的概念。在此过程中，我会把操作系统提供的支持与编译器通过代码生成和运行时库提供的支持分开来说。当我挖掘到关键的操作系统例程时，我使用的是运行于Intel处理器上的Windows NT 4.0。但是我这里讲的大部分内容同样也适用于其它处理器。我会避免涉及到真实的C++异常处理，它使用的是catch()而不是__except。从内部来讲，真实的C++异常处理的实现与我这里要讲的非常相似。但是真实的C++异常处理有一些其它的复杂问题，它会混淆我这里要讲的一些概念。&lt;br&gt;
　　在挖掘组成Win32 SEH的晦涩的.H和.INC文件的过程中，我发现最好的信息来源之一是IBM OS/2头文件（特别是BSEXCPT.H）。如果你涉足这方面已经有一段时间了，就不会感到太奇怪。这里描述的SEH机制是早在Microsoft还工作在OS/2上时就已经定义好的。由于这个原因，你会发现Win32下的SEH和OS/2下的SEH极其相似。（现在我们可能已经没有机会体验这一点 了，OS/2已经永远成为历史了。）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1浅析seh&#34;&gt;1.浅析SEH&lt;/h3&gt;
&lt;p&gt;如果我把SEH的所有细节一股脑儿全倒给你，你可能无法接受。因此我先从一小部分开始，然后层层深入。如果你以前从未接触过结构化异常处理，那正好，因为你头脑中没有一些自己设想的概念。如果你以前接触过SEH，最好把头脑中有关__try、GetExceptionCode和 EXCEPTION_EXECUTE_HANDLER之类的词统统忘掉，假设它对你来说是全新的。深呼吸。准备好了吗？让我们开始吧！&lt;br&gt;
　　设想我告诉过你，当一个线程出现错误时，操作系统给你一个机会被告知这个错误。说得更明白一些就是，&lt;strong&gt;当一个线程出现错误时，操作系统调用用户定义的一个回调函数&lt;/strong&gt;。这个回调函数可以做它想做的一切。例如它可以修复错误，或者它也可以播放一段音乐。无论回调函数做什么，它最后都要返回一个值来告诉系统下一步做什么。（这不是十分准确，但就此刻来说非常接近。）&lt;br&gt;
　　当你的某一部分代码出错时，系统再回调你的其它代码，那么这个回调函数看起来是什么样子呢？换句话说，你想知道关于异常什么类型的信息呢？实际上这并不重要，因为Win32已经替你做了决定。异常的回调函数的样子如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;EXCEPTION_DISPOSITION
__cdecl _except_handler( 
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		这个原型来自标准的Win32头文件EXCPT.H，乍看起来有些费解。但如果你仔细看，它并不是很难理解。首先，忽略掉返回值的类型（EXCEPTION_DISPOSITION）。你得到的基本信息就是它是一个叫作**_except_handler&lt;strong&gt;并且带有四个参数的函数。&lt;br&gt;
　　这个函数的第一个参数是一个指向&lt;/strong&gt;EXCEPTION_RECORD**结构的指针。这个结构在WINNT.H中定义，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		这个结构中的 ExcepitonCode成员是赋予异常的代码。通过在WINNT.H中搜索以“STATUS_”开头的＃define定义，你可以得到一个异常代码列表。例如所有人都非常熟悉的STATUS_ACCESS_VIOLATION的代码是0xC0000005。一个更全面的异常代码列表可以在 Windows NT DDK的NTSTATUS.H中找到。此结构的第四个成员是异常发生的地址。其它成员暂时可以忽略。&lt;br&gt;
　　_except_handler函数的第二个参数是一个指向establisher帧结构的指针。它是SEH中一个至关重要的参数，但是现在你可以忽略它。&lt;br&gt;
　　 _except_handler回调函数的第三个参数是一个指向&lt;strong&gt;CONTEXT&lt;/strong&gt;结构的指针。此结构在WINNT.H中定义，它代表某个特定线程的寄存器值。图1显示了CONTEXT结构的成员。当用于SEH时，CONTEXT结构表示异常发生时寄存器的值。顺便说一下，这个CONTEXT结构就是GetThreadContext和SetThreadContext这两个API中使用 的那个CONTEXT结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图1 CONTEXT结构&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct _CONTEXT
{
    DWORD ContextFlags;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;
    FLOATING_SAVE_AREA FloatSave;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;
    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs;
    DWORD EFlags;
    DWORD Esp;
    DWORD SegSs;
} CONTEXT;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		_except_handler回调函数的第四个参数被称为DispatcherContext。它暂时也可以被忽略。&lt;br&gt;
　　到现在为止，你头脑中已经有了一个当异常发生时会被操作系统调用的回调函数的模型了。这个回调函数带四个参数，其中三个指向其它结构。在这些结构中，一些域比较重要，其它的就不那么重要。这里的关键是**_exept_handler回调函数接收到操作系统传递过来的许多有价值的信息**，例如异常的类型和发生的地址。使用这些信息，异常回调函数就能决定下一步做什么。&lt;br&gt;
　　对我来说，现在就写一个能够显示_except_handler作用的样例程序是再诱人不过的了。但是我们还缺少一些关键信息。特别是，当错误发生时操作系统是怎么知道到哪里去调用这个回调函数的呢？答案是还有一个称为EXCEPTION_REGISTRATION的结构。通篇你都会看到这个结构，所以不要跳过这一部分。我唯一能找到的&lt;strong&gt;EXCEPTION_REGISTRATION&lt;/strong&gt;结构的正式定义是在Visual C++运行时库源代码中的EXSUP.INC文件中：&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;_EXCEPTION_REGISTRATION struc
    prev        dd       ?
    handler     dd       ?
_EXCEPTION_REGISTRATION ends
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这个结构在WINNT.H的NT_TIB结构的定义中被称为_EXCEPITON_REGISTARTION_RECORD。唉，没有一个地方能够找到 &lt;em&gt;EXCEPTION_REGISTRATION_RECORD的定义，所以我不得不使用EXSUP.INC中这个汇编语言的结构定义。这是我前面所说 SEH未公开的一个证据。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​	无论正在干什么，现在让我们回到手头的问题上来。当异常发生时，操作系统是如何知道到哪里去调用回调函数的呢？实际 上，EXCEPTION_REGISTARTION结构由两个域组成，第一个你现在可以忽略。第二个域handler，包含一个指向 _except_handler回调函数的指针。这让你离答案更近一点，但现在的问题是，操作系统到哪里去找 EXCEPTION_REGISTATRION结构呢？&lt;br&gt;
　　要回答这个问题，记住&lt;strong&gt;结构化异常处理是基于线程的&lt;/strong&gt;这一点是非常有用的。也就是说，每个线程有它自己的异常处理回调函数。在1996年五月的Under The Hood专栏中，我介绍了一个关键的Win32数据结构——&lt;strong&gt;线程信息块（Thread Information/Environment Block，TIB或TEB）&lt;/strong&gt;。这个结构的某些域在Windows NT、Windows 95、Win32s和OS/2上是相同的。&lt;strong&gt;TIB的第一个DWORD是一个指向线程的EXCEPTION_REGISTARTION结构的指针。在基于Intel处理器的Win32平台上，FS寄存器总是指向当前的TIB。因此在FS:[0]处你可以找到一个指向EXCEPTION_REGISTARTION结构的指针&lt;/strong&gt;。&lt;br&gt;
　　到现在为止，我们已经有了足够的认识。当异常发生时，系统查找出错线程的TIB，获取一个指向EXCEPTION_REGISTRATION结构的指针。在这个结构中有一个指向_except_handler回调函数的指针。现在操作系统已经知道了足够的信息去调用_except_handler函数，如图 2所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh_files/pietrek2.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		把这些小块知识拼凑起来，我写了一个小程序来演示上面这个对操作系统层面的结构化异常处理的简化描述，如图3的MYSEH.CPP所示。它只有两个函数。main函数使用了三个内联汇编块。第一个内联汇编块通过两个PUSH指令（“&lt;code&gt;PUSH handler&lt;/code&gt;”和“&lt;code&gt;PUSH FS:[0]&lt;/code&gt;”）在堆栈上创建了一个EXCEPTION_REGISTRATION结构。&lt;code&gt;PUSH FS:[0]&lt;/code&gt;这条指令保存了先前的&lt;code&gt;FS:[0]&lt;/code&gt;中的值作为这个结构的一部分，但这在此刻并不重要。重要的是现在堆栈上有一个8字节的 EXCEPTION_REGISTRATION结构。紧接着的下一条指令（&lt;code&gt;MOV FS:[0],ESP&lt;/code&gt;）使线程信息块中的第一个DWORD指向了新的EXCEPTION_REGISTRATION结构。（注意堆栈操作）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图3 MYSEH.CPP&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;//==================================================
// MYSEH - Matt Pietrek 1997
// Microsoft Systems Journal, January 1997
// FILE: MYSEH.CPP
// 用命令行CL MYSEH.CPP编译
//==================================================
#define WIN32_LEAN_AND_MEAN
#include &amp;lt;windows.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
DWORD scratch;
EXCEPTION_DISPOSITION
__cdecl
_except_handler( 
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext )
{
    unsigned i;
    // 指明是我们让流程转到我们的异常处理程序的
    printf( &amp;quot;Hello from an exception handler\n&amp;quot; );
    // 改变CONTEXT结构中EAX的值，以便它指向可以成功进写操作的位置
    ContextRecord-&amp;gt;Eax = (DWORD)&amp;amp;scratch;
    // 告诉操作系统重新执行出错的指令
    return ExceptionContinueExecution;
}

int main()
{
    DWORD handler = (DWORD)_except_handler;
    __asm
    { 
        // 创建EXCEPTION_REGISTRATION结构：
        push handler // handler函数的地址
        push FS:[0] // 前一个handler函数的地址
        mov FS:[0],ESP // 安装新的EXECEPTION_REGISTRATION结构
    }
    __asm
    {
        mov eax,0     // 将EAX清零
        mov [eax], 1 // 写EAX指向的内存从而故意引发一个错误
    }
    printf( &amp;quot;After writing!\n&amp;quot; );
    __asm
    { 
        // 移去我们的EXECEPTION_REGISTRATION结构
        mov eax,[ESP]    // 获取前一个结构
        mov FS:[0], EAX // 安装前一个结构
        add esp, 8       // 将我们的EXECEPTION_REGISTRATION弹出堆栈
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你想知道我为什么把EXCEPTION_REGISTRATION结构创建在堆栈上而不是使用全局变量，我有一个很好的理由可以解释它。实际上，当你使用编译器的__try/__except语法结构时，编译器自己也把EXCEPTION_REGISTRATION结构创建在堆栈上。我只是简单地向你展示了如果使用__try/__except时编译器做法的简化版。&lt;br&gt;
　　回到main函数，第二个__asm块通过先把EAX寄存器清零（&lt;code&gt;MOV EAX,0&lt;/code&gt;）然后把此寄存器的值作为内存地址让下一条指令（&lt;code&gt;MOV [EAX],1&lt;/code&gt;）向此地址写入数据而故意引发一个错误。最后的__asm块移除这个简单的异常处理程序：它首先恢复了&lt;code&gt;FS:[0]&lt;/code&gt;中先前的内容，然后把 EXCEPTION_REGISTRATION结构弹出堆栈（&lt;code&gt;ADD ESP,8&lt;/code&gt;）。&lt;br&gt;
　　现在假若你运行MYSEH.EXE，就会看到整个过程。当MOV [EAX],1这条指令执行时，它引发一个访问违规。系统在FS:[0]处的TIB中查找，然后发现了一个指向 EXCEPTION_REGISTRATION结构的指针。在MYSEH.CPP中，在这个结构中有一个指向_except_handler函数的指针。 系统然后把所需的四个参数（我在前面已经说过）压入堆栈，接着调用_except_handler函数。&lt;br&gt;
　　一旦进入_except_handler，这段代码首先通过一个printf语句表明“哈!是我让它转到这里的！”。接着，_except_handler 修复了引发错误的问题——即EAX寄存器指向了一个不能写的内存地址（地址0）。修复方法就是改变CONTEXT结构中的EAX的值使它指向一个允许写的 位置。在这个简单的程序中，我专门为此设置了一个DWORD变量（scratch）。_except_handler函数最后的动作是返回 ExceptionContinueExecution这个值，它在EXCPT.H文件中定义。&lt;br&gt;
　　当操作系统看到返回值为ExceptionContinueExecution时，它将其理解为你已经修复了问题，而引起错误的那条指令应该被重新执行。由于我的_except_handler函数已经让EAX寄存器指向一个合法的内存，&lt;code&gt;MOV [EAX],1&lt;/code&gt;指令再次执行，这次main函数一切正常。看，这也并不复杂，不是吗？&lt;/p&gt;
&lt;h3 id=&#34;2移向更深处&#34;&gt;2.移向更深处&lt;/h3&gt;
&lt;p&gt;有了这个最简单的情景之后，让我们回去填补那些空白。虽然这个异常回调机制很好，但它并不是一个完美的解决方案。对于稍微复杂一些的应用程序来说，仅用一个函数就能处理程序中任何地方都可能发生的异常是相当困难的。一个更实用的方案应该是有多个异常处理例程，每个例程针对程序中的一部分。实际上，操作系统提供的正是这个功能。&lt;br&gt;
　　还记得系统用来查找异常回调函数的EXCEPTION_REGISTRATION结构吗？这个结构的第一个成员，称为prev，前面我们暂时把它忽略了。它实际上是一个指向另外一个EXCEPTION_REGISTRATION结构的指针。这第二个EXCEPTION_REGISTRATION结构可以有一个完全不同的处理函数。它的prev域可以指向第三个EXCEPTION_REGISTRATION结构，依次类推。&lt;strong&gt;简单地说，就是有一个EXCEPTION_REGISTRATION结构链表。线程信息块的第一个DWORD（在基于Intel CPU的机器上是FS:[0]）指向这个链表的头部&lt;/strong&gt;。&lt;br&gt;
　　操作系统要这个EXCEPTION_REGISTRATION结构链表做什么呢？原来，当异常发生时，系统遍历这个链表以查找一个（其异常处理程序）同意处理这个异常的EXCEPTION_REGISTRATION结构。在 MYSEH.CPP中，异常处理程序通过返回ExceptionContinueExecution表示它同意处理这个异常。异常回调函数也可以拒绝处理 这个异常。在这种情况下，系统移向链表的下一个EXCEPTION_REGISTRATION结构并询问它的异常回调函数，看它是否同意处理这个异常。图 4显示了这个过程。一旦系统找到一个处理这个异常的回调函数，它就停止遍历链表。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh_files/pietrek4.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;图4 查找一个处理异常的EXCEPTION_REGISTRATION结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		图5的MYSEH2.CPP就是一个异常处理函数不处理某个异常的例子。为了使代码尽量简单，我使用了编译器层面的异常处理。main函数只设置了一个 __try/__except块。在__try块内部调用了HomeGrownFrame函数。这个函数与前面的MYSEH程序非常相似。它也是在堆栈上创建一个EXCEPTION_REGISTRATION结构，并且让FS:[0]指向此结构。在建立了新的异常处理程序之后，这个函数通过向一个NULL 指针所指向的内存处写入数据而故意引发一个错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*(PDWORD)0 = 0;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		这个异常处理回调函数，同样被称为_except_handler，却与前面的那个截然不同。它首先打印出ExceptionRecord结构中的异常代码和标志，这个结构的地址是作为一个指针参数被这个函数接收的。打印出异常标志的原因一会儿就清楚了。因为_except_handler函数并没有打算修复出错的代码，因此它返回ExceptionContinueSearch。这导致操作系统继续在EXCEPTION_REGISTRATION结构链表中搜索下一个 EXCEPTION_REGISTRATION结构。接下来安装的异常回调函数是针对main函数中的__try/__except块的。__except块简单地打印出“Caught the exception in main()”。此时我们只是简单地忽略这个异常来表明我们已经处理了它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图5 MYSEH2.CPP&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//=================================================
// MYSEH2 - Matt Pietrek 1997
// Microsoft Systems Journal, January 1997
// FILE: MYSEH2.CPP
// 使用命令行CL MYSEH2.CPP编译
//=================================================
#define WIN32_LEAN_AND_MEAN
#include &amp;lt;windows.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
EXCEPTION_DISPOSITION
__cdecl _except_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext )
{
    printf( &amp;quot;Home Grown handler: Exception Code: %08X Exception Flags %X&amp;quot;,
    ExceptionRecord-&amp;gt;ExceptionCode, ExceptionRecord-&amp;gt;ExceptionFlags );
    if ( ExceptionRecord-&amp;gt;ExceptionFlags &amp;amp; 1 )
        printf( &amp;quot; EH_NONCONTINUABLE&amp;quot; );
    if ( ExceptionRecord-&amp;gt;ExceptionFlags &amp;amp; 2 )
        printf( &amp;quot; EH_UNWINDING&amp;quot; );
    if ( ExceptionRecord-&amp;gt;ExceptionFlags &amp;amp; 4 )
        printf( &amp;quot; EH_EXIT_UNWIND&amp;quot; );
    if ( ExceptionRecord-&amp;gt;ExceptionFlags &amp;amp; 8 )      // 注意这个标志
        printf( &amp;quot; EH_STACK_INVALID&amp;quot; );
    if ( ExceptionRecord-&amp;gt;ExceptionFlags &amp;amp; 0x10 )   // 注意这个标志
        printf( &amp;quot; EH_NESTED_CALL&amp;quot; );
    printf( &amp;quot;\n&amp;quot; );
    // 我们不想处理这个异常，让其它函数处理吧
    return ExceptionContinueSearch;
}

void HomeGrownFrame( void )
{
    DWORD handler = (DWORD)_except_handler;
    __asm
    {
        // 创建EXCEPTION_REGISTRATION结构：
        push handler        // handler函数的地址
        push FS:[0]         // 前一个handler函数的地址
        mov FS:[0],ESP      // 安装新的EXECEPTION_REGISTRATION结构
    }
    *(PDWORD)0 = 0;         // 写入地址0，从而引发一个错误
    printf( &amp;quot;I should never get here!\n&amp;quot; );
    __asm
    {
        // 移去我们的EXECEPTION_REGISTRATION结构
        mov eax,[ESP]       // 获取前一个结构
        mov FS:[0], EAX     // 安装前一个结构
        add esp, 8          // 把我们EXECEPTION_REGISTRATION结构弹出堆栈
    }
}

int main()
{
    __try
    {
        HomeGrownFrame();
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        printf( &amp;quot;Caught the exception in main()\n&amp;quot; );
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		这里的关键是执行流程。&lt;strong&gt;当一个异常处理程序拒绝处理某个异常时，它实际上也就拒绝决定流程最终将从何处恢复&lt;/strong&gt;。只有处理某个异常的异常处理程序才能决定待所有异常处理代码执行完毕之后流程将从何处恢复。这个规则的意义非常重大，虽然现在还不明显。&lt;br&gt;
　　当使用结构化异常处理时，如果一个函数有一个异常处理程序但它却不处理某个异常，这个函数就有可能非正常退出。例如在MYSEH2中 HomeGrownFrame函数就不处理异常。由于在链表中后面的某个异常处理程序（这里是main函数中的）处理了这个异常，因此出错指令后面的 printf就永远不会执行。从某种程度上说，使用结构化异常处理与使用setjmp和longjmp运行时库函数有些类似。&lt;br&gt;
　　如果你运行MYSEH2，会发现其输出有些奇怪。看起来好像调用了两次_except_handler函数。根据你现有的知识，第一次调用当然可以完全理解。但是为什么会有第二次呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Home Grown handler: Exception Code: C0000005 Exception Flags 0
Home Grown handler: Exception Code: C0000027 Exception Flags 2 EH_UNWINDING
Caught the Exception in main()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	比较一下以“Home Grown Handler”开头的两行，就会看出它们之间有明显的区别。第一次异常标志是0，而第二次是2。这把我们带入到了展开（Unwinding）的世界中。实际上，当一个异常处理回调函数拒绝处理某个异常时，它会被再一次调用。但是这次回调并不是立即发生的。这有点复杂。我需要把异常发生时的情形好好梳理一下。&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;当异常发生时，系统遍历EXCEPTION_REGISTRATION结构链表，直到它找到一个处理这个异常的处理程序。一旦找到，系统就再次遍历这个链表，直到处理这个异常的结点为止。在这第二次遍历中，系统将再次调用每个异常处理函数。关键的区别是，在第二次调用中，异常标志被设置为2。这个值被定义为EH_UNWINDING。&lt;/strong&gt;（EH_UNWINDING的定义在Visual C++ 运行时库源代码文件EXCEPT.INC中，但Win32 SDK中并没有与之等价的定义。）&lt;br&gt;
EH_UNWINDING表示什么意思呢？原来，当一个异常处理回调函数被第二次调用时（带EH_UNWINDING标志），操作系统给这个函数一个最后清理的机会。什么样的清理呢？一个绝好的例子是C++类的析构函数。当一个函数的异常处理程序拒绝处理某个异常时，通常执行流程并不会正常地从那个函数退出。现在，想像一个定义了 一个C++类的实例作为局部变量的函数。C++规范规定析构函数必须被调用。这带EH_UNWINDING标志的第二次回调就给这个函数一个机会去做一些类似于调用析构函数和__finally块之类的清理工作。&lt;/p&gt;
&lt;p&gt;​    在异常已经被处理完毕，并且所有前面的异常帧都已经被展开之后，流程从处理异常的那个回调函数决定的地方开始继续执行。一定要记住，仅仅把指令指针设置到所需的代码处就开始执行是不行的。流程恢复执行处的代码的堆栈指针和栈帧指针（在Intel CPU上是ESP和EBP）也必须被恢复成它们在处理这个异常的函数的栈帧上的值。因此，这个处理异常的回调函数必须负责把堆栈指针和栈帧指针恢复成它们在包含处理这个异常的SEH代码的函数的堆栈上的值。&lt;/p&gt;
&lt;p&gt;​    通常，展开操作导致堆栈上处理异常的帧以下的堆栈区域上的所有内容都被移除了，就好像我们从来没有调用过这些函数一样。展开的另外一个效果就是 EXCEPTION_REGISTRATION结构链表上处理异常的那个结构之前的所有EXCEPTION_REGISTRATION结构都被移除了。这很好理解，因为这些EXCEPTION_REGISTRATION结构通常都被创建在堆栈上。在异常被处理后，堆栈指针和栈帧指针在内存中比那些从 EXCEPTION_REGISTRATION结构链表上移除的EXCEPTION_REGISTRATION结构高。图6显示了我说的情况。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh_files/pietrek6.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​																	&lt;strong&gt;图6 从异常展开&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	迄今为止，我实际上一直在假设操作系统总是能在EXCEPTION_REGISTRATION结构链表中找到一个异常处理程序。如果找不到怎么办呢？实际上，这几乎不可能发生。因为操作系统暗中已经为每个线程都提供了一个默认的异常处理程序。这个默认的异常处理程序总是链表的最后一个结点，并且它总是选择处理异常。它进行的操作与其它正常的异常处理回调函数有些不同，下面我会说明。&lt;/p&gt;
&lt;p&gt;​    让我们来看一下系统是在什么时候插入了这个默认的、最后一个异常处理程序。很明显它需要在线程执行的早期，在任何用户代码开始执行之前。图7是我为&lt;strong&gt;BaseProcessStart&lt;/strong&gt;函数写的伪代码，它是Windows NT KERNEL32.DLL的一个内部例程。这个函数带一个参数——线程入口点函数的地址。BaseProcessStart运行在新进程的环境中，并且它调用这个进程的第一个线程的入口点函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;BaseProcessStart( PVOID lpfnEntryPoint )
{
    DWORD retValue;
    DWORD currentESP;
    DWORD exceptionCode;
    currentESP = ESP;
    __try
    {
        NtSetInformationThread( GetCurrentThread(),
            ThreadQuerySetWin32StartAddress,
            &amp;amp;lpfnEntryPoint,
            sizeof(lpfnEntryPoint) );
            retValue = lpfnEntryPoint();
        ExitThread( retValue );
    }
    __except(   //过滤器表达式代码
        exceptionCode = GetExceptionInformation(),
        UnhandledExceptionFilter( GetExceptionInformation() ) )
    {
        ESP = currentESP;
        if ( !_BaseRunningInServerProcess ) // 普通进程
            ExitProcess( exceptionCode );
        else // 服务
            ExitThread( exceptionCode );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​														&lt;strong&gt;图7 BaseProcessStart伪代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	在上面的伪代码中，注意对lpfnEntryPoint的调用被一个__try和__except块封装着。就是这个__try块安装了默认的、异常处理程 序链表上的最后一个异常处理程序。所有后来注册的异常处理程序都被安装在链表中这个结点的前面。如果lpfnEntryPoint函数返回，那么表明线程 一直运行到完成并且没有引发异常。这时BaseProcessStart调用ExitThread使线程退出。&lt;/p&gt;
&lt;p&gt;​    如果线程引发了一个异常但是没有异常处理程序来处理它时怎么办呢？这时，执行流程转到__except关键字后面的括号中。在BaseProcessStart中，这段代码调用&lt;strong&gt;UnhandledExceptionFilter&lt;/strong&gt;这个API，后面我会讲到它。现在对于我们来说，重要的是UnhandledExceptionFilter这个API包含了默认的异常处理程序。&lt;/p&gt;
&lt;p&gt;​    如果UnhandledExceptionFilter返回EXCEPTION_EXECUTE_HANDLER，这时BaseProcessStart中的__except块开始执行。而__except块所做的只是调用ExitProcess函数去终止当前进程。稍微想一下你就会理解了。常识告诉我们， 如果一个进程引发了一个错误而没有异常处理程序去处理它，这个进程就会被系统终止。你在伪代码中看到的正是这些。&lt;/p&gt;
&lt;p&gt;​    对于上面所说的我还有一点要补充。如果引发错误的线程是作为服务来运行的，并且是基于线程的服务，那么__except块并不调用ExitProcess，相反，它调用ExitThread。不能仅仅因为一个服务出错就终止整个服务进程。&lt;/p&gt;
&lt;p&gt;​    UnhandledExceptionFilter中的默认异常处理程序都做了什么呢？当我在一个技术讲座上问起这个问题时，响应者寥寥无几。几乎没有人知道当未处理异常发生时，到底操作系统的默认行为是什么。简单地演示一下这个默认的行为也许会让很多人豁然开朗。我运行一个故意引发错误的程序，其结果如下（见图8）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh_files/pietrek8.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​														&lt;strong&gt;图8 未处理异常对话框&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表面上看，UnhandledExceptionFilter显示了一个对话框告诉你发生了一个错误。这时，你被给予了一个机会或者终止出错进程，或者调试它。但是幕后发生了许多事情，我会在文章最后详细讲述它。&lt;/p&gt;
&lt;p&gt;​    正如我让你看到的那样，当异常发生时，用户写的代码可以（并且通常是这样）获得机会执行。同样，在展开操作期间，用户写的代码也可以执行。这个用户写的代码可能也有错误，并且可能引发另一个异常。由于这个原因，异常处理回调函数也可以返回另外两个值：&lt;strong&gt;ExceptionNestedException&lt;/strong&gt;和****ExceptionCollidedUnwind****。很明显，它们很重要。但这是非常复杂的问题，我并不打算在这里涉及它们。要想理解其中的一些基本问题太困难了。&lt;/p&gt;
&lt;h3 id=&#34;3-编译器层面的seh&#34;&gt;3、编译器层面的SEH&lt;/h3&gt;
&lt;p&gt;​    虽然我在前面偶尔也使用了__try和__except，但迄今为止几乎我写的所有内容都是关于操作系统方面对SEH的实现。然而看一下我那两个使用操作系统的原始SEH的小程序别扭的样子，编译器对这个功能进行封装实在是非常有必要的。现在让我们来看一下Visual C++是如何在操作系统对SEH功能实现的基础上来创建它自己的结构化异常处理支持的。&lt;/p&gt;
&lt;p&gt;​    在我们继续下去之前，记住其它编译器可以使用原始的系统SEH来做一些完全不同的事情这一点是非常重要的。并没有什么规定编译器必须实现Win32 SDK文档中描述的__try/__except模型。例如Visual Basic 5.0在它的运行时代码中使用了结构化异常处理，但是那里的数据结构和算法与我这里要讲的完全不同。&lt;/p&gt;
&lt;p&gt;​    如果你把Win32 SDK文档中关于结构化异常处理方面的内容从头到尾读一遍，一定会遇到下面&lt;strong&gt;所谓的“基于帧”的异常处理程序模型&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__try {
    // 这里是被保护的代码
}
__except (过滤器表达式) { 
   // 这里是异常处理程序代码
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	简单地说，在一个函数中，一个__try块中的所有代码就通过创建在这个函数的堆栈帧上的一个EXCEPTION_REGISTRATION结构来保护。在函数的入口处，这个新的EXCEPTION_REGISTRATION结构被放在异常处理程序链表的头部。在__try块结束后，相应的 EXCEPTION_REGISTRATION结构从这个链表的头部被移除。正如我前面所说，异常处理程序链表的头部被保存在FS:[0]处。因此，如果你在调试器中单步跟踪时看到类似下面的指令时&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MOV DWORD PTR FS:[00000000],ESP
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MOV DWORD PTR FS:[00000000],ECX
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就能非常确定这段代码正在进入或退出一个__try/__except块。&lt;/p&gt;
&lt;p&gt;​    既然一个__try块相当于堆栈上的一个EXCEPTION_REGISTRATION结构，那么EXCEPTION_REGISTRATION结构中的回调函数相当于什么呢？使用Win32的术语来说，异常处理回调函数相当于**过滤器表达式（filter-expression）**代码。实际上，过滤器表达式就是__except关键字后面的小括号中的代码。就是这个过滤器表达式代码决定了后面的大括号中的代码是否执行。&lt;/p&gt;
&lt;p&gt;​    由于过滤器表达式代码是你自己写的，你当然可以决定在你的代码中的某个地方是否处理某个特定的异常。它可以简单的只是一句“EXCEPTION_EXECUTE_HANDLER”，也可以先调用一个把p计算到20,000,000位的函数，然后再返回一个值来告诉操作系统下一步做什么。随你的便。关键是你的过滤器表达式代码必须是我前面讲的有效的异常处理回调函数。&lt;/p&gt;
&lt;p&gt;​    我刚才讲的虽然相当简单，但那只不过是隔着有色玻璃看世界罢了。实际它是非常复杂的。首先，你的过滤器表达式代码并不是被操作系统直接调用的。事实上，各个EXCEPTION_REGISTRATION结构的handler域都指向了同一个函数。这个函数在Visual C++的运行时库中，它被称为__except_handler3。正是这个__except_handler3调用了你的过滤器表达式代码，我一会儿再接着说它。&lt;/p&gt;
&lt;p&gt;​    对我前面的简单描述需要修正的另一个地方是，并不是每次进入或退出一个__try块时就创建或撤销一个EXCEPTION_REGISTRATION结构。 相反，在使用SEH的任何函数中只创建一个EXCEPTION_REGISTRATION结构。换句话说，你可以在一个函数中使用多个__try/__except块，但是在堆栈上只创建一个EXCEPTION_REGISTRATION结构。同样，你可以在一个函数中嵌套使用__try块，但Visual C++仍旧只是创建一个EXCEPTION_REGISTRATION结构。&lt;/p&gt;
&lt;p&gt;​    如果整个EXE或DLL只需要单个的异常处理程序（__except_handler3），同时，如果单个的EXCEPTION_REGISTRATION 结构就能处理多个__try块的话，很明显，这里面还有很多东西我们不知道。这个技巧是通过一个通常情况下看不到的表中的数据来完成的。由于本文的目的就是要深入探索结构化异常处理，那就让我们来看一看这些数据结构吧。&lt;/p&gt;
&lt;h3 id=&#34;4-扩展的异常处理帧&#34;&gt;4、扩展的异常处理帧&lt;/h3&gt;
&lt;p&gt;​    Visual C++的 SEH实现并没有使用原始的EXCEPTION_REGISTRATION结构。它在这个结构的末尾添加了一些附加数据。这些附加数据正是允许单个函数 （__except_handler3）处理所有异常并将执行流程传递到相应的过滤器表达式和__except块的关键。我在Visual C++运行时库源代码中的EXSUP.INC文件中找到了有关Visual C++扩展的EXCEPTION_REGISTRATION结构格式的线索。在这个文件中，你会看到以下定义（已经被注释掉了）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;;struct _EXCEPTION_REGISTRATION{
;   struct _EXCEPTION_REGISTRATION *prev;
;   void (*handler)(    PEXCEPTION_RECORD,
;                   PEXCEPTION_REGISTRATION,
;                   PCONTEXT,
;                  PEXCEPTION_RECORD);
; struct scopetable_entry *scopetable;
; int trylevel;
; int _ebp;
; PEXCEPTION_POINTERS xpointers;
;};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	在前面你已经见过前两个域：prev和handler。它们组成了基本的EXCEPTION_REGISTRATION结构。后面三个域：scopetable（作用域表）、trylevel和_ebp是新增加的。scopetable域指向一个scopetable_entry结构数组，而trylevel域实际上是这个数组的索引。最后一个域_ebp，是EXCEPTION_REGISTRATION结构创建之前栈帧指针（EBP）的值。&lt;/p&gt;
&lt;p&gt;​    _ebp域成为扩展的EXCEPTION_REGISTRATION结构的一部分并非偶然。它是通过PUSH EBP这条指令被包含进这个结构中的，而大多数函数开头都是这条指令（&lt;strong&gt;通常编译器并不为使用FPO优化的函数生成标准的堆栈帧，这样其第一条指令可能不是PUSH EBP。但是如果使用了SEH的话，那么无论你是否使用了FPO优化，编译器一定生成标准的堆栈帧&lt;/strong&gt;）。这条指令可以使EXCEPTION_REGISTRATION结构中所有其它的域都可以用一个相对于栈帧指针（EBP）的负偏移来访问。例如 trylevel域在[EBP-04]处，scopetable指针在[EBP-08]处，等等。（也就是说，这个结构是从[EBP-10H]处开始 的）&lt;/p&gt;
&lt;p&gt;​    紧跟着扩展的EXCEPTION_REGISTRATION结构下面，Visual C++压入了另外两个值。紧跟着（即[EBP-14H]处）的一个DWORD，是为一个指向&lt;strong&gt;EXCEPTION_POINTERS&lt;/strong&gt;结构（一个标准的Win32 结构）的指针所保留的空间。这个指针就是你调用&lt;strong&gt;GetExceptionInformation&lt;/strong&gt;这个API时返回的指针。尽管SDK文档暗示GetExceptionInformation是一个标准的Win32 API，但事实上它是一个编译器内联函数。当你调用这个函数时，Visual C++生成以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MOV EAX,DWORD PTR [EBP-14]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	GetExceptionInformation是一个编译器内联函数，与它相关的&lt;strong&gt;GetExceptionCode&lt;/strong&gt;函数也是如此。此函数实际上只是返回GetExceptionInformation返回的数据结构（EXCEPTION_POINTERS）中的一个结构 （EXCEPTION_RECORD）中的一个域（ExceptionCode）的值。当Visual C++为GetExceptionCode函数生成下面的指令时，它到底是想干什么？我把这个问题留给读者。（现在就能理解为什么SDK文档提醒我们要注意这两个函数的使用范围了。）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MOV EAX,DWORD PTR [EBP-14] ; // 执行完毕，EAX指向EXCEPTION_POINTERS结构
MOV EAX,DWORD PTR [EAX]     ;// 执行完毕，EAX指向EXCEPTION_RECORD结构
MOV EAX,DWORD PTR [EAX]     ;// 执行完毕，EAX中是ExceptionCode的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	现在回到扩展的EXCEPTION_REGISTRATION结构上来。在这个结构开始前的8个字节处（即[EBP-18H]处），Visual C++保留了一个DWORD来保存所有prolog代码执行完毕之后的堆栈指针（ESP）的值（实际生成的指令为MOV DWORD PTR [EBP-18H], ESP）。这个DWORD中保存的值是函数执行时ESP寄存器的正常值（除了在准备调用其它函数时把参数压入堆栈这个过程会改变ESP寄存器的值并在函数返回时恢复它的值外，函数在执行过程中一般不改变ESP寄存器的值）。&lt;/p&gt;
&lt;p&gt;​    看起来好像我一下子给你灌输了太多的信息，这点我承认。在继续下去之前，让我们先暂停，来回顾一下Visual C++为使用结构化异常处理的函数生成的标准异常堆栈帧，它看起来像下面这个样子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;EBP-00 _ebp
EBP-04 trylevel
EBP-08 scopetable数组指针
EBP-0C handler函数地址
EBP-10指向前一个EXCEPTION_REGISTRATION结构
EBP-14 GetExceptionInformation
EBP-18 栈帧中的标准ESP
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在操作系统看来，只存在组成原始EXCEPTION_REGISTRATION结构的两个域：即[EBP-10h]处的prev指针和[EBP-0Ch]处的handler函数指针。栈帧中的其它所有内容是针对于Visual C++的。把这个Visual C++生成的标准异常堆栈帧记到脑子里之后，让我们来看一下真正实现编译器层面SEH的这个Visual C++运行时库例程——__except_handler3。&lt;/p&gt;
&lt;p&gt;__except_handler3和scopetable&lt;/p&gt;
&lt;p&gt;​    我真的很希望让你看一看Visual C++运行时库源代码，让你自己好好研究一下__except_handler3函数，但是我办不到。因为Microsoft并没有提供。在这里你就将就着看一下我为__except_handler3函数写的伪代码吧（如图9所示）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int __except_handler3(
struct _EXCEPTION_RECORD * pExceptionRecord,
struct EXCEPTION_REGISTRATION * pRegistrationFrame,
struct _CONTEXT *pContextRecord,
void * pDispatcherContext )
{
    LONG filterFuncRet;
    LONG trylevel;
    EXCEPTION_POINTERS exceptPtrs;
    PSCOPETABLE pScopeTable;
    CLD // 将方向标志复位（不测试任何条件！）
    // 如果没有设置EXCEPTION_UNWINDING标志或EXCEPTION_EXIT_UNWIND标志
    // 表明这是第一次调用这个处理程序（也就是说，并非处于异常展开阶段）
    if ( ! (pExceptionRecord-&amp;gt;ExceptionFlags
        &amp;amp; (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)) )
    {
        // 在堆栈上创建一个EXCEPTION_POINTERS结构
        exceptPtrs.ExceptionRecord = pExceptionRecord;
        exceptPtrs.ContextRecord = pContextRecord;
        // 把前面定义的EXCEPTION_POINTERS结构的地址放在比
        // establisher栈帧低4个字节的位置上。参考前面我讲
        // 的编译器为GetExceptionInformation生成的汇编代码*(PDWORD)                        ((PBYTE)pRegistrationFrame - 4) = &amp;amp;exceptPtrs;
        // 获取初始的“trylevel”值
        trylevel = pRegistrationFrame-&amp;gt;trylevel;
        // 获取指向scopetable数组的指针 
        scopeTable = pRegistrationFrame-&amp;gt;scopetable;
        search_for_handler:
        if ( pRegistrationFrame-&amp;gt;trylevel != TRYLEVEL_NONE )
        {
            if ( pRegistrationFrame-&amp;gt;scopetable[trylevel].lpfnFilter )
            {
                PUSH EBP // 保存这个栈帧指针
                // ！！！非常重要！！！切换回原来的EBP。正是这个操作才使得
                // 栈帧上的所有局部变量能够在异常发生后仍然保持它的值不变。
                EBP = &amp;amp;pRegistrationFrame-&amp;gt;_ebp;
                // 调用过滤器函数
                filterFuncRet = scopetable[trylevel].lpfnFilter();
                POP EBP // 恢复异常处理程序的栈帧指针
                if ( filterFuncRet != EXCEPTION_CONTINUE_SEARCH )
                {
                    if ( filterFuncRet &amp;lt; 0 ) // EXCEPTION_CONTINUE_EXECUTION
                       return ExceptionContinueExecution;
 
                    // 如果能够执行到这里，说明返回值为EXCEPTION_EXECUTE_HANDLER
                    scopetable = pRegistrationFrame-&amp;gt;scopetable;
                    // 让操作系统清理已经注册的栈帧，这会使本函数被递归调用
                    __global_unwind2( pRegistrationFrame );
                    // 一旦执行到这里，除最后一个栈帧外，所有的栈帧已经
                    // 被清理完毕，流程要从最后一个栈帧继续执行
                    EBP = &amp;amp;pRegistrationFrame-&amp;gt;_ebp;
                    __local_unwind2( pRegistrationFrame, trylevel );
                    // NLG = &amp;quot;non-local-goto&amp;quot; (setjmp/longjmp stuff)
                    __NLG_Notify( 1 ); // EAX = scopetable-&amp;gt;lpfnHandler
                    // 把当前的trylevel设置成当找到一个异常处理程序时
                    // SCOPETABLE中当前正在被使用的那一个元素的内容
                    pRegistrationFrame-&amp;gt;trylevel = scopetable-&amp;gt;previousTryLevel;
                    // 调用__except {}块，这个调用并不会返回
                    pRegistrationFrame-&amp;gt;scopetable[trylevel].lpfnHandler();
                }
            }
 
            scopeTable = pRegistrationFrame-&amp;gt;scopetable;
            trylevel = scopeTable-&amp;gt;previousTryLevel;
            goto search_for_handler;
        }
        else // trylevel == TRYLEVEL_NONE
        {
            return ExceptionContinueSearch;
        }
    }
    else // 设置了EXCEPTION_UNWINDING标志或EXCEPTION_EXIT_UNWIND标志
    {
       PUSH EBP // 保存EBP
       EBP = &amp;amp;pRegistrationFrame-&amp;gt;_ebp; // 为调用__local_unwind2设置EBP
       __local_unwind2( pRegistrationFrame, TRYLEVEL_NONE )
       POP EBP // 恢复EBP
       return ExceptionContinueSearch;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;图9 __except_handler3函数的伪代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然__except_handler3的代码看起来很多，但是记住一点：它只是一个我在文章开头讲过的异常处理回调函数。它同MYSEH.EXE和 MYSEH2.EXE中的异常回调函数都带有同样的四个参数&lt;/p&gt;
&lt;p&gt;​    __except_handler3大体上可以由第一个if语句分为两部分。这是由于这个函数可以在两种情况下被调用，一次是正常调用，另一次是在展开阶段。其中大部分是在非展开阶段的回调。&lt;/p&gt;
&lt;p&gt;​    __except_handler3一开始就在堆栈上创建了一个EXCEPTION_POINTERS结构，并用它的两个参数来对这个结构进行初始化。我在伪代码中把这个结构称为 exceptPrts，它的地址被放在[EBP-14h]处。你回忆一下前面我讲的编译器为GetExceptionInformation和 GetExceptionCode函数生成的汇编代码就会意识到，这实际上初始化了这两个函数使用的指针。&lt;/p&gt;
&lt;p&gt;​    接着，__except_handler3从EXCEPTION_REGISTRATION帧中获取当前的trylevel（在[EBP-04h]处）。trylevel变量实际是scopetable数组的索引，而正是这个数组才使得一个函数中的多个__try块和嵌套的__try块能够仅使用一个 EXCEPTION_REGISTRATION结构。每个scopetable元素结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef struct _SCOPETABLE
{
   DWORD previousTryLevel;
   DWORD lpfnFilter;
   DWORD lpfnHandler;
} SCOPETABLE, *PSCOPETABLE;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SCOPETABLE结构中的第二个成员和第三个成员比较容易理解。它们分别是过滤器表达式代码的地址和相应的__except块的地址。但是prviousTryLevel成员有点复杂。总之一句话，它用于嵌套的__try块。这里的关键是函数中的每个__try块都有一个相应的SCOPETABLE结构。&lt;br&gt;
正如我前面所说，当前的trylevel指定了要使用的scopetable数组的哪一个元素，最终也就是指定了过滤器表达式和__except块的地址。 现在想像一下两个__try块嵌套的情形。如果内层__try块的过滤器表达式不处理某个异常，那外层__try块的过滤器表达式就必须处理它。那现在要问，__except_handler3是如何知道SCOPETABLE数组的哪个元素相应于外层的__try块的呢？答案是：外层__try块的索引由 SCOPETABLE结构的previousTryLevel域给出。利用这种机制，你可以嵌套任意层的__try块。previousTryLevel 域就好像是一个函数中所有可能的异常处理程序构成的线性链表中的结点一样。如果trylevel的值为0xFFFFFFFF（实际上就是-1，这个值在 EXSUP.INC中被定义为TRYLEVEL_NONE），标志着这个链表结束。&lt;/p&gt;
&lt;p&gt;​    回到__except_handler3的代码中。在获取了当前的trylevel之后，它就调用相应的SCOPETABLE结构中的过滤器表达式代码。如果过滤器表达式返回EXCEPTION_CONTINUE_SEARCH，__exception_handler3 移向SCOPETABLE数组中的下一个元素，这个元素的索引由previousTryLevel域给出。如果遍历完整个线性链表（还记得吗？这个链表是由于在一个函数内部嵌套使用__try块而形成的）都没有找到处理这个异常的代码，__except_handler3返回DISPOSITION_CONTINUE_SEARCH（原文如此，但根据_except_handler函数的定义，这个返回值应该为ExceptionContinueSearch。实际上这两个常量的值是一样的。我在伪代码中已经将其改正过来了），这导致系统移向下一个EXCEPTION_REGISTRATION帧（这个链表是由于函数嵌套调用而形成的）。&lt;/p&gt;
&lt;p&gt;​    如果过滤器表达式返回EXCEPTION_EXECUTE_HANDLER， 这意味着异常应该由相应的__except块处理。它同时也意味着所有前面的EXCEPTION_REGISTRATION帧都应该从链表中移除，并且相应的__except块都应该被执行。第一个任务通过调用__global_unwind2来完成的，后面我会讲到这个函数。跳过这中间的一些清理代码， 流程离开__except_handler3转向__except块。令人奇怪的是，流程并不从__except块中返回，虽然是 __except_handler3使用CALL指令调用了它。&lt;/p&gt;
&lt;p&gt;​    当前的trylevel值是如何被设置的呢？它实际上是由编译器隐含处理的。编译器非常机灵地修改这个扩展的EXCEPTION_REGISTRATION 结构中的trylevel域的值（实际上是生成修改这个域的值的代码）。如果你检查编译器为使用SEH的函数生成的汇编代码，就会在不同的地方都看到修改这个位于[EBP-04h]处的trylevel域的值的代码。&lt;/p&gt;
&lt;p&gt;​    __except_handler3是如何做到既通过CALL指令调用__except块而又不让执行流程返回呢？由于CALL指令要向堆栈中压入了一个返回地址，你可以想象这有可能破坏堆栈。如果你检查一下编译器为__except块生成的代码，你会发现它做的第一件事就是将EXCEPTION_REGISTRATION结构下面8个字节 处（即[EBP-18H]处）的一个DWORD值加载到ESP寄存器中（实际代码为MOV ESP,DWORD PTR [EBP-18H]）,这个值是在函数的prolog代码中被保存在这个位置的（实际代码为MOV DWORD PTR [EBP-18H],ESP）。&lt;/p&gt;
&lt;h3 id=&#34;5-showsehframes程序&#34;&gt;5、ShowSEHFrames程序&lt;/h3&gt;
&lt;p&gt;​    如果你现在觉得已经被EXCEPTION_REGISTRATION、scopetable、trylevel、过滤器表达式以及展开等等之类的词搞得晕头转向的话，那和我最初的感觉一样。但是编译器层面的结构化异常处理方面的知识并不适合一点一点的学。除非你从整体上理解它，否则有很多内容单独看并没有什么意义。当面对大堆的理论时，我最自然的做法就是写一些应用我学到的理论方面的程序。如果它能够按照预料的那样工作，我就知道我的理解（通常）是正确的。&lt;/p&gt;
&lt;p&gt;​    图10是ShowSEHFrame.EXE的源代码。它使用__try/__except块设置了好几个Visual C++ SEH帧。然后它显示每一个帧以及Visual C++为每个帧创建的scopetable的相关信息。这个程序本身并不生成也不依赖任何异常。相反，我使用了多个__try块以强制Visual C++生成多个EXCEPTION_REGISTRATION帧以及相应的scopetable。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//=========================================================
// ShowSEHFrames - Matt Pietrek 1997
// Microsoft Systems Journal, February 1997
// FILE: ShowSEHFrames.CPP
// 使用命令行CL ShowSehFrames.CPP进行编译//=========================================================
#define WIN32_LEAN_AND_MEAN
#include &amp;lt;windows.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#pragma hdrstop
 
//-------------------------------------------------------------------
// 本程序仅适用于Visual C++，它使用的数据结构是特定于Visual C++的
//-------------------------------------------------------------------
#ifndef _MSC_VER
#error Visual C++ Required (Visual C++ specific information is displayed)
#endif
 
//-------------------------------------------------------------------
// 结构定义
//-------------------------------------------------------------------
// 操作系统定义的基本异常帧
struct EXCEPTION_REGISTRATION
{
     EXCEPTION_REGISTRATION* prev;
     FARPROC handler;
};
 
// Visual C++扩展异常帧指向的数据结构
struct scopetable_entry
{
    DWORD previousTryLevel;
    FARPROC lpfnFilter;
    FARPROC lpfnHandler;
};
 
// Visual C++使用的扩展异常帧
struct VC_EXCEPTION_REGISTRATION : EXCEPTION_REGISTRATION
{
     scopetable_entry * scopetable;
     int trylevel;
     int _ebp;
};
 
//----------------------------------------------------------------
// 原型声明
//----------------------------------------------------------------
// __except_handler3是Visual C++运行时库函数，我们想打印出它的地址
// 但是它的原型并没有出现在任何头文件中，所以我们需要自己声明它。
extern &amp;quot;C&amp;quot; int _except_handler3(PEXCEPTION_RECORD,
                                EXCEPTION_REGISTRATION *,
                                PCONTEXT,
                                PEXCEPTION_RECORD);
 
//-------------------------------------------------------------
// 代码
//-------------------------------------------------------------
//
// 显示一个异常帧及其相应的scopetable的信息
//
void ShowSEHFrame( VC_EXCEPTION_REGISTRATION * pVCExcRec )
{
    printf( &amp;quot;Frame: %08X Handler: %08X Prev: %08X Scopetable: %08X\n&amp;quot;,
            pVCExcRec, pVCExcRec-&amp;gt;handler, pVCExcRec-&amp;gt;prev,
            pVCExcRec-&amp;gt;scopetable );
    scopetable_entry * pScopeTableEntry = pVCExcRec-&amp;gt;scopetable;
    for ( unsigned i = 0; i &amp;lt;= pVCExcRec-&amp;gt;trylevel; i++ )
    {
        printf( &amp;quot; scopetable[%u] PrevTryLevel: %08X &amp;quot;
            &amp;quot;filter: %08X __except: %08X\n&amp;quot;, i,
            pScopeTableEntry-&amp;gt;previousTryLevel,
            pScopeTableEntry-&amp;gt;lpfnFilter,
            pScopeTableEntry-&amp;gt;lpfnHandler );
        pScopeTableEntry++;
    }
    printf( &amp;quot;\n&amp;quot; );
    }
 
//
// 遍历异常帧的链表，按顺序显示它们的信息
//
void WalkSEHFrames( void )
{
    VC_EXCEPTION_REGISTRATION * pVCExcRec;
    // 打印出__except_handler3函数的位置
    printf( &amp;quot;_except_handler3 is at address: %08X\n&amp;quot;, _except_handler3 );
    printf( &amp;quot;\n&amp;quot; );
    // 从FS:[0]处获取指向链表头的指针
    __asm mov eax, FS:[0]
    __asm mov [pVCExcRec], EAX
    // 遍历异常帧的链表。0xFFFFFFFF标志着链表的结尾
    while ( 0xFFFFFFFF != (unsigned)pVCExcRec )
    {
       ShowSEHFrame( pVCExcRec );
       pVCExcRec = (VC_EXCEPTION_REGISTRATION *)(pVCExcRec-&amp;gt;prev);
    }
}
 
void Function1( void )
{
   // 嵌套3层__try块以便强制为scopetable数组产生3个元素
   __try
   {
         __try
         {
             __try
             {
                 WalkSEHFrames(); // 现在显示所有的异常帧的信息
             } __except( EXCEPTION_CONTINUE_SEARCH )
              {}
        } __except( EXCEPTION_CONTINUE_SEARCH )
          {}
    } __except( EXCEPTION_CONTINUE_SEARCH )
      {}
}
 
int main()
{
    int i;
    // 使用两个__try块（并不嵌套），这导致为scopetable数组生成两个元素
    __try
    {
        i = 0x1234;
    } __except( EXCEPTION_CONTINUE_SEARCH )
    {
        i = 0x4321;
    }
 
    __try
    {
        Function1(); // 调用一个设置更多异常帧的函数
    } __except( EXCEPTION_EXECUTE_HANDLER )
    {
       // 应该永远不会执行到这里，因为我们并没有打算产生任何异常
       printf( &amp;quot;Caught Exception in main\n&amp;quot; );
    }
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	ShowSEHFrames程序中比较重要的函数是WalkSEHFrames和ShowSEHFrame。WalkSEHFrames函数首选打印出 __except_handler3的地址，打印它的原因很快就清楚了。接着，它从FS:[0]处获取异常链表的头指针，然后遍历该链表。此链表中每个结 点都是一个VC_EXCEPTION_REGISTRATION类型的结构，它是我自己定义的，用于描述Visual C++的异常处理帧。对于这个链表中的每个结点，WalkSEHFrames都把指向这个结点的指针传递给ShowSEHFrame函数。&lt;/p&gt;
&lt;p&gt;​    ShowSEHFrame函数一开始就打印出异常处理帧的地址、异常处理回调函数的地址、前一个异常处理帧的地址以及scopetable的地址。接着，对于每个 scopetable数组中的元素，它都打印出其priviousTryLevel、过滤器表达式的地址以及相应的__except块的地址。我是如何知道scopetable数组中有多少个元素的呢？其实我并不知道。但是我假定VC_EXCEPTION_REGISTRATION结构中的当前trylevel域的值比scopetable数组中的元素总数少1。&lt;/p&gt;
&lt;p&gt;​    图11是ShowSEHFrames的运行结果。首先检查以“Frame:”开头的每一行，你会发现它们显示的异常处理帧在堆栈上的地址呈递增趋势，并且在前三个帧中，它们的异常处理程序的地址是一样的（都是004012A8）。再看输出的开始部分，你会发现这个004012A8不是别的，它正是 Visual C++运行时库函数__except_handler3的地址。这证明了我前面所说的单个回调函数处理所有异常这一点。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh_files/pietrk11.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;图11　ShowSEHFrames运行结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    你可能想知道为什么明明ShowSEHFrames程序只有两个函数使用SEH，但是却有三个异常处理帧使用__except_handler3作为它们的异常回调函数。实际上第三个帧来自Visual C++运行时库。Visual C++运行时库源代码中的CRT0.C文件清楚地表明了对main或WinMain的调用也被一个__try/__except块封装着。这个__try 块的过滤器表达式代码可以在WINXFLTR.C文件中找到。&lt;/p&gt;
&lt;p&gt;​    回到ShowSEHFrames程序，注意到最后一个帧的异常处理程序的地址是77F3AB6C，这与其它三个不同。仔细观察一下，你会发现这个地址在 KERNEL32.DLL中。这个特别的帧就是由KERNEL32.DLL中的BaseProcessStart函数安装的，这在前面我已经说过。&lt;/p&gt;
&lt;h3 id=&#34;6-展开&#34;&gt;6、展开&lt;/h3&gt;
&lt;p&gt;​    在挖掘展开（Unwinding）的实现代码之前让我们先来搞清楚它的意思。我在前面已经讲过所有可能的异常处理程序是如何被组织在一个由线程信息块的第一个DWORD（FS:[0]）所指向的链表中的。由于针对某个特定异常的处理程序可能不在这个链表的开头，因此就需要从链表中依次移除实际处理异常的那个 异常处理程序之前的所有异常处理程序。&lt;/p&gt;
&lt;p&gt;​    正如你在Visual C++的__except_handler3函数中看到的那样，展开是由__global_unwind2这个运行时库（RTL）函数来完成的。这个函数只是对RtlUnwind这个未公开的API进行了非常简单的封装。（现在这个API已经被公开了，但给出的信息极其简单，详细信息可以参考最新的Platform SDK文档。）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__global_unwind2(void * pRegistFrame)
{
    _RtlUnwind( pRegistFrame, &amp;amp;__ret_label, 0, 0 );
    __ret_label:
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然从技术上讲RtlUnwind是一个KERNEL32函数，但它只是转发到了NTDLL.DLL中的同名函数上。图12是我为此函数写的伪代码。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void _RtlUnwind( PEXCEPTION_REGISTRATION pRegistrationFrame,
                PVOID returnAddr, // 并未使用！（至少是在i386机器上）
                PEXCEPTION_RECORD pExcptRec,
                DWORD _eax_value)
{
   DWORD stackUserBase;
   DWORD stackUserTop;
   PEXCEPTION_RECORD pExcptRec;
   EXCEPTION_RECORD exceptRec;
   CONTEXT context;
   // 从FS:[4]和FS:[8]处获取堆栈的界限
RtlpGetStackLimits( &amp;amp;stackUserBase, &amp;amp;stackUserTop );
   if ( 0 == pExcptRec ) // 正常情况
   {
       pExcptRec = &amp;amp;excptRec;
      pExcptRec-&amp;gt;ExceptionFlags = 0;
      pExcptRec-&amp;gt;ExceptionCode = STATUS_UNWIND;
      pExcptRec-&amp;gt;ExceptionRecord = 0;
      pExcptRec-&amp;gt;ExceptionAddress = [ebp+4]; // RtlpGetReturnAddress()—获取返回地址
      pExcptRec-&amp;gt;ExceptionInformation[0] = 0;
   }
 
   if ( pRegistrationFrame )
       pExcptRec-&amp;gt;ExceptionFlags |= EXCEPTION_UNWINDING;
   else             // 这两个标志合起来被定义为EXCEPTION_UNWIND_CONTEXT
      pExcptRec-&amp;gt;ExceptionFlags|=(EXCEPTION_UNWINDING|EXCEPTION_EXIT_UNWIND);
   context.ContextFlags =( CONTEXT_i486 | CONTEXT_CONTROL |
           CONTEXT_INTEGER | CONTEXT_SEGMENTS);
   RtlpCaptureContext( &amp;amp;context );
    context.Esp += 0x10;
    context.Eax = _eax_value;
    PEXCEPTION_REGISTRATION pExcptRegHead;
    pExcptRegHead = RtlpGetRegistrationHead(); // 返回FS:[0]的值
    // 开始遍历EXCEPTION_REGISTRATION结构链表
    while ( -1 != pExcptRegHead )
    {
        EXCEPTION_RECORD excptRec2;
        if ( pExcptRegHead == pRegistrationFrame )
        {
           NtContinue( &amp;amp;context, 0 );
        }
        else
        {
           // 如果存在某个异常帧在堆栈上的位置比异常链表的头部还低
           // 说明一定出现了错误
           if ( pRegistrationFrame &amp;amp;&amp;amp; (pRegistrationFrame &amp;lt;= pExcptRegHead) )
           {
              // 生成一个异常
              excptRec2.ExceptionRecord = pExcptRec;
              excptRec2.NumberParameters = 0;
              excptRec2.ExceptionCode = STATUS_INVALID_UNWIND_TARGET;
              excptRec2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
              RtlRaiseException( &amp;amp;exceptRec2 );
            }
        }
 
        PVOID pStack = pExcptRegHead + 8; // 8 = sizeof(EXCEPTION_REGISTRATION)
        // 确保pExcptRegHead在堆栈范围内，并且是4的倍数
        if ( (stackUserBase &amp;lt;= pExcptRegHead )
              &amp;amp;&amp;amp; (stackUserTop &amp;gt;= pStack )
              &amp;amp;&amp;amp; (0 == (pExcptRegHead &amp;amp; 3)) )
        {
           DWORD pNewRegistHead;
           DWORD retValue;
           retValue = RtlpExecutehandlerForUnwind(pExcptRec, pExcptRegHead, &amp;amp;context,
                &amp;amp;pNewRegistHead, pExceptRegHead-&amp;gt;handler );
            if ( retValue != DISPOSITION_CONTINUE_SEARCH )
            {
               if ( retValue != DISPOSITION_COLLIDED_UNWIND )
               {
                  excptRec2.ExceptionRecord = pExcptRec;
                  excptRec2.NumberParameters = 0;
                  excptRec2.ExceptionCode = STATUS_INVALID_DISPOSITION;
                  excptRec2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                  RtlRaiseException( &amp;amp;excptRec2 );
               }
           else
              pExcptRegHead = pNewRegistHead;
        }
 
        PEXCEPTION_REGISTRATION pCurrExcptReg = pExcptRegHead;
        pExcptRegHead = pExcptRegHead-&amp;gt;prev;
        RtlpUnlinkHandler( pCurrExcptReg );
    }
    else // 堆栈已经被破坏！生成一个异常
    {
       excptRec2.ExceptionRecord = pExcptRec;
       excptRec2.NumberParameters = 0;
       excptRec2.ExceptionCode = STATUS_BAD_STACK;
       excptRec2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
       RtlRaiseException( &amp;amp;excptRec2 );
    }
}
 
        // 如果执行到这里，说明已经到了EXCEPTION_REGISTRATION
     // 结构链表的末尾，正常情况下不应该发生这种情况。
     //（因为正常情况下异常应该被处理，这样就不会到链表末尾）
     if ( -1 == pRegistrationFrame )
         NtContinue( &amp;amp;context, 0 );
     else
         NtRaiseException( pExcptRec, &amp;amp;context, 0 );
}
 
// RtlUnwind函数的伪代码到这里就结束了，以下是它调用的几个函数的伪代码：
PEXCEPTION_REGISTRATION RtlpGetRegistrationHead( void )
{
   return FS:[0];
}
 
RtlpUnlinkHandler( PEXCEPTION_REGISTRATION pRegistrationFrame )
{
   FS:[0] = pRegistrationFrame-&amp;gt;prev;
}
 
void RtlpCaptureContext( CONTEXT * pContext )
{
   pContext-&amp;gt;Eax = 0;
   pContext-&amp;gt;Ecx = 0;
   pContext-&amp;gt;Edx = 0;
   pContext-&amp;gt;Ebx = 0;
   pContext-&amp;gt;Esi = 0;
   pContext-&amp;gt;Edi = 0;
   pContext-&amp;gt;SegCs = CS;
   pContext-&amp;gt;SegDs = DS;
   pContext-&amp;gt;SegEs = ES;
   pContext-&amp;gt;SegFs = FS;
   pContext-&amp;gt;SegGs = GS;
   pContext-&amp;gt;SegSs = SS;
   pContext-&amp;gt;EFlags = flags; // 它对应的汇编代码为__asm{ PUSHFD / pop [xxxxxxxx] }
   pContext-&amp;gt;Eip = 此函数的调用者的调用者的返回地址    // 读者看一下这个函数的
   pContext-&amp;gt;Ebp = 此函数的调用者的调用者的EBP        // 汇编代码就会清楚这一点
   pContext-&amp;gt;Esp = pContext-&amp;gt;Ebp + 8;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;图12 RtlUnwind函数的伪代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    虽然RtlUnwind函数的规模看起来很大，但是如果你按一定方法把它分开，其实并不难理解。它首先从FS:[4]和FS:[8]处获取当前线程堆栈的界限。它们对于后面要进行的合法性检查非常重要，以确保所有将要被展开的异常帧都在堆栈范围内。&lt;/p&gt;
&lt;p&gt;​    RtlUnwind接着在堆栈上创建了一个空的EXCEPTION_RECORD结构并把STATUS_UNWIND赋给它的ExceptionCode域，同时把 EXCEPTION_UNWINDING标志赋给它的ExceptionFlags域。指向这个结构的指针作为其中一个参数被传递给每个异常回调函数。然后，这个函数调用RtlCaptureContext函数来创建一个空的CONTEXT结构，这个结构也变成了在展开阶段调用每个异常回调函数时传递给它们的一个参数。&lt;/p&gt;
&lt;p&gt;​    RtlUnwind函数的其余部分遍历EXCEPTION_REGISTRATION结构链表。对于其中的每个帧，它都调用 RtlpExecuteHandlerForUnwind函数，后面我会讲到这个函数。正是这个函数带EXCEPTION_UNWINDING标志调用了异常处理回调函数。每次回调之后，它调用RtlpUnlinkHandler移除相应的异常帧。&lt;/p&gt;
&lt;p&gt;​    RtlUnwind函数的第一个参数是一个帧的地址，当它遍历到这个帧时就停止展开异常帧。上面所说的这些代码之间还有一些安全性检查代码，它们用来确保不出问题。如果出现任何问题，RtlUnwind就引发一个异常，指示出了什么问题，并且这个异常带有EXCEPTION_NONCONTINUABLE标志。当一个进程被设 置了这个标志时，它就不允许再运行，必须终止。&lt;/p&gt;
&lt;h3 id=&#34;7-未处理异常&#34;&gt;7、未处理异常&lt;/h3&gt;
&lt;p&gt;​    在文章的前面，我并没有全面描述UnhandledExceptionFilter这个API。通常情况下你并不直接调用它（尽管你可以这么做）。大多数情况下它都是由KERNEL32中进行默认异常处理的过滤器表达式代码调用。前面BaseProcessStart函数的伪代码已经表明了这一点。&lt;/p&gt;
&lt;p&gt;​    图13是我为UnhandledExceptionFilter函数写的伪代码。这个API有点奇怪（至少在我看来是这样）。如果异常的类型是 EXCEPTION_ACCESS_VIOLATION，它就调用_BasepCheckForReadOnlyResource。虽然我没有提供这个函数的伪代码，但可以简要描述一下。如果是因为要对EXE或DLL的资源节（.rsrc）进行写操作而导致的异常，_BasepCurrentTopLevelFilter就改变出错页面正常的只读属性，以便允许进行写操作。如果是这种特殊的情况，UnhandledExceptionFilter返回EXCEPTION_CONTINUE_EXECUTION，使系统重新执行出错指令。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;UnhandledExceptionFilter( STRUCT _EXCEPTION_POINTERS *pExceptionPtrs )
{
    PEXCEPTION_RECORD pExcptRec;
    DWORD currentESP;
    DWORD retValue;
    DWORD DEBUGPORT;
    DWORD dwTemp2;
    DWORD dwUseJustInTimeDebugger;
    CHAR szDbgCmdFmt[256]; // 从AeDebug这个注册表键值返回的字符串
    CHAR szDbgCmdLine[256]; // 实际的调试器命令行参数（已填入进程ID和事件ID）
    STARTUPINFO startupinfo;
    PROCESS_INFORMATION pi;
    HARDERR_STRUCT harderr; // ???
    BOOL fAeDebugAuto;
    TIB * pTib; // 线程信息块
 
    pExcptRec = pExceptionPtrs-&amp;gt;ExceptionRecord;
    if ( (pExcptRec-&amp;gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
      &amp;amp;&amp;amp; (pExcptRec-&amp;gt;ExceptionInformation[0]) )
    {
        retValue=BasepCheckForReadOnlyResource(pExcptRec-&amp;gt;ExceptionInformation[1]);
        if ( EXCEPTION_CONTINUE_EXECUTION == retValue )
        return EXCEPTION_CONTINUE_EXECUTION;
    }
 
    // 查看这个进程是否运行于调试器下
    retValue = NtQueryInformationProcess(GetCurrentProcess(), ProcessDebugPort,
                                     &amp;amp;debugPort, sizeof(debugPort), 0 );
    if ( (retValue &amp;gt;= 0) &amp;amp;&amp;amp; debugPort ) // 通知调试器
    return EXCEPTION_CONTINUE_SEARCH;
    // 用户调用SetUnhandledExceptionFilter了吗？
    // 如果调用了，那现在就调用他安装的异常处理程序
    if ( _BasepCurrentTopLevelFilter )
    {
       retValue = _BasepCurrentTopLevelFilter( pExceptionPtrs );
       if ( EXCEPTION_EXECUTE_HANDLER == retValue )
          return EXCEPTION_EXECUTE_HANDLER;
       if ( EXCEPTION_CONTINUE_EXECUTION == retValue )
          return EXCEPTION_CONTINUE_EXECUTION;
    // 只有返回值为EXCEPTION_CONTINUE_SEARCH时才会继续执行下去
    }
    // 调用过SetErrorMode(SEM_NOGPFAULTERRORBOX)吗？
    {
        harderr.elem0 = pExcptRec-&amp;gt;ExceptionCode;
        harderr.elem1 = pExcptRec-&amp;gt;ExceptionAddress;
        if ( EXCEPTION_IN_PAGE_ERROR == pExcptRec-&amp;gt;ExceptionCode )
            harderr.elem2 = pExcptRec-&amp;gt;ExceptionInformation[2];
        else
            harderr.elem2 = pExcptRec-&amp;gt;ExceptionInformation[0];
 
        dwTemp2 = 1;
        fAeDebugAuto = FALSE;
        harderr.elem3 = pExcptRec-&amp;gt;ExceptionInformation[1];
        pTib = FS:[18h];
        DWORD someVal = pTib-&amp;gt;pProcess-&amp;gt;0xC;
        if ( pTib-&amp;gt;threadID != someVal )
        {
           __try
            {
                 char szDbgCmdFmt[256];
                 retValue = GetProfileStringA( &amp;quot;AeDebug&amp;quot;, &amp;quot;Debugger&amp;quot;, 0,
                        szDbgCmdFmt, sizeof(szDbgCmdFmt)-1 );
                if ( retValue )
                    dwTemp2 = 2;
                char szAuto[8];
                retValue = GetProfileStringA( &amp;quot;AeDebug&amp;quot;, &amp;quot;Auto&amp;quot;, &amp;quot;0&amp;quot;,
                    szAuto, sizeof(szAuto)-1 );
                if ( retValue )
                if ( 0 == strcmp( szAuto, &amp;quot;1&amp;quot; ) )
                if ( 2 == dwTemp2 )
                    fAeDebugAuto = TRUE;
            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
               ESP = currentESP;
               dwTemp2 = 1;
               fAeDebugAuto = FALSE;
            }
        }
 
        if ( FALSE == fAeDebugAuto )
        {
            retValue=NtRaiseHardError(STATUS_UNHANDLED_EXCEPTION | 0x10000000,
               4, 0, &amp;amp;harderr,_BasepAlreadyHadHardError ? 1 : dwTemp2,
               &amp;amp;dwUseJustInTimeDebugger );
        }
        else
        {
           dwUseJustInTimeDebugger = 3;
           retValue = 0;
        }
 
        if (retValue &amp;gt;= 0 &amp;amp;&amp;amp; (dwUseJustInTimeDebugger == 3)
            &amp;amp;&amp;amp; (!_BasepAlreadyHadHardError)&amp;amp;&amp;amp;(!_BaseRunningInServerProcess))
        {
            _BasepAlreadyHadHardError = 1;
            SECURITY_ATTRIBUTES secAttr = { sizeof(secAttr), 0, TRUE };
            HANDLE hEvent = CreateEventA( &amp;amp;secAttr, TRUE, 0, 0 );
            memset( &amp;amp;startupinfo, 0, sizeof(startupinfo) );
            sprintf(szDbgCmdLine, szDbgCmdFmt, GetCurrentProcessId(), hEvent);
            startupinfo.cb = sizeof(startupinfo);
            startupinfo.lpDesktop = &amp;quot;Winsta0\Default&amp;quot;
            CsrIdentifyAlertableThread(); // ???
            retValue = CreateProcessA( 0,           // 应用程序名称
                            szDbgCmdLine, // 命令行
                            0, 0,          // 进程和线程安全属性
                            1,             // bInheritHandles
                            0, 0,          // 创建标志、环境
                            0,             // 当前目录
                            &amp;amp;statupinfo, // STARTUPINFO
                            &amp;amp;pi);          // PROCESS_INFORMATION
            if ( retValue &amp;amp;&amp;amp; hEvent )
            {
               NtWaitForSingleObject( hEvent, 1, 0 );
               return EXCEPTION_CONTINUE_SEARCH;
            }
        }
 
        if ( _BasepAlreadyHadHardError )
            NtTerminateProcess(GetCurrentProcess(), pExcptRec-&amp;gt;ExceptionCode);
     }
 
    return EXCEPTION_EXECUTE_HANDLER;
}
 
LPTOP_LEVEL_EXCEPTION_FILTER
SetUnhandledExceptionFilter(
          LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter )
{
    // _BasepCurrentTopLevelFilter是KERNEL32.DLL中的一个全局变量
    LPTOP_LEVEL_EXCEPTION_FILTER previous= _BasepCurrentTopLevelFilter;
    // 设置为新值
    _BasepCurrentTopLevelFilter = lpTopLevelExceptionFilter;
    return previous; // 返回以前的值
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;图13 UnHandledExceptionFilter函数的伪代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UnhandledExceptionFilter接下来的任务是确定进程是否运行于Win32调试器下。也就是进程的创建标志中是否带有标志DEBUG_PROCESS或DEBUG_ONLY_THIS_PROCESS。 它使用NtQueryInformationProcess函数来确定进程是否正在被调试，我在本月的Under the Hood专栏中讲解了这个函数。如果正在被调试，UnhandledExceptionFilter就返回 EXCEPTION_CONTINUE_SEARCH，这告诉系统去唤醒调试器并告诉它在被调试程序（debuggee）中产生了一个异常。&lt;/p&gt;
&lt;p&gt;​    UnhandledExceptionFilter接下来调用用户安装的未处理异常过滤器（如果存在的话）。通常情况下，用户并没有安装回调函数，但是用户可以调用 SetUnhandledExceptionFilter这个API来安装。上面我也提供了这个API的伪代码。这个函数只是简单地用用户安装的回调函数的地址来替换一个全局变量，并返回替换前的值。&lt;/p&gt;
&lt;p&gt;​    有了初步的准备之后，UnhandledExceptionFilter就开始做它的主要工作：用一个时髦的应用程序错误对话框来通知你犯了低级的编程错误。有两种方法可以避免出现这个对话框。第一种方法是调用SetErrorMode函数并指定SEM_NOGPFAULTERRORBOX标志。另一种方法是将AeDebug子键下的Auto的值设为1。此时UnhandledExceptionFilter跳过应用程序错误对话框直接启动AeDebug子键下的Debugger的值所指定的调试器。如果你熟悉“即时调试（Just In Time Debugging，JIT）”的话，这就是操作系统支持它的地方。接下来我会详细讲。&lt;/p&gt;
&lt;p&gt;​    大多数情况下，上面的两个条件都为假。这样UnhandledExceptionFilter就调用NTDLL.DLL中的 NtRaiseHardError函数。正是这个函数产生了应用程序错误对话框。这个对话框等待你单击“确定”按钮来终止进程，或者单击“取消”按钮来调试它（单击“取消”按钮而不是“确定”按钮来加载调试器好像有点颠倒了，可能这只是我个人的感觉吧）。&lt;/p&gt;
&lt;p&gt;​    如果你单击“确定”，UnhandledExceptionFilter就返回EXCEPTION_EXECUTE_HANDLER。调用UnhandledExceptionFilter 的进程通常通过终止自身来作为响应（正像你在BaseProcessStart的伪代码中看到的那样）。这就产生了一个有趣的问题——大多数人都认为是系统终止了产生未处理异常的进程，而实际上更准确的说法应该是，系统进行了一些设置使得产生未处理异常的进程将自身终止掉了。&lt;/p&gt;
&lt;p&gt;​    UnhandledExceptionFilter执行时真正有意思的部分是当你单击应用程序错误对话框中的“取消”按钮，此时系统将调试器附加（attach）到出错进程上。这段代码首先调用 CreateEvent来创建一个事件内核对象，调试器成功附加到出错进程之后会将此事件对象变成有信号状态。这个事件句柄以及出错进程的ID都被传到sprintf函数，由它将其格式化成一个命令行，用来启动调试器。一切就绪之后，UnhandledExceptionFilter就调用 CreateProcess来启动调试器。如果CreateProcess成功，它就调用NtWaitForSingleObject来等待前面创建的那个事件对象。此时这个调用被阻塞，直到调试器进程将此事件变成有信号状态，以表明它已经成功附加到出错进程上。 UnhandledExceptionFilter函数中还有一些其它的代码，我在这里只讲重要的。&lt;/p&gt;
&lt;h3 id=&#34;8-进入地狱&#34;&gt;8、进入地狱&lt;/h3&gt;
&lt;p&gt;​    如果你已经走了这么远，不把整个过程讲完对你有点不公平。我已经讲了当异常发生时操作系统是如何调用用户定义的回调函数的。我也讲了这些回调的内部情况，以及编译器是如何使用它们来实现__try和__except的。我甚至还讲了当某个异常没有被处理时所发生的情况以及系统所做的扫尾工作。剩下的就只有异常回调过程最初是从哪里开始的这个问题了。好吧，让我们深入系统内部来看一下结构化异常处理的开始阶段吧。&lt;/p&gt;
&lt;p&gt;​    图14是我为KiUserExceptionDispatcher函数和一些相关函数写的伪代码。这个函数在NTDLL.DLL中，它是异常处理执行的起点。为了绝对准确起见，我必须指出：刚才说的并不是绝对准确。例如在Intel平台上，一个异常导致CPU将控制权转到ring 0（0特权级，即内核模式）的一个处理程序上。这个处理程序由中断描述符表（Interrupt Descriptor Table，IDT）中的一个元素定义，它是专门用来处理相应异常的。我跳过所有的内核模式代码，假设当异常发生时CPU直接将控制权转到了 KiUserExceptionDispatcher函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;KiUserExceptionDispatcher( PEXCEPTION_RECORD pExcptRec, CONTEXT * pContext )
{
   DWORD retValue;
    // 注意：如果异常被处理，那么RtlDispatchException函数就不会返回
    if ( RtlDispatchException( pExceptRec, pContext ) )
       retValue = NtContinue( pContext, 0 );
    else
       retValue = NtRaiseException( pExceptRec, pContext, 0 );
 
    EXCEPTION_RECORD excptRec2;
    excptRec2.ExceptionCode = retValue;
    excptRec2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    excptRec2.ExceptionRecord = pExcptRec;
    excptRec2.NumberParameters = 0;
    RtlRaiseException( &amp;amp;excptRec2 );
}
 
int RtlDispatchException( PEXCEPTION_RECORD pExcptRec, CONTEXT * pContext )
{
    DWORD stackUserBase;
    DWORD stackUserTop;
    PEXCEPTION_REGISTRATION pRegistrationFrame;
    DWORD hLog;
 
    // 从FS:[4]和FS:[8]处获取堆栈的界限
    RtlpGetStackLimits( &amp;amp;stackUserBase, &amp;amp;stackUserTop );
    pRegistrationFrame = RtlpGetRegistrationHead();
    while ( -1 != pRegistrationFrame )
    {
        PVOID justPastRegistrationFrame = &amp;amp;pRegistrationFrame + 8;
        if ( stackUserBase &amp;gt; justPastRegistrationFrame )
        {
           pExcptRec-&amp;gt;ExceptionFlags |= EH_STACK_INVALID;
           return DISPOSITION_DISMISS; // 0
        }
 
        if ( stackUsertop &amp;lt; justPastRegistrationFrame )
        {
           pExcptRec-&amp;gt;ExceptionFlags |= EH_STACK_INVALID;
           return DISPOSITION_DISMISS; // 0
        }
 
        if ( pRegistrationFrame &amp;amp; 3 ) // 确保堆栈按DWORD对齐
        {
           pExcptRec-&amp;gt;ExceptionFlags |= EH_STACK_INVALID;
           return DISPOSITION_DISMISS; // 0
        }
 
        if ( someProcessFlag )
        {
           hLog = RtlpLogExceptionHandler( pExcptRec, pContext, 0,
                                 pRegistrationFrame, 0x10 );
        }
 
        DWORD retValue, dispatcherContext;
        retValue= RtlpExecuteHandlerForException(pExcptRec, pRegistrationFrame,
        pContext, &amp;amp;dispatcherContext,
        pRegistrationFrame-&amp;gt;handler );
 
        if ( someProcessFlag )
            RtlpLogLastExceptionDisposition( hLog, retValue );
        if ( 0 == pRegistrationFrame )
        {
           pExcptRec-&amp;gt;ExceptionFlags &amp;amp;= ~EH_NESTED_CALL; // 关闭标志
        }
 
        EXCEPTION_RECORD excptRec2;
        DWORD yetAnotherValue = 0;
        if ( DISPOSITION_DISMISS == retValue )
        {
           if ( pExcptRec-&amp;gt;ExceptionFlags &amp;amp; EH_NONCONTINUABLE )
           {
              excptRec2.ExceptionRecord = pExcptRec;
              excptRec2.ExceptionNumber = STATUS_NONCONTINUABLE_EXCEPTION;
              excptRec2.ExceptionFlags    = EH_NONCONTINUABLE;
              excptRec2.NumberParameters = 0;
              RtlRaiseException( &amp;amp;excptRec2 );
           }
           else
              return DISPOSITION_CONTINUE_SEARCH;
        }
        else if ( DISPOSITION_CONTINUE_SEARCH == retValue )
        {}
        else if ( DISPOSITION_NESTED_EXCEPTION == retValue )
        {
           pExcptRec-&amp;gt;ExceptionFlags |= EH_EXIT_UNWIND;
           if ( dispatcherContext &amp;gt; yetAnotherValue )
               yetAnotherValue = dispatcherContext;
        }
        else // DISPOSITION_COLLIDED_UNWIND
        {
           excptRec2.ExceptionRecord = pExcptRec;
           excptRec2.ExceptionNumber = STATUS_INVALID_DISPOSITION;
           excptRec2.ExceptionFlags    = EH_NONCONTINUABLE;
           excptRec2.NumberParameters = 0;
           RtlRaiseException( &amp;amp;excptRec2 );
        }
        pRegistrationFrame = pRegistrationFrame-&amp;gt;prev; // 转到前一个帧
    }
return DISPOSITION_DISMISS;
}
 
_RtlpExecuteHandlerForException: // 处理异常（第一次）
MOV EDX,XXXXXXXX
JMP ExecuteHandler
RtlpExecutehandlerForUnwind: // 处理展开（第二次）
MOV EDX,XXXXXXXX
 
int ExecuteHandler( PEXCEPTION_RECORD pExcptRec,
PEXCEPTION_REGISTRATION pExcptReg,
CONTEXT * pContext,
PVOID pDispatcherContext,
FARPROC handler ) // 实际上是指向_except_handler()的指针
{
    // 安装一个EXCEPTION_REGISTRATION帧，EDX指向相应的handler代码
    PUSH EDX
    PUSH FS:[0]
    MOV FS:[0],ESP
    // 调用异常处理回调函数
    EAX = handler( pExcptRec, pExcptReg, pContext, pDispatcherContext );
    // 移除EXCEPTION_REGISTRATION帧
    MOV ESP,DWORD PTR FS:[00000000]
    POP DWORD PTR FS:[00000000]
    return EAX;
}
 
_RtlpExecuteHandlerForException使用的异常处理程序：
{
   // 如果设置了展开标志，返回DISPOSITION_CONTINUE_SEARCH
   // 否则，给pDispatcherContext赋值并返回DISPOSITION_NESTED_EXCEPTION
   return pExcptRec-&amp;gt;ExceptionFlags &amp;amp; EXCEPTION_UNWIND_CONTEXT ?
            DISPOSITION_CONTINUE_SEARC : ( *pDispatcherContext = 
                                           pRegistrationFrame-&amp;gt;scopetable,
                                           DISPOSITION_NESTED_EXCEPTION );
}
 
_RtlpExecuteHandlerForUnwind使用的异常处理程序：
{
    // 如果设置了展开标志，返回DISPOSITION_CONTINUE_SEARCH
    // 否则，给pDispatcherContext赋值并返回DISPOSITION_COLLIDED_UNWIND
    return pExcptRec-&amp;gt;ExceptionFlags &amp;amp; EXCEPTION_UNWIND_CONTEXT ?
            DISPOSITION_CONTINUE_SEARCH : ( *pDispatcherContext = 
                                           pRegistrationFrame-&amp;gt;scopetable,
                                            DISPOSITION_COLLIDED_UNWIND );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;图14 KiUserExceptionDispatcher的伪代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    KiUserExceptionDispatcher的核心是对RtlDispatchException的调用。这拉开了搜索已注册的异常处理程序的序幕。如果某个处理程序处理这个异常并继续执行，那么对 RtlDispatchException的调用就不会返回。如果它返回了，只有两种可能：或者调用了NtContinue以便让进程继续执行，或者产生了新的异常。如果是这样，那异常就不能再继续处理了，必须终止进程。&lt;/p&gt;
&lt;p&gt;​    现在把目光对准RtlDispatchException函数的代码，这就是我通篇提到的遍历异常帧的代码。这个函数获取一个指向EXCEPTION_REGISTRATION结构链表的指针，然后遍历此链表以寻找一个异常处理程序。由于堆栈可能已经被破坏了，所以这个例程非常谨慎。在调用每个EXCEPTION_REGISTRATION结构中指定的异常处理程序之前，它确保这个结构是按DWORD对齐的，并且是在线程的堆栈之中，同时在堆栈中比前一个EXCEPTION_REGISTRATION结构高。&lt;br&gt;
RtlDispatchException并不直接调用EXCEPTION_REGISTRATION结构中指定的异常处理程序。相反，它调用 RtlpExecuteHandlerForException来完成这个工作。根据RtlpExecuteHandlerForException的执行情况，RtlDispatchException或者继续遍历异常帧，或者引发另一个异常。这第二次的异常表明异常处理程序内部出现了错误，这样就不能继续执行下去了。&lt;/p&gt;
&lt;p&gt;​    RtlpExecuteHandlerForException的代码与RtlpExecuteHandlerForUnwind的代码极其相似。你可能会回忆起来在前面讨论展开时我提到过它。这两个“函数”都只是简单地给EDX寄存器加载一个不同的值然后就调用ExecuteHandler函数。也就是说，RtlpExecuteHandlerForException和RtlpExecuteHandlerForUnwind都是ExecuteHanlder这个公共函数的前端。&lt;/p&gt;
&lt;p&gt;​    ExecuteHandler查找EXCEPTION_REGISTRATION结构的handler域的值并调用它。令人奇怪的是，对异常处理回调函数的调用本身也被一个结构化异常处 理程序封装着。在SEH自身中使用SEH看起来有点奇怪，但你思索一会儿就会理解其中的含义。如果在异常回调过程中引发了另外一个异常，操作系统需要知道这个情况。根据异常发生在最初的回调阶段还是展开回调阶段，ExecuteHandler或者返回DISPOSITION_NESTED_EXCEPTION，或者返回DISPOSITION_COLLIDED_UNWIND。这两者都是“红色警报！现在把一切都关掉！”类型的代码。&lt;/p&gt;
&lt;p&gt;​    如果你像我一样，那不仅理解所有与SEH有关的函数非常困难，而且记住它们之间的调用关系也非常困难。为了帮助我自己记忆，我画了一个调用关系图（图15）。&lt;/p&gt;
&lt;p&gt;​    现在要问：在调用ExecuteHandler之前设置EDX寄存器的值有什么用呢？这非常简单。如果ExecuteHandler在调用用户安装的异常处 理程序的过程中出现了什么错误，它就把EDX指向的代码作为原始的异常处理程序。它把EDX寄存器的值压入堆栈作为原始的 EXCEPTION_REGISTRATION结构的handler域。这基本上与我在MYSEH和MYSEH2中对原始的结构化异常处理的使用情况一样。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh_files/pietrk15.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;图15 在SEH中是谁调用了谁&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;9-结论&#34;&gt;9、结论&lt;/h3&gt;
&lt;p&gt;​    结构化异常处理是Win32一个非常好的特性。多亏有了像Visual C++之类的编译器的支持层对它的封装，一般的程序员才能付出比较小的学习代价就能利用SEH所提供的便利。但是在操作系统层面上，事情远比Win32文档说的复杂。&lt;/p&gt;
&lt;p&gt;​    不幸的是，由于人人都认为系统层面的SEH是一个非常困难的问题，因此至今这方面的资料都不多。在本文中，我已经向你指出了系统层面的SEH就是围绕着简单的回调在打转。如果你理解了回调的本质，在此基础上分层理解，系统层面的结构化异常处理也不是那么难掌握。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本文仅对原文的翻译进行转载记录，用于个人学习。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;原文链接：&lt;a href=&#34;https://bytepointer.com/resources/pietrek_crash_course_depths_of_win32_seh.htm&#34;&gt;A Crash Course on theDepths of Win32 Structured Exception Handling, MSJ January 1997 (bytepointer.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">深入解析结构化异常处理（SEH）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/2023-quan-guo-zhi-neng-jia-shi-ce-shi-sai-che-lian-wang-an-quan-zhuan-xiang-sai-wp-re/"" data-c="
          &lt;p&gt;中间短暂的拿到了第一名，可惜最后止步12名，www。。。&lt;br&gt;
&lt;strong&gt;RRRRust&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单rust逆向&lt;/li&gt;
&lt;li&gt;首先找到密文，然后找关键逻辑，发现只有一个异或&lt;/li&gt;
&lt;li&gt;直接脚本解密&lt;br&gt;
c=&#39;&#39;&lt;br&gt;
x=&#39;e&amp;gt;?d7a411zakf`|e4ec16754c65&amp;gt;a&amp;gt;b4&amp;gt;e3f51&#39;&lt;br&gt;
for i in range(len(x)):&lt;br&gt;
c+=chr(ord(x[i])^7)&lt;br&gt;
print(c)&lt;/li&gt;
&lt;li&gt;得到b98c0f366}flag{b3bd61023d129f9e39b4a26&lt;/li&gt;
&lt;li&gt;调整一下位置即可&lt;/li&gt;
&lt;li&gt;flag{b3bd61023d129f9e39b4a26b98c0f366}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SomethingInIt：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IDA64打开，发现程序实现了一个双层的vm&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先考虑用Inter-pin进行爆破&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到关键输入点以及最后的比较代码case 0x28,case0x29：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用pin爆破即可，下面为爆破脚本：&lt;br&gt;
`from pwn import *&lt;br&gt;
import subprocess&lt;br&gt;
def run(msg):&lt;br&gt;
cmd = [&lt;br&gt;
&amp;quot;/home/tanggerr/Downloads/pin-3.28-98749-g6643ecee5-gcc-linux/pin&amp;quot;,&lt;br&gt;
&amp;quot;-t&amp;quot;, &amp;quot;/home/tanggerr/Downloads/pin-3.28-98749-g6643ecee5-gcc-linux/source/tools/ManualExamples/obj-intel64/inscount0.so&amp;quot;,&lt;br&gt;
&amp;quot;-o&amp;quot;, &amp;quot;/home/tanggerr/Downloads/pin-3.28-98749-g6643ecee5-gcc-linux/source/tools/ManualExamples/inscount0.log&amp;quot;,&lt;br&gt;
&amp;quot;--&amp;quot;,&lt;br&gt;
&amp;quot;/home/tanggerr/challenge&amp;quot;&lt;br&gt;
]&lt;br&gt;
p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)&lt;/p&gt;
&lt;p&gt;p.stdin.write(msg.encode())&lt;br&gt;
p.stdin.flush()&lt;/p&gt;
&lt;p&gt;output = p.stdout.readline()&lt;/p&gt;
&lt;p&gt;p.terminate()&lt;br&gt;
return int(read(&amp;quot;/home/tanggerr/Downloads/pin-3.28-98749-g6643ecee5-gcc-linux/source/tools/ManualExamples/inscount0.log&amp;quot;).split(&amp;quot; &amp;quot;)[1])&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;def read(fname):&lt;br&gt;
with open(fname) as f:&lt;br&gt;
return f.read()&lt;/p&gt;
&lt;p&gt;charset = string.printable&lt;/p&gt;
&lt;p&gt;l = []&lt;br&gt;
flag = &amp;quot;&amp;quot;&lt;br&gt;
counter = 0&lt;/p&gt;
&lt;p&gt;while(True):&lt;br&gt;
max_chr = 0&lt;br&gt;
first_iteration = True&lt;br&gt;
for chr in charset:&lt;br&gt;
tmp = run(flag + chr)&lt;br&gt;
if first_iteration:&lt;br&gt;
max_value = tmp&lt;br&gt;
first_iteration = False&lt;br&gt;
if tmp &amp;gt; max_value:&lt;br&gt;
max_chr = chr&lt;br&gt;
max_value = tmp&lt;br&gt;
break&lt;br&gt;
print(max_chr)&lt;br&gt;
flag += str(max_chr)&lt;br&gt;
print(flag)`&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大概一个多小时即可爆破出flag&lt;/li&gt;
&lt;li&gt;flag{Is_thi5_VM_THAT_1s_1n_vm_beautiful?!}&lt;/li&gt;
&lt;/ul&gt;
">2023-全国智能驾驶测试赛-车联网安全专项赛WP (Re)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/fsctf2023-wp-reandcrypto/"" data-c="
          &lt;p&gt;第一次做出题人，共出题10道（4道re，6道密码），现将wp补充在下面，做个记录。。。&lt;/p&gt;
&lt;h2 id=&#34;fsctf2023-re-wp-出题人tanggerr&#34;&gt;FSCTF2023 re WP ------出题人：Tanggerr&lt;/h2&gt;
&lt;h2 id=&#34;ezbroke&#34;&gt;ezbroke&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DIE查壳&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拖进010查看：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现PE头被修改了，先把开头标识改为4D 5A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再看3C处，指向70处，而80处才是50 45，故修改为80&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存后发现有UPX壳，但是不能直接去除，再用010看&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现UPX特征码被改掉了，故把所有的TUT改为UPX&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时再去查壳&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;经典3.96壳，直接工具脱壳即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;32位无壳程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拖入IDA，看main函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其实是一个很简单的vm，我们恢复一下opcode即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据提示，我们找到opcode与一些handler即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void __noreturn main()
{
  int v0; // [esp+1Ch] [ebp-4h] BYREF

  __main();
  v0 = 0;
  puts(&amp;quot;We1c0me t0 FSCTF&amp;quot;);
  puts(&amp;quot;---------------------&amp;quot;);
  puts(&amp;quot;please input the flag:&amp;quot;);
  vm_init((vm_cpu *)&amp;amp;v0);
  vm_start((vm_cpu *)&amp;amp;v0);
  check();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到vm_init：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void __cdecl vm_init(vm_cpu *cpu)
{
  cpu-&amp;gt;r1 = 0;
  cpu-&amp;gt;r2 = 0;
  cpu-&amp;gt;r3 = 0;
  cpu-&amp;gt;eip = vm_code;
  cpu-&amp;gt;op_list[0].opcode = -15;
  cpu-&amp;gt;op_list[0].handle = (void (*)(void *))mov;
  cpu-&amp;gt;op_list[1].opcode = -14;
  cpu-&amp;gt;op_list[1].handle = (void (*)(void *))xor;
  cpu-&amp;gt;op_list[2].opcode = -11;
  cpu-&amp;gt;op_list[2].handle = (void (*)(void *))read_;
  vm_stack = (char *)malloc(0x512u);
  memset(vm_stack, 0, 0x512u);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void __cdecl xor(vm_cpu *cpu)
{
  cpu-&amp;gt;r1 ^= cpu-&amp;gt;r2 ^ 0x17;
  ++cpu-&amp;gt;eip;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;check函数：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void __noreturn check()
{
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i &amp;lt;= 11; ++i )
  {
    if ( vm_stack[i + 32] != enc_flag[i] )
    {
      puts(&amp;quot;think please&amp;quot;);
      exit(0);
    }
  }
  puts(&amp;quot;Success!&amp;quot;);
  exit(0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;看完函数，我们把opcode提取出来对应handler进行翻译&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;0xF5, 0xF1, 0xE1, 0x00, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 
0x20, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x01, 0x00, 0x00, 0x00, 
0xF2, 0xF1, 0xE4, 0x21, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x02, 
0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x22, 0x00, 0x00, 0x00, 
0xF1, 0xE1, 0x03, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x23, 
0x00, 0x00, 0x00, 0xF1, 0xE1, 0x04, 0x00, 0x00, 0x00, 0xF2, 
0xF1, 0xE4, 0x24, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x05, 0x00, 
0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x25, 0x00, 0x00, 0x00, 0xF1, 
0xE1, 0x06, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x26, 0x00, 
0x00, 0x00, 0xF1, 0xE1, 0x07, 0x00, 0x00, 0x00, 0xF2, 0xF1, 
0xE4, 0x27, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x08, 0x00, 0x00, 
0x00, 0xF2, 0xF1, 0xE4, 0x28, 0x00, 0x00, 0x00, 0xF1, 0xE1, 
0x09, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x29, 0x00, 0x00, 
0x00, 0xF1, 0xE1, 0x0A, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 
0x2A, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0B, 0x00, 0x00, 0x00, 
0xF2, 0xF1, 0xE4, 0x2B, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0C, 
0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2C, 0x00, 0x00, 0x00, 
0xF4
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有一个异或操作，直接写脚本：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;c=&#39;&#39;
x=[0x51, 0x44, 0x54, 0x43, 0x51, 0x6C, 0x4E, 0x27, 0x62, 0x37, 0x64, 0x62, 0x74, 0x74, 0x72, 0x64, 0x64, 0x71, 0x62, 0x26, 0x26, 0x6E, 0x37, 0x75, 0x65, 0x27, 0x7C, 0x24, 0x37, 0x7A, 0x6E, 0x37, 0x67, 0x65, 0x27, 0x63, 0x24, 0x74, 0x63, 0x26, 0x27, 0x79, 0x36, 0x36, 0x36, 0x6A]
for i in range(len(x)):
    c+=chr(x[i]^0x17)
print(c)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;得到flag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;FSCTF{Y0u successfu11y br0k3 my pr0t3ct10n!!!}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ezcode&#34;&gt;ezcode&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;手撕python字节码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析可得是魔改RC4及base64换表加密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接上脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def func1(key, message):
    s_box = func2(key)
    crypt = str(func3(message, s_box))
    return crypt

def func2(key):
    s_box = list(range(256))
    j = 0
    for i in range(256):
        j = (j + s_box[i] + ord(key[i % len(key)])) % 256
        s_box[i], s_box[j] = s_box[j], s_box[i]
    return s_box

def func3(plain, box):
    res = []
    y=&#39;FSCTF&#39;
    i = j = 0
    for s in plain:
        i = (i + 1) % 256
        j = (j + box[i]) % 256
        box[i], box[j] = box[j], box[i]
        t = (box[i] + box[j]) % 256
        k = box[t]
        res.append(chr(ord(s) ^ k ^ ord(y[i % len(y)])))
        cipher = &amp;quot;&amp;quot;.join(res)
    return cipher

def rc4_decrypt(key, cipher):
    s_box = func2(key)
    plain = []
    y = &#39;FSCTF&#39;
    i = j = 0
    for c in cipher:
        i = (i + 1) % 256
        j = (j + s_box[i]) % 256
        s_box[i], s_box[j] = s_box[j], s_box[i]
        t = (s_box[i] + s_box[j]) % 256
        k = s_box[t]
        plain.append(chr(ord(c) ^ k ^ ord(y[i % len(y)])))
        message = &amp;quot;&amp;quot;.join(plain)
    return message

key = &amp;quot;XFFTnT&amp;quot;
cipher = &amp;quot;=.#MØQïòtÂÐ­v|·&amp;quot;
message = rc4_decrypt(key, cipher)
print(message)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解得&lt;em&gt;&lt;strong&gt;FSCTF{G00d_j0b!!!}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mine-sweeper&#34;&gt;MINE SWEEPER&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;签到题，IDA打开，搜索字符串即有flag&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rrrrust&#34;&gt;rrrrust!!!&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查壳，ELF64位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rust逆向&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到主函数中的关键函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意到：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;qmemcpy(v63, &amp;quot;&amp;gt;*&#39;3&amp;quot;, 4);
v63[4] = 21;
v63[5] = 3;
v63[6] = 61;
v63[7] = 119;
v63[8] = 37;
v63[9] = 100;
v63[10] = 3;
v63[11] = 103;
v63[12] = 7;
v63[13] = 50;
v63[14] = 118;
v63[15] = 11;
v63[16] = 28;
v63[17] = 33;
v63[18] = 43;
v63[19] = 50;
v63[20] = 25;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;明显的关键字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在程序输入处下断点，直接动调，观察输入的字符串的变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现只是在进行一个循环异或&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们动调出来异或密钥为XFFTnT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接上脚本解密就行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x=[0x3E, 0x2A, 0x27, 0x33, 0x15, 0x03, 0x3D, 0x77, 0x25, 0x64,
  0x03, 0x67, 0x07, 0x32, 0x76, 0x0B, 0x1C, 0x21, 0x2B, 0x32,
  0x19, 0x23, 0x5E, 0x26, 0x69, 0x22, 0x3B]
y=&#39;XFFTnT&#39;
c=&#39;&#39;
for i in range(len(x)):
    c+=chr(x[i]^ord(y[i%len(y)]))
print(c)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;flag{We1c0m3_t0_rust_w0r1d}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;fsctf2023-crypto-wp-出题人tanggerr&#34;&gt;FSCTF2023 Crypto WP---出题人：Tanggerr&lt;/h1&gt;
&lt;h2 id=&#34;do-you-know-gcd&#34;&gt;Do you know gcd&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发现两个模数有公因子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接gcd破解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from Crypto.Util.number import *
e=65537
n1= 18680935400842120133090782991548100098299141114788036098274292600814484762178879421175852824971602717084073867867453382415307589970440719890918576225495401632854107018246844209327118177917122236073227158593514362850629722223228335334773008682775987859295083444638923726449899310854161394586430943134469559429878238769266114132469166535509030877235272476877484918308883799496627699789051809542538091061550107526246728583019140703765888157806778516567048103700384849598143249322109207879381251223776896702362630437178664824125387477797876186939235800859102380783259361745143574493440078787931593394188675093506492640857
n2= 16308523133405725830120564525574438512803584148781960516042054284309437381876822602134185065101371986717984978566359252072738078020261823966208153922611063201149105749778596739692554295573408850719208215646167050188830459343054219856901871953140988948482577813730729085764541988120049026971705499798003225755018687242522370406495429425494022876627543617474873929054728724093702291448754458748923218635900061398716191201846139296921753782690468189409101899415028480878296408735247604084627019116374444335509072590669239349212479592499426230525792270750612371117196200786891891430446212938482959351978202358044864822577
c1= 534518909595318304521410713148076850830155521838755402438490325620155197496935820831936109252194297244161393310730073882257949954815312409974998733265641354273665213856408848764503848122264972023143474923678585167025591255034150826271791019266426616987355463111138963331008761826310757292765842789380409826387579098421126952331558360737102888876551724241978020305977032047901621477384392409864427091911872691182528938458750707982564581322551517287491916691010743390992018974168703956622998928457142606354825714033609199676987795174032254878017883605565760275857658822315970522114838062469258676628619381342357632179
c2= 10248394002302905069278122013496854496130190499518622376819239887579692634750808499513497018453473232140518824608976734237637842228035017757831938865937098325684711995382081489403971465596662585196007547659143066184546400992333479193424580690897692586491475768279754939199148642035267049092880715299621206567123356521609120801306358100326600900326310677054810032471472266402660807205675696110133573150125117412696328434523507708110949743705536889950671778501402435457354251761692098671783596194430798692942013503015764266392551048702428063161786512924608239609802040937400619384828550050291094616346317726139970219621
p=gcd(n1,n2)
q1=n1//p
q2=n2//p
phi1=(p-1)*(q1-1)
phi2=(p-1)*(q2-1)
d1=inverse(e,phi1)
d2=inverse(e,phi2)
print(long_to_bytes(pow(c1,d1,n1))+long_to_bytes(pow(c2,d2,n2)))

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;FSCTF{0hN0_Y0u_f1nd_th3_gcd!}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rsa签到&#34;&gt;RSA签到&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注意到：assert m.bit_length()&amp;lt;150  ，e=3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑直接开方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from Crypto.Util.number import *
c = 42336544435252811021843650684098817755849747192874682997240960601474927692351510022965782272751339319782351146077580929125
print(long_to_bytes(iroot(c,3)[0]))
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;flag{sign_1n_RSA}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;big_e&#34;&gt;Big_e&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简单的低解密指数攻击&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def rational_to_contfrac(x, y):
    # Converts a rational x/y fraction into a list of partial quotients [a0, ..., an]
    a = x // y
    pquotients = [a]
    while a * y != x:
        x, y = y, x - a * y
        a = x // y
        pquotients.append(a)
    return pquotients


def convergents_from_contfrac(frac):
    # computes the list of convergents using the list of partial quotients
    convs = [];
    for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0: i]))
    return convs


def contfrac_to_rational(frac):
    # Converts a finite continued fraction [a0, ..., an] to an x/y rational.
    if len(frac) == 0: return (0, 1)
    num = frac[-1]
    denom = 1
    for _ in range(-2, -len(frac) - 1, -1): num, denom = frac[_] * num + denom, num
    return (num, denom)
n = 12238605063252292170613110607692779326628090745751955692266649177882959231822580682548279800443278979485092243645806337103841086023159482786712759291169541633901936290854044069486201989034158882661270017305064348254800318759062921744741432214818915527537124001063995865927527037625277330117588414586505635959411443039463168463608235165929831344586283875119363703480280602514451713723663297066810128769907278246434745483846869482536367912810637275405943566734099622063142293421936734750356828712268385319217225803602442033960930413469179550331907541244416573641309943913383658451409219852933526106735587605884499707827

e= 11850552481503020257392808424743510851763548184936536180317707155841959788151862976445957810691568475609821000653594584717037528429828330763571556164988619635320288125983463358648887090031957900011546300841211712664477474767941406651977784177969001025954167441377912326806132232375497798238928464025466905201977180541053129691501120197010080001677260814313906843670652972019631997467352264392296894192998971542816081534808106792758008676039929763345402657578681818891775091140555977382868531202964486261123748663752490909455324860302967636149379567988941803701512680099398021640317868259975961261408500449965277690517
c=4218884541887711839568615416673923480889604461874475071333225389075770098726337046768413570546617180777109293884545400260353306419150066928226964662256930702466709992997796154415790565112167663547017839870351167884417142819504498662037048412313768450136617389372395690363188005647619061128497371121168347810294424378348301835826084732747005110258557662466626720961279087145559906371505117097599774430970980355531235913439823966628008554872896820907555353892843539526041019103819804854883231421963308265517622470779089941078841902464033685762524196275032288319744157255628189204988632871276637699312750636348750883054



def egcd(a, b):
    if a == 0: return (b, 0, 1)
    g, x, y = egcd(b % a, a)
    return (g, y - (b // a) * x, x)


def mod_inv(a, m):
    g, x, _ = egcd(a, m)
    return (x + m) % m


def isqrt(n):
    x = n
    y = (x + 1) // 2
    while y &amp;lt; x:
        x = y
        y = (x + n // x) // 2
    return x


def crack_rsa(e, n):
    frac = rational_to_contfrac(e, n)
    convergents = convergents_from_contfrac(frac)

    for (k, d) in convergents:
        if k != 0 and (e * d - 1) % k == 0:
            phi = (e * d - 1) // k
            s = n - phi + 1
            # check if x*x - s*x + n = 0 has integer roots
            D = s * s - 4 * n
            if D &amp;gt;= 0:
                sq = isqrt(D)
                if sq * sq == D and (s + sq) % 2 == 0: return d


d = crack_rsa(e, n)
m = hex(pow(c, d, n))[2:]
print(bytes.fromhex(m))
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;FSCTF{Y0u_ar3_s0_C001}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;babyhint&#34;&gt;babyhint&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过两个hint进行推理，再gcd得到p或q&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;得到关键kq = pow(2023,1919*9191,n)*pow(h2,1919,n) - pow(2022,1919*9191,n)*pow(h1,9191,n)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上脚本解密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import libnum
h1= 83535799515204730191288403119559179388147974968301357768644756769205396635068662150926873512812305514469213626273460486537390422570056287512841114712846420160416446291128064734960979586229744062965998582728378025151822479630618024804808407804317029367335421715125562402059266983021662398390585435529976586654
h2= 14402204438484882372730843813561914135941866642278909172674395293274736617425618184831446215507756031454895377588951726822765439585979555636320832177929472057402274116190878688601329765374509467243968967279090492272317903230101551317377700802837187081510381677262879617929177970455244249498674083943925477229
n= 94120719816617297967197808458007462810449143149204454740678593087096770130918870563878599847276923902207042790106345400843990455347835029220453217996810995363105274873857381469314548191574754245357568090646094043040797653858225598519876785530143007788084656262253002478643994943076851585839631209338814367691
c= 84244594789418833202484965138308516535996015903654462304986953156471594657993252593373963514364258027091543394305491354187806441313428473670956684437253991594327692679733432489342255718685303997647293213324463025120804679847465190496542879161344985402542539184706559207299026102682674060562738496314731555616
e=65537
kq = pow(2023,1919*9191,n)*pow(h2,1919,n) - pow(2022,1919*9191,n)*pow(h1,9191,n)
q = libnum.gcd(kq,n)
phi = (q-1)*(n//q - 1)
d = libnum.invmod(e,phi)
print(libnum.n2s(pow(c,d,n)))


&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;flag{ezsy_e3sy_ea4y_so_easy!!!}&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ezmath&#34;&gt;ezmath&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同样找到公因子是p的两个式子即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import libnum
from Crypto.Util.number import *
n=16099847254382387482323197733210572595987701766995679577427964142162383113660616883997429365200200943640950821711084123429306946305893862414506257284441114840863787499898478803568113348661314216300658606282276936902117099898776435948501831796770856505782683585268617613575681655903107683069260253287994894440427511440504754827820494060133773435262418256886443037510658584541624614692050308222516337333585823733360631982795323752298740497235142977602602205292595197618229629610834651923388269194546316023246525302500676142502931303976146680655368617094100097945625676103639154884247373003120937959132698199043562660573
c=7980021929208497878634194663038470941705554065040985666635317762877799614984808729636911256912639929083920319066806111423231500122646366713245534616522235309310234767331344216892929739448126523171652425415458999098138841038319673380331281114806318366697490343176758140150118761408250366783210772381316729932361601257318131085116265135718477224618689710966570938280408341402386000281564650565256635313406111364916715660419153433573586809503564050585204002594864254089288672391014804368427324162776953191520483774116807593366091685560902424782104761523067998300887293902330501335485075609216897135678017158187880996872
hint=14005608544369156893681352040163362072608754453657200460825561123439158535855236943525558717120672888372079069187756549797113560863313618058077150885401191613229507892570378437310964624470055767463556516869604496669085622244233154871165554916349033197798790982409986216498996673603605465039336316170130644317728786516639634775709400754328137266154981484016505702738584209800158047120647468364899692021253904198509376650238372552486792709682170146695759196408908825447960637667502907929061819408441663880712891979320089482801220225451560809151067631824526463122992973388740015878474372614751149918455457191739542980396

e = 65537
p = libnum.gcd(hint-pow(2023,n,n), n)
phi = (p-1)*(n//p -1)
d = libnum.invmod(e,phi)
print(libnum.n2s(pow(c,d,n)))

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;flag{ju3t_a_s1mpl3_ta3k}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ezrsa&#34;&gt;ezRSA&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构造方程求解就行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sympy import *
from Crypto.Util.number import *

n = 1901485114700245088118015176838411045645808657633721129158322425051110390237801115516544893309422501851747092251796770953642000579931231478667887589988786560834446696408732292786254192492281586457284980263740183
enc = 1199361436656854951826843585559905358018072076349745598865984504434921942249797269971584270541920348511243191511578321283455075109027873358983934024677982086699270397304699932717071144314481599892879445599516848

e = 31337

k = symbols(&#39;k&#39;)
p = k**6 + 7*k**4 - 40*k**3 + 12*k**2 - 114*k + 31377
q = k**5 - 8*k**4 + 19*k**3 - 313*k**2 - 14*k + 14011
ans = solve(p * q - n, k)
k = int(ans[0])
p = k**6 + 7*k**4 - 40*k**3 + 12*k**2 - 114*k + 31377
q = k**5 - 8*k**4 + 19*k**3 - 313*k**2 - 14*k + 14011
assert p * q == n

phi = (p - 1) * (q - 1)
d = inverse(e, phi)
m = pow(enc, d, n)
flag = long_to_bytes(m).decode()
print(flag)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注：这个脚本有点小慢，大家可以去用sage求解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;flag{y0u_kn0w_th3_P0lyn0mialRing_w1th_RSA!!!}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">FSCTF2023 WP  (Re&Crypto)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/2023-lan-mao-bei-ban-jue-sai-wpreandcryptoandmisc/"" data-c="
          &lt;p&gt;大二上的第二次线下比赛，远赴哈尔滨，最终得到21名（队里少一名队友捏），可惜差一名进决赛，但愿可以作为明年的铺垫吧。。。&lt;/p&gt;
&lt;h2 id=&#34;一reverse-justamat&#34;&gt;一.reverse-- justamat&lt;/h2&gt;
&lt;p&gt;直接看最后的比较函数，sub_4051A0&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  qmemcpy(v11, &amp;amp;unk_574020, sizeof(v11));
  qmemcpy(v12, &amp;amp;unk_5741C0, sizeof(v12));
  v3 = a1 + 10;
  while ( 2 )
  {
    v4 = v11;
    v5 = v2;
    do
    {
      v6 = v4;
      v7 = v1;
      LODWORD(v8) = 0;
      do
      {
        v9 = (unsigned int)(*(_DWORD *)v6 * *v7++);
        v6 += 40;
        v8 = (unsigned int)(v9 + v8);
      }
      while ( v7 != v3 );
      if ( *(_DWORD *)v5 != (_DWORD)v8 )
      {
        result = 0LL;
        goto LABEL_10;
      }
      v4 += 4;
      v5 += 4;
    }
    while ( v4 != &amp;amp;v11[40] );
    v2 += 40;
    v1 += 10;
    v3 = v7 + 10;
    if ( v2 != &amp;amp;v13 )
      continue;
    break;
  }
  result = 1LL;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两重循环，找到输入的数组以及最后的需要比较的数组，直接用z3解就可以&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import z3
last=[0x1C633, 0x1DF94, 0x20EBF, 0x2BA40, 0x1E884, 0x260D1, 0x1F9B1, 0x1EA1A, 0x1EEAA, 0x1DFB2, 0x1C1D0, 0x1EEF2, 0x216E1, 0x2BE00, 0x1FB5E, 0x25D74, 0x1F000, 0x202D6, 0x20002, 0x1DDFE, 0x1C017, 0x1F08C, 0x227F6, 0x2C7BA, 0x201AE, 0x27FBF, 0x20E21, 0x1FF5C, 0x1FD62, 0x1E948, 0x1BE6E, 0x1F4D7, 0x22C8D, 0x2C353, 0x1F8DB, 0x26E1D, 0x1FF61, 0x1EA0F, 0x1F0D6, 0x1EDA8, 0x1AD7D, 0x18218, 0x1CCD4, 0x239B6, 0x1AC4C, 0x20D7C, 0x1D967, 0x1A4F4, 0x1CAD8, 0x196AE, 0x1831B, 0x17E45, 0x1D0CF, 0x23EDF, 0x181AE, 0x21760, 0x1D3B4, 0x175D6, 0x17D3A, 0x1994F, 0x1189D, 0x14CCF, 0x1568E, 0x17EEB, 0x1327E, 0x16A45, 0x12921, 0x11FF0, 0x13643, 0x11729, 0x15191, 0x17D17, 0x17262, 0x1A863, 0x17010, 0x17B10, 0x14F9C, 0x143E8, 0x15E9B, 0x1242C, 0x0F68C, 0x1192A, 0x150AD, 0x1B1A0, 0x14C60, 0x182AB, 0x13F4B, 0x141A6, 0x15AA3, 0x135C9, 0x1D86F, 0x1E8FA, 0x2158D, 0x2BDAC, 0x20E4F, 0x27EE6, 0x213B9, 0x20E86, 0x211FF, 0x1E1EF]
v4=[0xFE, 0x0B, 0x1D, 0xF6, 0x83, 0xFF, 0xE0, 0xB8, 0xDD, 0xB0, 0xC5, 0xDE, 0xF6, 0x14, 0x9F, 0xDD, 0xD9, 0x07, 0x2D, 0x6B, 0x19, 0xCA, 0x73, 0xFD, 0x87, 0x72, 0x24, 0x04, 0x49, 0x7E, 0xA9, 0xCE, 0x91, 0xBE, 0x41, 0x18, 0x60, 0x3F, 0x2B, 0x63, 0x1C, 0xD2, 0x90, 0xE9, 0x8E, 0xBA, 0x1E, 0xF3, 0x41, 0xAD, 0x2C, 0x03, 0x69, 0xDA, 0x10, 0xFD, 0xFD, 0xE7, 0x06, 0x36, 0xD6, 0x02, 0x59, 0x18, 0xCC, 0x50, 0x87, 0xAF, 0xFB, 0x18, 0x44, 0x7F, 0xAD, 0xF8, 0x2C, 0x67, 0x1D, 0x22, 0x84, 0xAC, 0x0E, 0x23, 0xDC, 0xE6, 0xBB, 0xD2, 0xB8, 0x4A, 0xBC, 0xDE, 0x50, 0x9C, 0x1C, 0x1E, 0x86, 0x3A, 0x2D, 0xDD, 0xC3, 0x03]
s = z3.Solver()
a = [z3.Int(f&#39;a{i}&#39;) for i in range(len(last))]
for i in range(0, 10):
    for j in range(0, 10):
        s.add(((a[0 + j * 10] * v4[i + 0]) +(a[1 + j * 10] * v4[i + 10]) + (a[2 + j * 10] * v4[i + 20]) +(a[3 + j * 10] * v4[i + 30]) +(a[4 + j * 10] * v4[i + 40]) +(a[5 + j * 10] * v4[i + 50]) +(a[6 + j * 10] * v4[i + 60]) +(a[7 + j * 10] * v4[i + 70]) +(a[8 + j * 10] * v4[i + 80]) +(a[9 + j * 10] * v4[i + 90]) ) == last[i + j * 10])
if s.check() == z3.sat:
    m = s.model()
    for i in range(len(last)):
        print(chr(m[a[i]].as_long()), end=&#39;&#39;)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到there_are_a_lot_useless_information_but_oh.o0O_flag{8f9c6cf7-f362-4a4e-ace2-a34d90939589}_you_get_it&lt;/p&gt;
&lt;h2 id=&#34;二-crypto-ezrsa&#34;&gt;二. Crypto--ezrsa&lt;/h2&gt;
&lt;p&gt;注意到：两个相等的分数，首先将左边的分数通分，直接让左右两个分数的分子分母对应相等&lt;/p&gt;
&lt;p&gt;也就是说&lt;strong&gt;n+n+p+q+1==2*s-X&lt;/strong&gt;,以及&lt;strong&gt;n+q=s+Y&lt;/strong&gt;,就是一个方程组，我们直接让一式减去二式乘二，就可以得到&lt;strong&gt;p+1-q==-X-2*Y&lt;/strong&gt;,这时就可以得到p-q的值，我们知道p*q，那么p+q就容易知道了，从而可以得到phi，进而求解flag&lt;/p&gt;
&lt;p&gt;下面为脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x=153801856029563198525204130558738800846256680799373350925981555360388985602786501362501554433635610131437376183630577217917787342621398264625389914280509
y=8086061902465799210233863613232941060876437002894022994953293934963170056653232109405937694010696299303888742108631749969054117542816358078039478109426
n = 161010103536746712075112156042553283066813155993777943981946663919051986586388748662616958741697621238654724628406094469789970509959159343108847331259823125490271091357244742345403096394500947202321339572876147277506789731024810289354756781901338337411136794489136638411531539112369520980466458615878975406339
c = 15380535750650959213679345560658190067564859611922563753882617419201718847747207949211621591882732604480600745000879508274349808435529637573773711729853565120321608048340424321537282281161623712479117497156437792084977778826238039385697230676340978078264209760724043776058017336241110097549146883806481148999#
e=65537
print(-x-2*y-1)
sub=-169973979834494796945671857785204682968009554805161396915888143230315325716092965581313429821657002730045153667847840717855895577707030980781468870499362
phi = n - gmpy2.iroot(sub**2+4*n, 2)[0] + 1
d=inverse(e,phi)
print(long_to_bytes(pow(c,d,n)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到&lt;em&gt;&lt;strong&gt;flag{2a5a9c6fe94da5ef7edeffebb506b29a}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;三-misc-排队队吃果果&#34;&gt;三. misc--排队队吃果果&lt;/h2&gt;
&lt;p&gt;基本思路为列排序，再标黑找二维码（甚至不需要写脚本）&lt;/p&gt;
&lt;p&gt;首先将所有加粗的数字标黑，直接用ctrl+h特殊格式改就行，然后根据题目提示进行排序，当然在排序之前先把表格中的数据转换成数字格式，才能正常的升序排序，这里直接手动列排序即可，最终得到二维码，扫描出flag&lt;/p&gt;
">2023蓝帽杯半决赛 WP（Re&Crypto&Misc)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/nss2nd-ctf-crypto-wp/"" data-c="
          &lt;p&gt;很久之前的比赛，忘放到博客里了hh (AK)&lt;/p&gt;
&lt;h4 id=&#34;ezrsa&#34;&gt;EzRSA&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注意到m的bit长度是小于200的，e=3，所以m的e次方是小于n的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那么直接开立方即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;c = 5329266956476837379347536739209778690886367516092584944314921220156032648621405214333809779485753073093853063734538746101929825083615077

print(long_to_bytes(iroot(c,3)[0]))

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;NSSCTF{Rea1_Si9n3n}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;math&#34;&gt;math&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这题分为两部分解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一部分通过数论推导，得到&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;p*q=(p**-1)*p+(q**-1)*q-1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;之后用sympy库解方程即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二部分通过数论推导得到&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;p=gcd(hint-114514**n,n)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用工具求出p&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面为脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;n= 12775720506835890504634034278254395430943267336816473660983646973423280986156683988190224391394224069040565587173690009193979401332176772774003070053150665425296356891182224095151626957780349726980433545162004592720236315207871365869074491602494662741551613634958123374477023452496165047922053316939727488269523121920612595228860205356006298829652664878874947173274376497334009997867175453728857230796230189708744624237537460795795419731996104364946593492505600336294206922224497794285687308908233911851722675754289376914626682400586422368439122244417279745706732355332295177737063024381192630487607768783465981451061
c= 11915755246503584850391275332434803210208427722294114071001100308626307947436200730224125480063437044802693983505018296915205479746420176594816835977233647903359581826758195341201097246092133133080060014734506394659931221663322724002898147351352947871411658624516142945817233952310735792476179959957816923241946083918670905682025431311942375276709386415064702578261223172000098847340935816693603778431506315238612938066215726795441606532661443096921685386088202968978123769780506210313106183173960388498229061590976260661410212374609180449458118176113016257713595435899800372393071369403114116302366178240855961673903
hint= 3780943720055765163478806027243965253559007912583544143299490993337790800685861348603846579733509246734554644847248999634328337059584874553568080801619380770056010428956589779410205977076728450941189508972291059502282197067064652703679207594494311426932070873126291964667101759741689303119878339091991064473009603015444698156763131697516348762529243379294719509271792197450290763350043267150173332933064667716343268081089911389405010661267902446894363575630871542572200564687271311946580866369204751787686029541644463829030926902617740142434884740791338666415524172057644794094577876577760376741447161098006698524808
# p=gcd(hint-114514**n,n)
# print(p)
p=105455782136297301522101060102416289455521326237183609203266108650491902454001879515825304995889577954921548871398491249066999225070183739074683311311222633352056597215034013108495088419093171515311559870257496994471344117002696877757522247127846375242687873559988740474656421576669527924443831716929014383633
q=n//p
phi=(p-1)*(q-1)
e=65537
d=inverse(e,phi)
print(long_to_bytes(pow(c,d,n)))#19f-a1a6-959449b4df5a}
e= 65537
phi= 57503658815924732796927268512359220093654065782651166474086873213897562591669139461637657743218269483127368502067086834142943722633173824328770582751298229218384634668803018140064093913557812104300156596305487698041934061627496715082394633864043543838906900101637618600513874001567624343801197495058260716932
c= 25112054943247897935419483097872905208058812866572413543619256987820739973912338143408907736140292730221716259826494247791605665059462509978370784276523708331832947651238752021415405546380682507724076832547566130498713598421615793975775973104012856974241202142929158494480919115138145558312814378701754511483
pinv= 3020925936342826638134751865559091272992166887636010673949262570355319420768006254977586056820075450411872960532347149926398408063119965574618417289548987
qinv= 4671408431692232396906683283409818749720996872112784059065890300436550189441120696235427299344866325968178729053396743472242000658751114391777274910146291
import libnum
import sympy
p, q = sympy.symbols(&#39;p q&#39;)
expr1 = pinv * p + qinv * q - 1 - p*q
expr2 = (p-1)*(q-1) - phi
r = sympy.solve([expr1,expr2],[p, q],domain=sympy.S.Integers)
p = int(r[0][0])
q = int(r[0][1])
d = libnum.invmod(e, phi)
flag = pow(c,d,p*q)
print(libnum.n2s(int(flag)))

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;NSSCTF{e713afa4-fcd8-419f-a1a6-959449b4df5a}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;&#34;&gt;&lt;/h4&gt;
&lt;h4 id=&#34;latticelcg&#34;&gt;LatticeLCG&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代码分为两部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先通过第二部分求出n，再用共模攻击求出a，再通过LCG求出seed，最终就可以得到b&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;求n这里我们用到LLL算法，用sage解一下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;让es=e，cs=c，假设能找到ai，让ai*ei对i=1到n求和等于0，那么ci^ai进行连乘就等于m的ei乘ai次方，与1同余，所以要找到不同的a，即可通过gcd恢复n&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以构造一个格：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里其实是背包密码的延申&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当N符合要求后，目标向量的最后一个元素将会规约成0,前n个元素即是一个符合要求的a,找两个（以末元素是否为0来判断符合条件的a），让上面的连乘用x/y表示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后我们用gcd去求得n&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其实可以共模攻击继续求出第二部分的明文，但是这题不需要该明文，降低难度了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面直接给出整道题的脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from Crypto.Util.number import *
from gmpy2 import *
from itertools import *
es= [297332330847212015073434001239859795661, 247136911662054641479463124065475615181, 269964458627145370722389742095701827701, 270745917671094194052444327351021588037, 254010082507930275771798119457499420531, 219178601856077385518322602059961601013, 226562702503988968288128483964146379529, 236756812424464516919183114495913408541, 330800121752029915693039296018980956519, 244800084005240595691424199440981715431, 171753849214889522920105847094773384191, 175843874533972361422410968920873382741, 326554577162848075059517044795930784993, 181842368629269753698222635712342485771, 221634122983362091660188171985742369561, 314244561819808202322467576330355199409, 286703236198397527318161582654787197007, 298101543059628501506668748374542117409, 304158884506393754601331945634109778837, 227577031261920314010408499530794497453]
cs= [100163998802948218573427220530909801629443946118807841130458771881611961921044413091457977957530737347507311468578174294420439883266450142918647561103714976340598499984679873518770686239019753272419975426555435266764099822607336645955391865380657632176223122712125661464370522088500110746571354290680063421912, 123528268396018633078964378145622645321836134964966941909300627704018826667414656614011250938241127521627117348901416042868382174504514240509791471909819407751786633761392047187057200130450960708049681366686147337178110669163142189940397343388837018627392202704211693014162963133958078984558400205296509955066, 50364974727218716170137342348825758682286710377257708196467656986986475658591351848251278364177715325447140300281348027787487944839878770556527568407280736570303345044999352851718908253510696083227344179177110348363623815158409862985684687329665113210373028159714648637297476014803935686233984711925346269925, 9159042298258514259206302054907530984498816597282237786310355131965025367180505822032135021520906576471052417629425493533222088036674196397387325202128095476044308794426593565419139845832998557280786358482011226957053125314152322427131984411160984485669030286331376124575677908877399942011661647598763754231, 83466948172962290899792524342204996697711370224947233607865306692546824512672969402433314856742908546253967225963904395036102408684746619744412073888614033881366518452878344698289278946024167788789718690655953517892282374396760436658422838909903123439370164929347147855359470889455753772857233516742991766128, 72028057477369331020972407277180913909557985390590548305094935208898254733240351763155769013959589016793318772858662702447133499307826143247356049051993727167694036585280387890126287679890730586145740176250715386149857291210207281073772478229355625725300592003798974298248102432508449566953296818450441875311, 63397152736399466888877444377156185012692670493456346196278062009641363047685720620967313379507212944658351683022480839941265221126018392433078546696140135677499181555082643172378488800458657825640013090182171355299282023794908520172571785687147143015581400891531296496177973817400317905868361800342940667657, 45427004823510815929685208038284324980662968275105063862891077759131069014314933978878667052450145039482242546093735499108826130367476890384431317243013990394189191560941678120985717370542332803012619694821129395559214706968432476548145608291516176910849698455496733056096163035964057523545705356926187216133, 85046100612081858546755294340770681541320509587396377967875404950325314121709046137842413744740490231945105758075761946555179595664901813127463402854440384657046429776033129391138370272524736543471909307910018577738207910417672603889922445435939876023878220177983424547612635006926243055642166274730894301704, 5833380233103086014860892228744764647016585478949686583145531659689295506666493518453642500086277427538189091865461553097914845680665917702500908205558454036911757659426809969367680394533585635383007758339917554453268182491874683638880986360065633842854622244953985055815937671635222264056071882344388307409, 83587615309194701727032548415548847571046191382552371312058083137102227325098839286526833147951063338204327145093831238962818333112251936853329663907079943414231588222256242520221314528944937229985997926851198158564313703719031124442094987245466116488897263358510493905440842917634723859176839440753120904481, 108651960334634726889543063749359050688114025706494125848785084643330096858725917513596985853593252388835207675036982640195609499739937405655156895161071906340785173459426867946058638393154997931747445494284445204735492709747637173698383609764016673932827648159152658645291248613736662020472251048171789274368, 118612010487916657134965416492319303083994743753602531817008130269546146141506819718265549648441671373744766173780682168587021797626910931105508317440664521595783406848956221465897709761805869130021172013000282497881581247777388315282629463546261696169893882772397797722134711444928443061384985458691749569847, 106808406616890955924408992591724627593882118490933791849624747503316110669154243209826761617940864170830792705070618439466645580274835929100331418955890808763286193770831205511071440703609240364726061677822134370309018443508205980554831705850988319397384130044484586798585896460152167042282847992593429629533, 88091869606421350393441194783722851111189272445506506936925797213395319937783082680078622732926273935980894566775394134783157488360516905477700601820480975112122167589887641130656305741351643175495552454293030309247254533571254198691204714097846510872592569447050033289483493274672346210063885124570695832880, 94400859500860667431780782962782396345261822402898708716634581228428633704975879685572548692997007974004673676539496590659276952154740096463133011458100387006276325192223993452314873089466451613079029429327880672384210802191677586975844471189127835578979108767548290181668434770385199468588493042256788539610, 76177813724283720012398394789596589415486093955132688784865364048503447246391866424200071522136707581280434193680972230914105236504028522288780213089260160776489804587209115330412067560802680789338779056583047491942817016437672075192528508677997165703606520158178725128251694801612417667440677124932361973397, 17188209523466762369281362386525396145127294763502094183797065621821932913685690176344514910405677170931795652509426794846131051983826422536084073462084935517166603832542862106287058675490933197600813710203114108790043880150305327523679949543592622443904084453387396870899883324751789625806819506542619123964, 120007173989070249117019147454557020213723707722383599019972471016186584968096445904023372671513462965078400715365736756710078805039115601609874780421117795585342458478316236202328120583456334489780231976628584606042971207759763658961365139429661536955996519512283283500790612975034779837647053750631763512799, 18797057418663411295612229938999282286746920748194349166509084258061650142260043277698907538088835210620841171754186980908772147495732980563542600139935202965632319542217264685208215907551992891370166006725534397313373079841419662622936316343820775075897977228084528246337988431658221881343556854053475137330]

L = Matrix(QQ,len(es),len(es) + 1)
for i in range(len(es)):
    L[i,len(es)] = es[i]
    L[i,i] = 1
L[:, len(es)] *= 2 ^ 11 # N的最小值2^11
L = L.LLL()
print(L)

xx = product([ZZ(y) ^ x for x, y in zip(L[0][:-1], cs)]) # 列表中所有元素乘积
yy = product([ZZ(y) ^ x for x, y in zip(L[1][:-1], cs)])
n = gcd(xx.numer() - xx.denom(), yy.numer() - yy.denom()) # 获取xx,yy的分子分母
print(n)
s,s1,s2 = xgcd(es[0], es[1])
m = pow(cs[0], s1, n) * pow(cs[1], s2, n) % n

print(long_to_bytes(int(m)))

n=144195616225517130139553879032789087363345719184209965153957734484017481087563259298073412179385691339856835367038233652960921043438130441546622467854561746540234185779818652424614702625694747523202592051400384839225423182264627929190443610610683526608116658120285614198376504623869469278859145863411493155577
c1 =  132894829064255831243210470637067717685821770359549730768366345840525257033166172926149293454192143005551270166547902269036843756318967855047301751521125394803373953151753927497701242767032542708689455184991906629946511295108898559666019232955132938245031352553261823905498810285940911315433144300083027795647
c2 =  24086830909813702968855830967174364278115647345064163689290457852025690324300607354444884288995399344650789235347773145941872226843099538451759854505842021844881825309790171852845467221751852440178862638893185965125776165397575087879479327323737686652198357863042305078811580074617322063509435591981140533310
output1 =  54997286032365904331111467760366122947903752273328087460831713533712307510311367648330090376100815622160705007873798883153287827481112070182047111994066594911019010222064952859306742931009422376955635523160546531204043294436812066746785938062292942759004837173423765427628610568097898331237064396308950601636
output2 =  115015764780168428067411132384122324817310808727138440691727747976276050930701648349452842302609389394467134068064132550313721128807222231505312226682756817617177620169804112319332815872107656884931985435898097063491690413460967856530075292289784649593915313885813931026280791070577034075346669028068003251024
import libnum
import gmpy2

e1 = 2333
e2 = 23333
def exp_def(e1,e2,c1,c2,n):
    s,s1,s2 = gmpy2.gcdext(e1, e2)
    m = (pow(c1,s1,n) * pow(c2 ,s2 ,n)) % n
    return int(m)

m=exp_def(e1,e2,c1,c2,n)
#print(m)
a=6916067937269950974206746204164509896240838110131015886297814490101615527867219160040558623231859474391279572961225727366045095864405799615600246029206211
x1=output2-output1
x2=a*output1
#print(x1//a)
print(x2-x1)
y=380364966565310346139573705275593171203674160992096711250221695526401248521852913594363815176817043289588051955466214462719028670096210487634414273255971211508621518183501598483571526743311665155469924046333690113016300934259482472804982474730586918781189345531156942525990739409605346972255479155344018382592549832030836602814570541002258843050592542321772891175248031995675501106284172505939635218555310755333395621347065633090782603850619202551803156905311808
b=output1-y
print(b)
print(b%n)
mm=2806865643354785580439949064910175259057528627315932887769100372449333004880846521832438221661926953727869
print(long_to_bytes(mm))
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;得到&lt;em&gt;&lt;strong&gt;NSSCTF{407f8832-6ffd-43bf-91a0-6900758cdff7}&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;funnyencrypt&#34;&gt;FunnyEncrypt&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;直接将txt文本中的内容替换掉就行&lt;/li&gt;
&lt;/ul&gt;
">NSS2nd CTF  Crypto WP</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/xiang-shan-bei-2023-chu-sai-re-wp/"" data-c="
          &lt;h1 id=&#34;香山杯2023初赛&#34;&gt;香山杯2023初赛&lt;/h1&gt;
&lt;h2 id=&#34;一-re&#34;&gt;一. RE&lt;/h2&gt;
&lt;h3 id=&#34;1url从哪儿来&#34;&gt;1.URL从哪儿来&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;看main函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __cdecl main(int argc, const char **argv, const char **envp)
{
  HMODULE ModuleHandleW; // eax
  HMODULE v4; // eax
  HMODULE v5; // eax
  _BYTE *v7; // [esp+4h] [ebp-28Ch]
  HGLOBAL hResData; // [esp+8h] [ebp-288h]
  HRSRC hResInfo; // [esp+Ch] [ebp-284h]
  _BYTE *lpAddress; // [esp+10h] [ebp-280h]
  FILE *Stream; // [esp+1Ch] [ebp-274h]
  DWORD dwSize; // [esp+20h] [ebp-270h]
  DWORD i; // [esp+28h] [ebp-268h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+30h] [ebp-260h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+40h] [ebp-250h] BYREF
  CHAR Buffer[260]; // [esp+84h] [ebp-20Ch] BYREF
  CHAR TempFileName[260]; // [esp+188h] [ebp-108h] BYREF

  ModuleHandleW = GetModuleHandleW(0);
  hResInfo = FindResourceW(ModuleHandleW, (LPCWSTR)0x65, L&amp;quot;e_ou&amp;quot;);
  v4 = GetModuleHandleW(0);
  hResData = LoadResource(v4, hResInfo);
  v7 = LockResource(hResData);
  v5 = GetModuleHandleW(0);
  dwSize = SizeofResource(v5, hResInfo);
  lpAddress = VirtualAlloc(0, dwSize, 0x1000u, 4u);
  if ( !lpAddress )
    return 1;
  for ( i = 0; i &amp;lt; dwSize; ++i )
  {
    if ( v7[i] &amp;amp;&amp;amp; v7[i] != 120 )
      lpAddress[i] = v7[i] ^ 0x78;
    else
      lpAddress[i] = v7[i];
  }
  if ( !GetTempPathA(0x104u, Buffer) )
    return 1;
  if ( !GetTempFileNameA(Buffer, &amp;quot;ou.exe&amp;quot;, 0, TempFileName) )
    return 1;
  Stream = fopen(TempFileName, &amp;quot;wb&amp;quot;);
  if ( !Stream )
    return 1;
  if ( fwrite(lpAddress, 1u, dwSize, Stream) == dwSize )
  {
    fclose(Stream);
    VirtualFree(lpAddress, 0, 0x8000u);
    memset(&amp;amp;StartupInfo, 0, sizeof(StartupInfo));
    memset(&amp;amp;ProcessInformation, 0, sizeof(ProcessInformation));
    StartupInfo.cb = 68;
    GetStartupInfoA(&amp;amp;StartupInfo);
    StartupInfo.wShowWindow = 0;
    CreateProcessA(TempFileName, 0, 0, 0, 1, 0, 0, 0, &amp;amp;StartupInfo, &amp;amp;ProcessInformation);
    CloseHandle(ProcessInformation.hProcess);
    CloseHandle(ProcessInformation.hThread);
    DeleteFileA(TempFileName);
    return 0;
  }
  else
  {
    fclose(Stream);
    return 1;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一种方法（最简单的）：直接动调，在CreateProcessA函数处下断点即可，导出ou.26B6.tmp文件，查壳，拖入IDA分析，逻辑很简单，-30后base64就行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种方法：将原来的exe拖入resource hack里导出bin文件，再写脚本进行异或，输出bin文件，再IDA分析即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面是bin文件输出方法：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;arr = 0x78
with open(&#39;C:\\Users\\lenovo\\Desktop\\E_OU101.bin&#39;, &#39;rb&#39;) as f:
    b = f.read()
b = bytearray(b)
for i in range(len(b)):
    if b[i]!=0 &amp;amp; b[i]!=120:
        b[i] = b[i] ^ arr
    else:
        b[i]=b[i]
with open(&#39;C:\\Users\\lenovo\\Desktop\\COD_de1&#39;, &#39;wb&#39;) as f:
    f.write(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脚本简单不在此赘述&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2hello_py&#34;&gt;2.hello_py&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;该题运用chaquopy来调用python代码，根据题目提示我们找到python源码，在app.imy里找到hello.py，代码如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from java import jboolean ,jclass #line:1
import struct #line:3
import ctypes #line:4
def MX (O0O00OOO00OO00O00 ,O0OO0O00OO0O000OO ,OO000OO000000O0O0 ,OOO00O00OOO000OOO ,OO0OOO0OOO0OOOO0O ,O0OO000O0000O000O ):#line:7
    OOO000O0O0OO00000 =(O0O00OOO00OO00O00 .value &amp;gt;&amp;gt;5 ^O0OO0O00OO0O000OO .value &amp;lt;&amp;lt;2 )+(O0OO0O00OO0O000OO .value &amp;gt;&amp;gt;3 ^O0O00OOO00OO00O00 .value &amp;lt;&amp;lt;4 )#line:8
    OOO0OOOOOO0O0OO00 =(OO000OO000000O0O0 .value ^O0OO0O00OO0O000OO .value )+(OOO00O00OOO000OOO [(OO0OOO0OOO0OOOO0O &amp;amp;3 )^O0OO000O0000O000O .value ]^O0O00OOO00OO00O00 .value )#line:9
    return ctypes .c_uint32 (OOO000O0O0OO00000 ^OOO0OOOOOO0O0OO00 )#line:11
def encrypt (OO0OO0O0O0O0O0OO0 ,OOO0O0OO0O0OOO000 ,OO0OOOO0OO0OOO0O0 ):#line:14
    O0OOO0OO00O0000OO =0x9e3779b9 #line:15
    OOOO0OOOO00O0OOOO =6 +52 //OO0OO0O0O0O0O0OO0 #line:16
    O00OO00000O0OO00O =ctypes .c_uint32 (0 )#line:18
    OO0OOOO0O0O0O0OO0 =ctypes .c_uint32 (OOO0O0OO0O0OOO000 [OO0OO0O0O0O0O0OO0 -1 ])#line:19
    OOOOO00000OOOOOOO =ctypes .c_uint32 (0 )#line:20
    while OOOO0OOOO00O0OOOO &amp;gt;0 :#line:22
        O00OO00000O0OO00O .value +=O0OOO0OO00O0000OO #line:23
        OOOOO00000OOOOOOO .value =(O00OO00000O0OO00O .value &amp;gt;&amp;gt;2 )&amp;amp;3 #line:24
        for OO0O0OOO000O0000O in range (OO0OO0O0O0O0O0OO0 -1 ):#line:25
            OOO0OO00O0OO0O000 =ctypes .c_uint32 (OOO0O0OO0O0OOO000 [OO0O0OOO000O0000O +1 ])#line:26
            OOO0O0OO0O0OOO000 [OO0O0OOO000O0000O ]=ctypes .c_uint32 (OOO0O0OO0O0OOO000 [OO0O0OOO000O0000O ]+MX (OO0OOOO0O0O0O0OO0 ,OOO0OO00O0OO0O000 ,O00OO00000O0OO00O ,OO0OOOO0OO0OOO0O0 ,OO0O0OOO000O0000O ,OOOOO00000OOOOOOO ).value ).value #line:27
            OO0OOOO0O0O0O0OO0 .value =OOO0O0OO0O0OOO000 [OO0O0OOO000O0000O ]#line:28
        OOO0OO00O0OO0O000 =ctypes .c_uint32 (OOO0O0OO0O0OOO000 [0 ])#line:29
        OOO0O0OO0O0OOO000 [OO0OO0O0O0O0O0OO0 -1 ]=ctypes .c_uint32 (OOO0O0OO0O0OOO000 [OO0OO0O0O0O0O0OO0 -1 ]+MX (OO0OOOO0O0O0O0OO0 ,OOO0OO00O0OO0O000 ,O00OO00000O0OO00O ,OO0OOOO0OO0OOO0O0 ,OO0OO0O0O0O0O0OO0 -1 ,OOOOO00000OOOOOOO ).value ).value #line:30
        OO0OOOO0O0O0O0OO0 .value =OOO0O0OO0O0OOO000 [OO0OO0O0O0O0O0OO0 -1 ]#line:31
        OOOO0OOOO00O0OOOO -=1 #line:32
    return OOO0O0OO0O0OOO000 #line:34

def check (O0000000000O0O0O0 ):#line:63
    print (&amp;quot;checking~~~: &amp;quot;+O0000000000O0O0O0 )#line:64
    O0000000000O0O0O0 =str (O0000000000O0O0O0 )#line:65
    if len (O0000000000O0O0O0 )!=36 :#line:66
        return jboolean (False )#line:67
    O00OO00000OO0OOOO =[]#line:69
    for O0O0OOOOO0OOO0OOO in range (0 ,36 ,4 ):#line:70
        OO0OO0OOO000OO0O0 =O0000000000O0O0O0 [O0O0OOOOO0OOO0OOO :O0O0OOOOO0OOO0OOO +4 ].encode (&#39;latin-1&#39;)#line:71
        O00OO00000OO0OOOO .append (OO0OO0OOO000OO0O0 )#line:72
    _O00OO0OOOOO00O00O =[]#line:73
    for O0O0OOOOO0OOO0OOO in O00OO00000OO0OOOO :#line:74
        _O00OO0OOOOO00O00O .append (struct .unpack (&amp;quot;&amp;lt;I&amp;quot;,O0O0OOOOO0OOO0OOO )[0 ])#line:75
    print (_O00OO0OOOOO00O00O )#line:77
    OO0OO0OOO000OO0O0 =encrypt (9 ,_O00OO0OOOOO00O00O ,[12345678 ,12398712 ,91283904 ,12378192 ])#line:78
    OOOOO0OOO0OO00000 =[689085350 ,626885696 ,1894439255 ,1204672445 ,1869189675 ,475967424 ,1932042439 ,1280104741 ,2808893494 ]#line:85
    for O0O0OOOOO0OOO0OOO in range (9 ):#line:86
        if OOOOO0OOO0OO00000 [O0O0OOOOO0OOO0OOO ]!=OO0OO0OOO000OO0O0 [O0O0OOOOO0OOO0OOO ]:#line:87
            return jboolean (False )#line:88
    return jboolean (True )#line:90
def sayHello ():#line:92
    print (&amp;quot;hello from py&amp;quot;)#line:93

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然混淆了，但是可以看出来是XXTea加密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后面直接套脚本解密即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import ctypes  
def MX(z, y, total, tea_key, p, e):  
    temp1 = (z .value &amp;gt;&amp;gt; 5 ^ y .value &amp;lt;&amp;lt; 2)+(y .value &amp;gt;&amp;gt; 3 ^ z .value &amp;lt;&amp;lt; 4)   
    temp2 = (total .value ^ y .value)+(tea_key[(p &amp;amp; 3) ^ e .value] ^ z .value)  
    return ctypes.c_uint32(temp1 ^ temp2)  

def decrypt(n, v, key):
    delta = 0x9e3779b9
    rounds = 6 + 52//n 
    
    total = ctypes.c_uint32(rounds * delta)
    y = ctypes.c_uint32(v[0])
    e = ctypes.c_uint32(0)

    while rounds &amp;gt; 0:
        e.value = (total.value &amp;gt;&amp;gt; 2) &amp;amp; 3
        for p in range(n-1, 0, -1):
            z = ctypes.c_uint32(v[p-1])
            v[p] = ctypes.c_uint32((v[p] - MX(z,y,total,key,p,e).value)).value
            y.value = v[p]
        z = ctypes.c_uint32(v[n-1])  
        v[0] = ctypes.c_uint32(v[0] - MX(z,y,total,key,0,e).value).value
        y.value = v[0]  
        total.value -= delta
        rounds -= 1

    return v 

key_str = [689085350, 626885696, 1894439255, 1204672445, 1869189675, 475967424, 1932042439, 1280104741, 2808893494]
res = encrypt_input = decrypt(9, key_str, [12345678, 12398712, 91283904, 12378192])
for i in res:
    print(hex(i)[2:])
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手动恢复大端序，然后16进制转字符串即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;flag{c1f8ace6-4b46-4931-b25b-a1010a89c592}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-nesting&#34;&gt;3. nesting&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;竟然是一道vm题，与最近的研究方向撞上了哈哈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双重vm，大致有两种方法：手搓+脚本还原或是用intel pin进行爆破&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先介绍第一种方法：intel pin爆破&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到程序的输入点，再找到程序的cmp点，有两个case：0x1E21,0x1EC9,通过输入fl，fi等不同字符串发现，两处执行次数不同，用pin去统计执行次数，这样我们可以逐字节爆破。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先在 source/tools/ManualExamples 路径下 make obj-intel64/inscount0.so TARGET=intel64，编译生成计数器的so文件（即为一种pintool），可以记录程序执行的指令的条数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注：想知道pintool功能可以：$ pin -t your_pintool -h -- your_application&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同样的，编译32位pintool使用：make obj-ia32/inscount0.so&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用 make all TAEGET=intel64 make all TAEGET=ia32 来编译所有的pintool&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译完以后生成输出文件  ../../../pin -t obj-intel64/inscount0.so -o inscount0.log -- 文件路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这时可以再去写脚本进行爆破，另外的，在编译pintool之前可以把.c源码文件中的一些源码改掉以适应情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于此题：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先我们只想统计指定行代码的执行次数，所以将inscount0.c中：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;VOID docount() { icount++; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改为：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;VOID docount(void *ip) 
{
	if ((long long int)ip == 0x0000555555555E21)
	 icount++; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并将&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改为&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_INST_PTR, IARG_END);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入IARG_INST_PTR参数，是为了检测指令的地址，传入ip&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;sudo su
echo 0 &amp;gt; /proc/sys/kernel/randomize_va_space
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将ALSR保护关掉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改完后在将inscount0进行64位编译，生成输出文件，之后编写脚本如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pwn import *
import subprocess
def run(msg):
    cmd = [
    &amp;quot;/home/tanggerr/Downloads/pin-3.28-98749-g6643ecee5-gcc-linux/pin&amp;quot;,
    &amp;quot;-t&amp;quot;, &amp;quot;/home/tanggerr/Downloads/pin-3.28-98749-g6643ecee5-gcc-linux/source/tools/ManualExamples/obj-intel64/inscount0.so&amp;quot;,
    &amp;quot;-o&amp;quot;, &amp;quot;/home/tanggerr/Downloads/pin-3.28-98749-g6643ecee5-gcc-linux/source/tools/ManualExamples/inscount0.log&amp;quot;,
    &amp;quot;--&amp;quot;,
    &amp;quot;/home/tanggerr/nesting&amp;quot;
]
    # 启动进程，并设置 stdin, stdout, stderr 为 PIPE，以便与进程交互
    p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    # 发送数据到进程
    p.stdin.write(msg.encode())
    p.stdin.flush()
    # 从进程接收数据
    output = p.stdout.readline()
    # print(output)
    # 结束进程
    p.terminate()
    return int(read(&amp;quot;/home/tanggerr/Downloads/pin-3.28-98749-g6643ecee5-gcc-linux/source/tools/ManualExamples/inscount0.log&amp;quot;).split(&amp;quot; &amp;quot;)[1])


def read(fname):
    with open(fname) as f:
        return f.read()
# print(run(&amp;quot;fl&amp;quot;))


charset = string.printable

l = []
flag = &amp;quot;&amp;quot;
counter = 0

while(True):
    max_chr = 0
    first_iteration = True  # 初始化标志为 True
    for chr in charset:
        tmp = run(flag + chr)
        if first_iteration:  # 只在第一次迭代时执行
            max_value = tmp
            first_iteration = False  # 设置标志为 False
        if tmp &amp;gt; max_value:
            max_chr = chr
            max_value = tmp
            break
    print(max_chr)
    flag += str(max_chr)
    print(flag)
    #flag{2c7c093b-f648-11ed-a716-701ab8caaafe}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待其爆破出&lt;em&gt;&lt;strong&gt;flag{2c7c093b-f648-11ed-a716-701ab8caaafe}&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接着看第二种方法：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手搓两层vm，这里我学习了LaoGong战队的解法，请见&lt;a href=&#34;https://ycznkvrmzo.feishu.cn/docx/DIdAdrKA3olqigxPgv0cbM4OnYg&#34;&gt;‌⁢﻿‬⁡⁣⁤﻿﻿﻿⁣‬⁡‍﻿‌‌⁡⁡⁣‬‍⁤⁢‬⁢⁢⁤‬﻿⁣‍‍‌⁡‍‬2023 10.15 香山杯 wp - LaoGong - 飞书云文档 (feishu.cn)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只能说手搓是真的nb（tql，orz&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">香山杯2023初赛 re WP</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/2023dasctf-liu-yue-tiao-zhan-sai-er-jin-zhi-zhuan-xiang-reverse/"" data-c="
          &lt;h2 id=&#34;一-careful&#34;&gt;一. careful&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;动态调试 设置断点在 ds:gethostbyname 处&lt;/li&gt;
&lt;li&gt;进入gethostbyname 内部其实存在了内联HOOK  hook了这个API函数 修改了传入的参数 然后调用真正的API&lt;/li&gt;
&lt;li&gt;需要更进一步步入进入该内联函数分析&lt;/li&gt;
&lt;li&gt;最后看参数即可得到flag&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-babyre&#34;&gt;二. babyre&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先找到关键字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交叉引用到7A80处&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;__int64 __fastcall sub_140007A80(int a1, __int64 a2)
{
  char *v2; // rdi
  __int64 i; // rcx
  char v5[32]; // [rsp+0h] [rbp-40h] BYREF
  char v6; // [rsp+40h] [rbp+0h] BYREF
  DWORD dwProcessId; // [rsp+44h] [rbp+4h]
  HANDLE v8; // [rsp+68h] [rbp+28h]
  char Parameter[132]; // [rsp+90h] [rbp+50h] BYREF
  int j; // [rsp+114h] [rbp+D4h]
  HRSRC hResInfo; // [rsp+138h] [rbp+F8h]
  size_t Size; // [rsp+154h] [rbp+114h]
  HGLOBAL hResData; // [rsp+178h] [rbp+138h]
  void *Src; // [rsp+198h] [rbp+158h]
  void *v15; // [rsp+1B8h] [rbp+178h]
  __int64 v16; // [rsp+1D8h] [rbp+198h]
  __int64 v17; // [rsp+1F8h] [rbp+1B8h]
  int k; // [rsp+214h] [rbp+1D4h]
  __int64 v19; // [rsp+2E8h] [rbp+2A8h]

  v2 = &amp;amp;v6;
  for ( i = 130i64; i; --i )
  {
    *(_DWORD *)v2 = -858993460;
    v2 += 4;
  }
  sub_1400012A8(&amp;amp;unk_1400140F4);
  dwProcessId = GetCurrentProcessId();
  v8 = OpenProcess(0x1FFFFFu, 0, dwProcessId);
  if ( a1 != 2 )
    exit(0);
  for ( j = 0; ; ++j )
  {
    v19 = j;
    if ( j &amp;gt;= strlen(*(const char **)(a2 + 8)) )
      break;
    Parameter[j] = *(_BYTE *)(*(_QWORD *)(a2 + 8) + j);
  }
  hResInfo = FindResourceW(0i64, (LPCWSTR)0x65, L&amp;quot;cod&amp;quot;);
  LODWORD(Size) = SizeofResource(0i64, hResInfo);
  hResData = LoadResource(0i64, hResInfo);
  Src = LockResource(hResData);
  v15 = malloc((unsigned int)Size);
  memcpy(v15, Src, (unsigned int)Size);
  sub_140001087(v15);//decrypt shellcode
  v16 = qword_14000FC30(v8, 0i64, 874i64, 4096i64, 64);//VirtualAllocEx
  qword_14000FC28(v8, v16, v15, 874i64, 0i64);//WriteProcessMemory
  v17 = qword_14000FC18(v8, 0i64, 0i64, v16, Parameter, 0, 0i64);//CreateRemoteThread
  Sleep(0x1F4u);
  for ( k = 0; k &amp;lt; 44; ++k )
    ;
  CreateThread(0i64, 0i64, StartAddress, Parameter, 0, 0i64);//子进程：checkflag
  Sleep(0x190u);
  sub_140001253(v5, &amp;amp;unk_14000BEE0);
  return 0i64;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cod二进制资源，在2940中会进行解密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于cod：&lt;strong&gt;通过对资源进行解密 并且Write到自身的内存中去 然后通过远程线程执行&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中会用到反调试在28F0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接静态即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将cod提取至resource hack&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成.bin文件后解密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解密脚本如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;arr = [0x18, 0x57, 0x68, 0x64]
with open(&#39;C:\\Users\\lenovo\\Desktop\\COD101&#39;, &#39;rb&#39;) as f:
    b = f.read()
b = bytearray(b)
for i in range(len(b)):
    b[i] = b[i] ^ arr[i % 4]
with open(&#39;C:\\Users\\lenovo\\Desktop\\COD_de&#39;, &#39;wb&#39;) as f:
    f.write(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将解密后的bin文件用ida分析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按c键将二进制数据转换成汇编代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面开始去花&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中注意loc_1EE，&lt;img src=&#34;C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230802005440118.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接nop掉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这时就能生成伪代码了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall sub_0(_BYTE *a1)
{
  void *v1; // rax
  __int64 result; // rax
  char v3[292]; // [rsp+40h] [rbp+10h]
  unsigned int j; // [rsp+164h] [rbp+134h]
  unsigned int v5; // [rsp+184h] [rbp+154h]
  unsigned int v6; // [rsp+1A4h] [rbp+174h]
  int v7; // [rsp+1C4h] [rbp+194h]
  char v8[44]; // [rsp+1E8h] [rbp+1B8h] BYREF
  unsigned int v9; // [rsp+214h] [rbp+1E4h]
  _BYTE *i; // [rsp+238h] [rbp+208h]
  int v11; // [rsp+254h] [rbp+224h]
  __int64 v12; // [rsp+3E8h] [rbp+3B8h]

  memset(v1, 0, 0x101ui64);
  qmemcpy(v8, &amp;quot;]Bb)&amp;quot;, 4);
  v8[4] = 3;
  v8[5] = 54;
  v8[6] = 71;
  v8[7] = 65;
  v8[8] = 21;
  v8[9] = 54;
  v9 = 0;
  for ( i = a1; *i; ++i )
    ++v9;
  for ( j = 0; j &amp;lt; 256; ++j )
    v3[j] = j;
  v6 = 0;
  v5 = 0;
  for ( j = 0; j &amp;lt; 256; ++j )
  {
    v7 = v3[j];
    v5 = (v8[v6] + v7 + 2 * v5) % 0x100;
    v3[j] = v3[v5];
    v3[v5] = v7;
    if ( ++v6 &amp;gt;= 0xA )
      v6 = 0;
  }
  v6 = 0;
  v5 = 0;
  for ( j = 0; ; ++j )
  {
    result = v9;
    if ( j &amp;gt;= v9 )
      break;
    v5 = (v6 + v5) % 0x100;
    v6 = (v3[v5] + v6) % 0x100;
    v7 = v3[v5];
    v3[v5] = v3[v6];
    v3[v6] = v7;
    v11 = v3[(v3[v5] + v6 + v3[v6]) % 0x100];
    a1[j] ^= v11;
    v12 = j;
    a1[j] += j % 0xD;
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;很明显的魔改RC4代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里我们找到起始key就是v8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同时flag的检验在程序的另一个子进程中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;checkflag伪代码如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void __fastcall __noreturn StartAddress_0(__int64 a1)
{
  char *v1; // rdi
  __int64 i; // rcx
  char v3; // [rsp+20h] [rbp+0h] BYREF
  char v4[76]; // [rsp+28h] [rbp+8h]
  int j; // [rsp+74h] [rbp+54h]

  v1 = &amp;amp;v3;
  for ( i = 30i64; i; --i )
  {
    *(_DWORD *)v1 = -858993460;
    v1 += 4;
  }
  sub_1400012A8((__int64)&amp;amp;unk_1400140F4);
  v4[0] = 0xF7;
  v4[1] = 46;
  v4[2] = 52;
  v4[3] = -16;
  v4[4] = 114;
  v4[5] = -49;
  v4[6] = 94;
  v4[7] = 10;
  v4[8] = -69;
  v4[9] = -20;
  v4[10] = -79;
  v4[11] = 43;
  v4[12] = 112;
  v4[13] = -120;
  v4[14] = -120;
  v4[15] = -19;
  v4[16] = 70;
  v4[17] = 56;
  v4[18] = -37;
  v4[19] = -38;
  v4[20] = 108;
  v4[21] = -67;
  v4[22] = -44;
  v4[23] = 6;
  v4[24] = 119;
  v4[25] = -14;
  v4[26] = -49;
  v4[27] = 86;
  v4[28] = -120;
  v4[29] = -58;
  v4[30] = 49;
  v4[31] = -46;
  v4[32] = -73;
  v4[33] = 90;
  v4[34] = -63;
  v4[35] = 66;
  v4[36] = -80;
  v4[37] = -12;
  v4[38] = 72;
  v4[39] = 55;
  v4[40] = -11;
  v4[41] = 44;
  v4[42] = -11;
  v4[43] = 88;
  puts(&amp;quot; &amp;quot;);
  for ( j = 0; j &amp;lt; 44; ++j )
  {
    if ( *(char *)(a1 + j) != v4[j] )
    {
      sub_14000114A(&amp;quot;error!\n&amp;quot;);
      exit(0);
    }
  }
  sub_14000114A(&amp;quot;get flag!&amp;quot;);
  exit(0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;exp如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class RC4:
    def __init__(self, key) -&amp;gt; None:
        self.key = key
        self.S = 0

        self.__rc4_init__()

    def __rc4_init__(self):
        S = [i for i in range(256)]
        j = 0
        for i in range(256):
            j = (2 * j + S[i] + key[i % len(key)]) % 256
            S[i], S[j] = S[j], S[i]
        self.S = S

    def rc4_encrypt(self, plain) -&amp;gt; list:
        i = 0
        j = 0
        cipher = []
        cnt = 0
        for p in plain:
            p = (p + 256 - cnt % 0xd) % 256
            cnt += 1
            i = (i + j) % 256
            j = (j + self.S[i]) % 256
            self.S[i], self.S[j] = self.S[j], self.S[i]
            tmp = self.S[(self.S[i] + self.S[j] + j) % 256]
            k = p ^ tmp
            cipher.append(k)
        return cipher

key = [0x5D , 0x42 , 0x62 , 0x29 , 0x3, 0x36 , 0x47 , 0x41 , 0x15, 0x36]
data = [0xF7, 0x2E, 0x34, 0xF0, 0x72, 0xCF, 0x5E, 0x0A, 0xBB, 0xEC, 0xB1, 0x2B, 0x70, 0x88, 0x88, 0xED,
0x46, 0x38, 0xDB, 0xDA, 0x6C, 0xBD, 0xD4, 0x06, 0x77, 0xF2, 0xCF, 0x56, 0x88, 0xC6, 0x31, 0xD2,
0xB7, 0x5A, 0xC1, 0x42, 0xB0, 0xF4, 0x48, 0x37, 0xF5, 0x2C, 0xF5, 0x58]

rc4 = RC4(key)
plain = rc4.rc4_encrypt(data)
print(&#39;&#39;.join(map(chr,plain)))

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-ez_exe&#34;&gt;三. ez_exe&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这里我们查壳发现是pyinstaller打包的exe&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先用pyinstxtractor进行解包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230802023358145.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后用uncompyle6进行反编译&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里有修改magic number的问题没有解决&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到：https://github.com/google/pytype/blob/main/pytype/pyc/magic.py（不同版本python对应的magic number&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以及magic number详解：http://t.csdn.cn/Lxf0T&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然而解决不了，那么我们不妨用在线反编译网站进行反编译：&lt;a href=&#34;https://www.lddgo.net/string/pyc-compile-decompile&#34;&gt;在线Python pyc文件编译与反编译 (lddgo.net)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;得到python代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Visit https://www.lddgo.net/string/pyc-compile-decompile for more information
# Version : Python 3.11

import ctypes
from time import *
from ctypes import *
from ctypes import wintypes
from hashlib import md5

class _STARTUPINFO(Structure):
    _fields_ = [
        (&#39;cb&#39;, c_ulong),
        (&#39;lpReserved&#39;, c_char_p),
        (&#39;lpDesktop&#39;, c_char_p),
        (&#39;lpTitle&#39;, c_char_p),
        (&#39;dwX&#39;, c_ulong),
        (&#39;dwY&#39;, c_ulong),
        (&#39;dwXSize&#39;, c_ulong),
        (&#39;dwYSize&#39;, c_ulong),
        (&#39;dwXCountChars&#39;, c_ulong),
        (&#39;dwYCountChars&#39;, c_ulong),
        (&#39;dwFillAttribute&#39;, c_ulong),
        (&#39;dwFlags&#39;, c_ulong),
        (&#39;wShowWindow&#39;, c_ushort),
        (&#39;cbReserved2&#39;, c_ushort),
        (&#39;lpReserved2&#39;, c_char_p),
        (&#39;hStdInput&#39;, c_ulong),
        (&#39;hStdOutput&#39;, c_ulong),
        (&#39;hStdError&#39;, c_ulong)]


class _PROCESS_INFORMATION(Structure):
    _fields_ = [
        (&#39;hProcess&#39;, c_void_p),
        (&#39;hThread&#39;, c_void_p),
        (&#39;dwProcessId&#39;, c_ulong),
        (&#39;dwThreadId&#39;, c_ulong)]

StartupInfo = _STARTUPINFO()
ProcessInfo = _PROCESS_INFORMATION()
key1 = bytes(md5(b&#39;bin1bin1bin1&#39;).hexdigest().encode())
file = open(&#39;bin1&#39;, &#39;rb&#39;).read()
arr = range(len(file))()
open(&#39;bin1&#39;, &#39;wb&#39;).write(bytes(arr))
sleep(0)
bet = ctypes.windll.kernel32.CreateProcessA(b&#39;bin1&#39;, ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), byref(StartupInfo), byref(ProcessInfo))
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ProcessInfo.hProcess), ctypes.c_int(-1))
open(&#39;bin1&#39;, &#39;wb&#39;).write(file)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行ez_exe，发现please use zhe execute file decrypt &#39;bin2&#39;  and your will get flag!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提示我们用这个去解密bin2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们运行ez_py.pyc，从而解密bin2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里是xxtea算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接写脚本逆向即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

using namespace std;

#include &amp;lt;stdint.h&amp;gt;

//delta changed
#define DELTA 0x7937B99E
#define MX (((z&amp;gt;&amp;gt;5^y&amp;lt;&amp;lt;2) + (y&amp;gt;&amp;gt;3^z&amp;lt;&amp;lt;4)) ^ ((sum^y) + (key[(p&amp;amp;3)^e] ^ z)))

void btea(uint32_t* v, int n, uint32_t const key[4]) {
	uint32_t y, z, sum;
	unsigned p, rounds, e;
	if (n &amp;gt; 1) {          /* Coding Part */
		rounds = 6 + 52 / n;
		sum = 0;
		z = v[n - 1];
		do {
			sum += DELTA;
			e = (sum &amp;gt;&amp;gt; 2) &amp;amp; 3;
			for (p = 0; p &amp;lt; n - 1; p++) {
				y = v[p + 1];
				z = v[p] += MX;
			}
			y = v[0];
			z = v[n - 1] += MX;
		} while (--rounds);
	}
	else if (n &amp;lt; -1) {  /* Decoding Part */
		n = -n;
		//round changed 
		rounds =  52 / n;
		sum = rounds * DELTA;
		y = v[0];
		do {
			e = (sum &amp;gt;&amp;gt; 2) &amp;amp; 3;
			for (p = n - 1; p &amp;gt; 0; p--) {
				z = v[p - 1];
				y = v[p] -= MX;
			}
			z = v[n - 1];
			y = v[0] -= MX;
		} while ((sum -= DELTA) != 0);
	}
}

int main()
{
	uint32_t key[4] = { 0 };
	key[0] = 0x4B5F;
	key[1] = 0xDEAD;
	key[2] = 0x11ED;
	key[3] = 0xB3CC;
	uint32_t v5[11] = { 0 };
	v5[0] = 0xCC45699D;
	v5[1] = 0x683D5352;
	v5[2] = 0xB8BB71A0;
	v5[3] = 0xD3817AD;
	v5[4] = 0x7547E79E;
	v5[5] = 0x4BDD8C7C;
	v5[6] = 0x95E25A81;
	v5[7] = 0xC4525103;
	v5[8] = 0x7049B46F;
	v5[9] = 0x5417F77C;
	v5[10] = 0x65567138;
	btea(v5, -11, key);
	for (int i = 0; i &amp;lt; 44; i++)
	{
		printf(&amp;quot;%c&amp;quot;,*((char *)v5 +i) &amp;amp; 0xff);
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;注意加密的轮数与delta都改了&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;DASCTF{7eb20cb2-deac-11ed-ae42-94085339ce84}&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四-cap&#34;&gt;四. cap&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;main函数如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;__int64 __fastcall sub_140001030(HWND hWnd)
{
  HBITMAP v2; // r14
  HDC hdcSrc; // r13
  HDC DC; // rsi
  HDC CompatibleDC; // r15
  int hSrc; // ebx
  int wSrc; // eax
  HBITMAP CompatibleBitmap; // rax
  signed int v9; // ebx
  HANDLE FileW; // rax
  void *v11; // r12
  signed int v12; // r10d
  _BYTE *v13; // r9
  int v14; // ecx
  int v15; // edx
  void *lpBuffer; // [rsp+60h] [rbp-59h]
  HGLOBAL hMem; // [rsp+68h] [rbp-51h]
  struct tagRECT Rect; // [rsp+70h] [rbp-49h] BYREF
  struct tagBITMAPINFO bmi; // [rsp+80h] [rbp-39h] BYREF
  char v21; // [rsp+ACh] [rbp-Dh]
  char v22; // [rsp+ADh] [rbp-Ch]
  char v23; // [rsp+AEh] [rbp-Bh]
  char v24; // [rsp+AFh] [rbp-Ah]
  char v25; // [rsp+B0h] [rbp-9h]
  char v26; // [rsp+B1h] [rbp-8h]
  int v27; // [rsp+B2h] [rbp-7h]
  DWORD NumberOfBytesWritten; // [rsp+B8h] [rbp-1h] BYREF
  char pv[4]; // [rsp+C0h] [rbp+7h] BYREF
  LONG v30; // [rsp+C4h] [rbp+Bh]
  UINT cLines; // [rsp+C8h] [rbp+Fh]

  NumberOfBytesWritten = 0;
  v2 = 0i64;
  hdcSrc = GetDC(0i64);
  DC = GetDC(hWnd);
  CompatibleDC = CreateCompatibleDC(DC);
  if ( CompatibleDC )
  {
    GetClientRect(hWnd, &amp;amp;Rect);                 // 检索用户坐标
    SetStretchBltMode(DC, 4);                   // 设置位图拉伸模式。
    hSrc = GetSystemMetrics(1);
    wSrc = GetSystemMetrics(0);
    if ( StretchBlt(DC, 0, 0, Rect.right, Rect.bottom, hdcSrc, 0, 0, wSrc, hSrc, 0xCC0020u) )
    {
      CompatibleBitmap = CreateCompatibleBitmap(DC, Rect.right - Rect.left, Rect.bottom - Rect.top);
      v2 = CompatibleBitmap;
      if ( CompatibleBitmap )
      {
        SelectObject(CompatibleDC, CompatibleBitmap);
        if ( BitBlt(CompatibleDC, 0, 0, Rect.right - Rect.left, Rect.bottom - Rect.top, DC, 0, 0, 0xCC0020u) )
        {
          GetObjectW(v2, 32, pv);
          bmi.bmiHeader.biWidth = v30;
          bmi.bmiHeader.biHeight = cLines;
          bmi.bmiHeader.biSize = 40;
          *(_QWORD *)&amp;amp;bmi.bmiHeader.biPlanes = 2097153i64;
          memset(&amp;amp;bmi.bmiHeader.biSizeImage, 0, 20);
          v9 = 4 * cLines * ((32 * v30 + 31) / 32);
          hMem = GlobalAlloc(0x42u, (unsigned int)v9);
          lpBuffer = GlobalLock(hMem);
          GetDIBits(DC, v2, 0, cLines, lpBuffer, &amp;amp;bmi, 0);
          FileW = CreateFileW(L&amp;quot;cap.bin&amp;quot;, 0x40000000u, 0, 0i64, 2u, 0x80u, 0i64);
          v23 ^= 0x64u;
          v24 ^= 0x61u;
          v11 = FileW;
          v25 ^= 0x73u;
          v26 ^= 0x63u;
          bmi.bmiHeader.biSize ^= &#39;yb_c&#39;;
          bmi.bmiHeader.biWidth ^= &#39;sad_&#39;;
          bmi.bmiHeader.biHeight ^= &#39;eftc&#39;;
          *(_QWORD *)&amp;amp;bmi.bmiHeader.biPlanes ^= &#39;ad_yb_cn&#39;;
          bmi.bmiColors[0].rgbReserved = ((unsigned __int16)(v9 + 54) &amp;gt;&amp;gt; 8) ^ 0x62;
          v21 = ((unsigned int)(v9 + 54) &amp;gt;&amp;gt; 16) ^ 0x79;
          v22 = ((unsigned int)(v9 + 54) &amp;gt;&amp;gt; 24) ^ 0x5F;
          v27 = &#39;nefB&#39;;
          bmi.bmiColors[0].rgbGreen = 46;
          bmi.bmiColors[0].rgbBlue = 44;
          bmi.bmiColors[0].rgbRed = (v9 + 54) ^ 0x5F;
          v12 = 0;
          bmi.bmiHeader.biSizeImage ^= &#39;ftcs&#39;;
          bmi.bmiHeader.biXPelsPerMeter ^= &#39;_cne&#39;;
          bmi.bmiHeader.biYPelsPerMeter ^= &#39;d_yb&#39;;
          bmi.bmiHeader.biClrUsed ^= &#39;tcsa&#39;;
          bmi.bmiHeader.biClrImportant ^= &#39;cnef&#39;;
          if ( v9 &amp;gt; 0 )
          {
            v13 = lpBuffer;
            do
            {
              v14 = v12 + 3;
              v15 = (unsigned __int64)(1321528399i64 * (v12 + 3)) &amp;gt;&amp;gt; 32;
              ++v12;
              *v13++ ^= aEncByDasctf[v14 - 13 * (((unsigned int)v15 &amp;gt;&amp;gt; 31) + (v15 &amp;gt;&amp;gt; 2))];
            }
            while ( v12 &amp;lt; v9 );
          }
          WriteFile(FileW, bmi.bmiColors, 0xEu, &amp;amp;NumberOfBytesWritten, 0i64);
          WriteFile(v11, &amp;amp;bmi, 0x28u, &amp;amp;NumberOfBytesWritten, 0i64);
          WriteFile(v11, lpBuffer, v9, &amp;amp;NumberOfBytesWritten, 0i64);
          GlobalUnlock(hMem);
          GlobalFree(hMem);
          CloseHandle(v11);
        }
        else
        {
          MessageBoxW(hWnd, L&amp;quot;BitBlt has failed&amp;quot;, L&amp;quot;Failed&amp;quot;, 0);
        }
      }
      else
      {
        MessageBoxW(hWnd, L&amp;quot;CreateCompatibleBitmap Failed&amp;quot;, L&amp;quot;Failed&amp;quot;, 0);
      }
    }
    else
    {
      MessageBoxW(hWnd, L&amp;quot;StretchBlt has failed&amp;quot;, L&amp;quot;Failed&amp;quot;, 0);
    }
  }
  else
  {
    MessageBoxW(hWnd, L&amp;quot;CreateCompatibleDC has failed&amp;quot;, L&amp;quot;Failed&amp;quot;, 0);
  }
  DeleteObject(v2);
  DeleteObject(CompatibleDC);
  ReleaseDC(0i64, hdcSrc);
  ReleaseDC(hWnd, DC);
  return 0i64;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果在网络上查询相关的API的话可以很清楚的了解到这些API函数在一起调用最终会实现屏幕图像截取的功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在这里动调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以发现数组的下标在0~12之间循环&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们随便打开一个BMP类型的文件，用010看看。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于BMP类型的文件前两个字节必定是&lt;code&gt;43 4D。&lt;/code&gt;既然这个加密的bmp的每一个字节进行的都是异或，那我们可以将前两个字节异或看看。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;n和c是密钥&lt;code&gt;enc_by_dasctf&lt;/code&gt;的第2个和第3个字符，按照这个序列，我们向后将密钥向后延申看看后面的情况如何。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;key = &amp;quot;enc_by_dasctf&amp;quot;
with open(&#39;cap.bin&#39;, &#39;rb&#39;) as f:
    s = bytearray(f.read())
for i in range(len(s)):
    s[i] ^= ord(key[(i+1) % len(key)])
with open(&#39;flag.bmp&#39;, &#39;wb&#39;) as f:
    f.write(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;得到flag。&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230804123426234.png&#34; alt=&#34;image-20230804123426234&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;五-unsym&#34;&gt;五. unsym&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;go语言逆向&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;golang插件恢复函数符号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;看看main_main函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;__int64 __fastcall main_main()
{
  __int64 v0; // r14
  __int128 v1; // xmm15
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v4; // rcx
  __int64 v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rdi
  __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v12; // rbx
  __int64 v13; // rbx
  __int64 v14; // rax
  unsigned __int64 v15; // rcx
  __int64 i; // rdx
  unsigned __int64 v17; // rbx
  __int64 v18; // rax
  __int64 v19; // rax
  unsigned __int64 v20; // rcx
  __int64 File; // rax
  __int64 v22; // rax
  __int64 v23; // rcx
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 j; // rcx
  __int64 v27; // rbx
  __int64 v28; // rax
  __int64 v30; // rax
  __int64 v31; // [rsp-38h] [rbp-230h]
  __int64 v32; // [rsp-38h] [rbp-230h]
  __int64 v33; // [rsp-38h] [rbp-230h]
  __int64 v34; // [rsp-30h] [rbp-228h]
  __int64 v35; // [rsp+18h] [rbp-1E0h]
  __int64 v36; // [rsp+28h] [rbp-1D0h]
  unsigned __int64 v37; // [rsp+38h] [rbp-1C0h]
  unsigned __int64 v38; // [rsp+38h] [rbp-1C0h]
  __int64 v39; // [rsp+48h] [rbp-1B0h] BYREF
  __int64 v40; // [rsp+50h] [rbp-1A8h]
  __int64 v41; // [rsp+58h] [rbp-1A0h] BYREF
  _QWORD v42[2]; // [rsp+62h] [rbp-196h]
  int v43; // [rsp+72h] [rbp-186h]
  __int16 v44; // [rsp+76h] [rbp-182h]
  __int64 v45; // [rsp+B8h] [rbp-140h]
  __int64 v46; // [rsp+C0h] [rbp-138h]
  __int64 v47; // [rsp+C8h] [rbp-130h]
  __int64 v48; // [rsp+D0h] [rbp-128h]
  __int64 v49; // [rsp+D8h] [rbp-120h]
  __int64 v50; // [rsp+E0h] [rbp-118h]
  __int64 v51; // [rsp+E8h] [rbp-110h]
  __int64 v52; // [rsp+F0h] [rbp-108h]
  __int64 v53; // [rsp+F8h] [rbp-100h]
  __int64 v54; // [rsp+100h] [rbp-F8h]
  _QWORD *v55; // [rsp+108h] [rbp-F0h]
  const char *v56; // [rsp+110h] [rbp-E8h]
  _QWORD *v57; // [rsp+118h] [rbp-E0h]
  void *v58; // [rsp+120h] [rbp-D8h]
  char **v59; // [rsp+128h] [rbp-D0h]
  __int128 v60; // [rsp+130h] [rbp-C8h]
  void *v61; // [rsp+140h] [rbp-B8h]
  char **v62; // [rsp+148h] [rbp-B0h]
  void *v63; // [rsp+150h] [rbp-A8h]
  char **v64; // [rsp+158h] [rbp-A0h]
  __int128 v65; // [rsp+160h] [rbp-98h]
  char v66; // [rsp+170h] [rbp-88h]
  __int64 v67; // [rsp+178h] [rbp-80h]
  __int128 v68; // [rsp+180h] [rbp-78h]
  char v69; // [rsp+190h] [rbp-68h]
  __int64 v70; // [rsp+198h] [rbp-60h]
  __int128 v71; // [rsp+1A0h] [rbp-58h]
  unsigned __int8 v72; // [rsp+1B0h] [rbp-48h]
  __int64 v73; // [rsp+1B8h] [rbp-40h]
  __int128 v74; // [rsp+1C0h] [rbp-38h]
  char v75; // [rsp+1D0h] [rbp-28h]
  __int64 *v76; // [rsp+1D8h] [rbp-20h]
  __int64 v77; // [rsp+1E0h] [rbp-18h]
  __int64 v78; // [rsp+1E8h] [rbp-10h]

  if ( (unsigned __int64)&amp;amp;v39 &amp;lt;= *(_QWORD *)(v0 + 16) )
    runtime_morestack_noctxt();
  v66 = 0;
  v67 = 0LL;
  v68 = v1;
  math_big__ptr_Int_SetString();
  v55 = (_QWORD *)runtime_newobject();
  *v55 = 0LL;
  v58 = &amp;amp;unk_4C9780;
  v59 = &amp;amp;off_506CD0;
  fmt_Fprint();
  v56 = &amp;quot;\b&amp;quot;;
  v57 = v55;
  fmt_Fscanln();
  v2 = *v55;
  v54 = *v55;
  v3 = v55[1];
  v40 = v3;
  v4 = 0LL;
  v5 = 0LL;
  while ( v4 &amp;lt; v3 )
  {
    v50 = v5;
    if ( *(unsigned __int8 *)(v2 + v4) &amp;gt;= 0x80u )
    {
      runtime_decoderune();
      v8 = v3;
    }
    else
    {
      v8 = v4 + 1;
    }
    v39 = v8;
    v60 = v1;
    v6 = runtime_convT64();
    *(_QWORD *)&amp;amp;v60 = &amp;quot;\b&amp;quot;;
    *((_QWORD *)&amp;amp;v60 + 1) = v6;
    fmt_Sprintf();
    v7 = runtime_concatstring2();
    v4 = v39;
    v5 = v7;
    v2 = v54;
    v3 = v40;
  }
  v41 = 65537LL;
  v75 = 0;
  v76 = &amp;amp;v41;
  v77 = 1LL;
  v78 = 1LL;
  v72 = 0;
  v73 = 0LL;
  v74 = v1;
  v69 = 0;
  v70 = 0LL;
  v71 = v1;
  math_big__ptr_Int_SetString();
  math_big__ptr_Int_exp();
  v9 = v72;
  v10 = 16LL;
  v31 = math_big_nat_itoa();
  v12 = v11;
  v47 = runtime_slicebytetostring();
  runtime_makeslice();
  if ( v12 == 57 &amp;amp;&amp;amp; (unsigned __int8)runtime_memequal() )
  {
    v13 = *v55;
    v14 = runtime_stringtoslicebyte();
    v42[0] = 0x504D5404501D282FLL;
    v42[1] = 0x3D5B2A485C5917LL;
    v43 = 54333973;
    v44 = 4888;
    for ( i = 0LL; i &amp;lt; 22; ++i )
      *((_BYTE *)v42 + i) ^= aVghpc19pc19hx2[i];
    v38 = v15;
    v49 = v14;
    v65 = v1;
    runtime_slicebytetostring();
    v30 = runtime_convTstring();
    *(_QWORD *)&amp;amp;v65 = &amp;amp;unk_4C9780;
    *((_QWORD *)&amp;amp;v65 + 1) = v30;
    v9 = 1LL;
    v10 = 1LL;
    fmt_Fprintln();
    v20 = v38;
    v19 = v49;
  }
  else
  {
    v17 = encoding_base64__ptr_Encoding_DecodeString();
    v18 = runtime_slicebytetostring();
    if ( v17 &amp;lt; 0x10 )
      runtime_panicSliceAlen(v31);
    v13 = v18;
    v19 = runtime_stringtoslicebyte();
  }
  v37 = v20;
  v49 = v19;
  File = os_ReadFile();
  if ( v9 )
  {
LABEL_26:
    v45 = v10;
    v63 = &amp;amp;unk_4C9780;
    v64 = &amp;amp;off_506CE0;
    fmt_Fprintln();
    while ( 1 )
      runtime_gopanic(v31);
  }
  v46 = File;
  v22 = crypto_aes_NewCipher();
  if ( v23 )
  {
    runtime_gopanic(v31);
    goto LABEL_26;
  }
  v51 = v13;
  v54 = v22;
  v24 = (*(__int64 (**)(void))(v22 + 24))();
  if ( !v24 )
    runtime_panicdivide();
  v35 = v24 - 7 % v24;
  v34 = runtime_makeslicecopy(v31);
  for ( j = 7LL; j &amp;lt; v35 + 7; ++j )
    *(_BYTE *)(v25 + j) = v35;
  v53 = v25;
  if ( (*(__int64 (**)(void))(v54 + 24))() &amp;gt; v37 )
LABEL_23:
    runtime_panicSliceAcap(v32, v34);
  v27 = v51;
  crypto_cipher_NewCBCEncrypter(v32, v34);
  v36 = v28;
  v48 = v27;
  v52 = runtime_makeslice();
  (*(void (**)(void))(v36 + 32))();
  if ( os_WriteFile() )
  {
    v34 = runtime_gopanic(v33);
    goto LABEL_23;
  }
  v61 = &amp;amp;unk_4C9780;
  v62 = &amp;amp;off_506CF0;
  return fmt_Fprintln();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现是个RSA加密与一个AES解密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先写一个脚本将AES的密钥解出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;n = 0x1d884d54d21694ccd120f145c8344b729b301e782c69a8f3073325b9c5
p = 37636318457745167234140808130156739
q = 21154904887215748949280410616478423
c = 0xfad53ce897d2c26f8cad910417fbdd1f0f9a18f6c1748faca10299dc8
e = 0x10001
phi=(p-1)*(q-1)
d=inverse(e,phi)
print(long_to_bytes(pow(c,d,n)))
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而且AES的密钥与偏移是一样的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接写exp将bin文件解密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from Crypto.Cipher import AES
 
password = b&#39;E@sy_RSA_enc7ypt&#39;  
iv = b&#39;E@sy_RSA_enc7ypt&#39; 
with open(&#39;encrypted.bin&#39;,&#39;rb&#39;) as f:
    en_text = f.read()
aes = AES.new(password, AES.MODE_CBC, iv)  
de_text = aes.decrypt(en_text)
with open(&#39;decrypt.exe&#39;,&#39;wb&#39;) as f:
    f.write(de_text)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行解密后的exe即有flag&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">2023DASCTF六月挑战赛二进制专项--reverse</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Tanggerr.github.io/post/kai-pian-da-xie/"" data-c="
          &lt;p&gt;首先感谢Harder师傅在百忙之中抽出时间帮我搭好博客(我懒)，感谢hygge学姐以及Yiaiyang学长在逆向和密码学方向学习的指引，引领我走向安全学习之路，感谢21安全组的学长们对我的包容与鼓励。当然，感谢Fallrain，Harder，glan，oraclepi，stone-san师傅与我并肩作战，希望安全组的各位在自己热爱的道路上继续前进，对生活与学习充满热情。&lt;br&gt;
harder是我爹&lt;/p&gt;
">开篇答谢</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>



<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas>
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
<script type="text/javascript" src="/media/js/mouse/fireworks.js"></script>


  <script src="/media/js/cool.js"></script>



  <div class="snow-container"></div>
  <script src="/media/js/bg/snow.js"></script>

</html>